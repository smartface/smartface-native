/// <reference types="node" />
declare module "global/notifications/unauthorization-status" {
    export enum UnauthorizationStatus {
        NotDetermined = 0,
        Denied = 1,
        Authorized = 2
    }
}
declare module "application/application-events" {
    export const ApplicationEvents: {
        readonly Exit: "exit";
        readonly Maximize: "maximize";
        readonly Minimize: "minimize";
        readonly ReceivedNotification: "receivedNotification";
        readonly UnhandledError: "unhandledError";
        readonly ApplicationCallReceived: "applicationCallReceived";
        readonly AppShortcutReceived: "appShortcutReceived";
        readonly BackButtonPressed: "backButtonPressed";
        readonly RequestPermissionResult: "requestPermissionResult";
    };
    export type ApplicationEvents = ExtractValues<typeof ApplicationEvents>;
}
declare module "core/eventemitter/event-emitter" {
    import Events from 'events';
    export type EventListenerCallback = (...args: any) => void;
    export interface IEventEmitter<TEvent extends string = string> {
        /**
         * Creates an event emitter instance to listen for the actions
         * @param {string} eventName
         * @param {Function} callback - Gets as any arguments as it needs
         * @returns {Function} Call the function to remove the event
         */
        on(eventName: TEvent, callback: EventListenerCallback): () => void;
        /**
         * Creates an event emitter instance to listen for the actions
         * @param {string} eventName
         * @param {Function} callback - Gets as any arguments as it needs
         * @returns {Function} Call the function to remove the event
         */
        once(eventName: TEvent, callback: EventListenerCallback): () => void;
        /**
         * Removes the specified event and invokes the callback after it is removed
         * @param {string} eventName
         * @param {Function} callback
         */
        off(eventName: TEvent, callback?: EventListenerCallback): void;
        /**
         * Triggers the event manually.
         * @param {string} event
         * @param {*} args - Arguments that needs to be passed down
         */
        emit(event: TEvent, ...args: any[]): void;
    }
    export class EventEmitter<TEvent extends string> implements IEventEmitter<TEvent> {
        protected emitter: Events.EventEmitter;
        on(eventName: TEvent, callback: EventListenerCallback): () => void;
        once(eventName: TEvent, callback: EventListenerCallback): () => void;
        off(eventName: TEvent, callback: EventListenerCallback): void;
        emit(event: TEvent, ...args: any[]): void;
        /**
         * Events of the Module in key-value notation.
         * Key means the Enum name
         * Value means the parameter to be passed to the EventEmitter
         */
        static Events: {
            [key: string]: string;
        };
    }
}
declare module "core/constructorof" {
    export type ConstructorOf<I, P = any> = new (params?: P) => I;
}
declare module "core/eventemitter/event-emitter.mixin" {
    import { EventEmitter, EventListenerCallback } from "core/eventemitter/event-emitter";
    import { ConstructorOf } from "core/constructorof";
    /**
     * This callback will be executed after the handler function is set.
     * Can get any param, can return anything.
     * @callback EventCallback
     */
    /**
     * This function will be bound to this
     * @param {Object} target - Target type, "this" should be passed
     * @param {string} event - The event to be handled
     * @param {EventCallback} callback - Pass null or empty function if you don't need to set any callback
     * @param  {Object} args - This might take multiple parameters and can get anything.
     * @returns {Function} - The function to be used on the native parts as event handler.
     */
    export function EventEmitterWrapper(target: any, event: any, callback: any, ...args: any[]): any;
    /**
     * This function adds core eventemitter functionality to the targeted class.
     * It modifies the class and the instance.
     * - It adds Events list as Class.Events as static variable
     * - It mixins the eventEmitter class if not inherited
     * - It adds relevant inheritance to the class if there is a parent class
     * - It alters the 'on' method relevant with inheritance
     *  * @example
     * ```
     * // viewGroup-Android.js
     * const Events = { ...View.Events, ...EventList }; // Inherit the Parent Events
     * const EventFunctions = {
     *   [EventsList.ViewAdded]: function() {
     *     this.onViewAdded = EventEmitterWrapper(this, EventList.ViewAdded, null);
     *   }
     * }
     *
     * function ViewGroup() {
     *   function emitterCallBack() {
     *     if (!this.didSetHierarchyChangeListener) {
     *       setHierarchyChangeListener(this);
     *     }
     *   }
     *   EventEmitterCreator(this, EventFunctions, emitterCallBack.bind(this));
     * }
     *
     * ```
     * @param {*} targetInstance this object
     * @param {*} eventFunctions Object of Functions. It will be bound to the current context using targetInstance parameter. If there is no function to inherit, pass empty object.
     * @param {*} callback This will be invoked after the relevant eventFunction is called. Will be bound to 'targetInstance' There is no filter.
     */
    export function EventEmitterMixin(TargetClass: ConstructorOf<any>): {
        new <TEvent extends string = string>(params?: any): {
            [x: string]: any;
            readonly emitter: EventEmitter<TEvent>;
            on(eventName: TEvent, callback: EventListenerCallback): () => void;
            once(eventName: TEvent, callback: EventListenerCallback): () => void;
            off(eventName: TEvent, callback: EventListenerCallback): void;
            emit(event: TEvent, ...args: any[]): void;
        };
    };
}
declare module "core/eventemitter/index" {
    export * from "core/eventemitter/event-emitter";
    export * from "core/eventemitter/event-emitter.mixin";
}
declare module "util/exception" {
    namespace Exception {
        enum TypeError {
            DEFAULT = "Parameter type must be ",
            NUMBER = "Parameter type must be number",
            STRING = "Parameter type must be string",
            BOOLEAN = "Parameter type must be boolean",
            OBJECT = "Parameter type must be object",
            ARRAY = "Parameter type must be array",
            FUNCTION = "Parameter type must be function",
            URL = "URL is not valid",
            FILE = "File is not valid"
        }
    }
    export default Exception;
}
declare module "util/type" {
    namespace TypeUtil {
        function isNumeric(param: any): boolean;
        function isBoolean(param: any): boolean;
        function isString(param: any): boolean;
        function isObject(param: any): boolean;
        function isFunction(param: any): boolean;
        function isArray(param: any): boolean;
        function isURL(param: any): boolean;
    }
    export function isNotEmpty<TValue = any>(value: TValue): value is TValue extends undefined | null ? never : TValue;
    export default TypeUtil;
}
declare module "util/iOS/uicontrolevents" {
    enum UIControlEvents {
        touchDown = 0,
        touchDownRepeat = 1,
        touchDragInside = 2,
        touchDragOutside = 3,
        touchDragEnter = 4,
        touchDragExit = 5,
        touchUpInside = 6,
        touchUpOutside = 7,
        touchCancel = 8,
        valueChanged = 9
    }
    export default UIControlEvents;
}
declare module "util/iOS/yogaenums" {
    export enum YGDirection {
        Inherit = 0,
        LTR = 1,
        RTL = 2
    }
    export enum YGFlexDirection {
        Column = 0,
        ColumnReverse = 1,
        Row = 2,
        RowReverse = 3
    }
    export enum YGJustify {
        FlexStart = 0,
        Center = 1,
        FlexEnd = 2,
        SpaceBetween = 3,
        SpaceAround = 4
    }
    export enum YGAlign {
        Auto = 0,
        FlexStart = 1,
        Center = 2,
        FlexEnd = 3,
        Stretch = 4,
        Baseline = 5,
        SpaceBetween = 6,
        SpaceAround = 7
    }
    export enum YGPositionType {
        Relative = 0,
        Absolute = 1
    }
    export enum YGWrap {
        NoWrap = 0,
        Wrap = 1,
        WrapReverse = 2
    }
    export enum YGOverflow {
        Visible = 0,
        Hidden = 1,
        Scroll = 2
    }
    export enum YGDisplay {
        Flex = 0,
        None = 1
    }
    export enum YGUnit {
        Undefined = 0,
        Point = 1,
        Percent = 2,
        tAuto = 3
    }
}
declare module "util/iOS/uidatepickermode" {
    enum UIDatePickerMode {
        time = 0,
        date = 1,
        dateAndTime = 2
    }
    export default UIDatePickerMode;
}
declare module "core/inative-component" {
    export interface INativeComponent<T extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }> {
        nativeObject: T;
    }
}
declare module "global/blob/blob" {
    import { INativeComponent } from "core/inative-component";
    /**
     * @class Blob
     * @since 0.1
     *
     * Blob is a binary large object.
     *
     *     @example
     *     const Blob = require('@smartface/native/blob');
     *     var myBase64Str = "SGVsbG8gV29ybGQ=";
     *     var blob = Blob.createFromBase64(myBase64Str);
     */
    interface IBlob extends INativeComponent {
        /**
         * Returns the type of Blob data.
         *
         * @property {String} type
         * @readonly
         * @since 0.1
         */
        readonly type: string;
        /**
         * Returns blob size.
         *
         * @property {Number} size
         * @readonly
         * @since 0.1
         */
        readonly size: number;
        /**
         * Returns a new Blob object containing the data in the specified range of bytes of the existing Blob.
         *
         * @method slice
         * @since 0.1
         */
        slice?: (start: number, end: number) => BlobBase;
        /**
         * Returns a base64 String
         *
         * @method toBase64
         * @since 0.1
         */
        toBase64: () => string;
        /**
         * Converts to base64 asynchronously
         *
         * @method toBase64Async
         * @param {Object} params Object describing parameters for the function.
         * @param {Function} params.onComplete Triggers when conversion is over.
         * @param {String} params.onComplete.base64
         * @param {Function} [params.onFailure] Triggers when failure situation occurred.
         * @android
         * @ios
         * @since 4.3.0
         */
        toBase64Async: (handlers: {
            onComplete: (base64: String) => void;
            onFailure?: () => void;
        }) => void;
        /**
         *  * Returns a utf8 String
         *
         * @method toString
         * @since 0.1
         */
        toString: () => string;
    }
    export class BlobBase implements IBlob {
        constructor(params?: Partial<BlobBase>, options?: Record<string, any>);
        nativeObject: any;
        get type(): string;
        get size(): number;
        slice(start: number, end: number): BlobBase;
        toBase64(): string;
        toBase64Async(handlers: {
            onComplete: (base64: String) => void;
            onFailure?: () => void;
        }): void;
        toString(): string;
        /**
         * Creates a blob object from given a base64String.
         *
         * @param {String} base64String
         * @method createFromBase64
         * @return Blob
         * @static
         * @since 0.1
         */
        static createFromBase64: (Base64String: string) => BlobBase;
        /**
         * Creates a blob object from given a utf8 string.
         *
         * @param {String} utf8String
         * @method createFromUTF8String
         * @return Blob
         * @static
         * @since 0.1
         */
        static createFromUTF8String: (utf8String: string) => BlobBase;
    }
    export default IBlob;
}
declare module "primitive/rectangle" {
    export type Rectangle = {
        top: number;
        left: number;
        width: number;
        height: number;
    };
}
declare module "ui/image/index" {
    import { NativeMobileComponent, WithMobileOSProps } from "core/native-mobile-component";
    import IBlob from "global/blob/blob";
    import { Rectangle } from "primitive/rectangle";
    /**
     * @class UI.Image
     * @since 0.1
     *
     * Image is used to store the image data read from the filesystem.
     * It can be set to UI objects' properties (e.g. UI.ImageView.image).
     *
     *     @example
     *     const Image = require('@smartface/native/ui/image');
     *     const ImageView = require('@smartface/native/ui/imageview');
     *
     *     var myImage = Image.createFromFile("images://smartface.png")
     *     var myImageView = new ImageView({
     *         image: myImage,
     *         width: 200, height: 200
     *     });
     *
     *     myPage.layout.addChild(myImageView);
     *
     */
    export interface IImage extends NativeMobileComponent {
        /**
         * Gets the height of image in pixels.
         *
         * @android
         * @ios
         * @property {Number} height
         * @readonly
         * @since 0.1
         */
        readonly height: number;
        /**
         * Gets the width of image in pixels.
         *
         * @android
         * @ios
         * @property {Number} width
         * @readonly
         * @since 0.1
         */
        readonly width: number;
        /**
         * Gets/Sets the autoMirrored of image. This property sets direction of Image automatically related to system or application direction.
         *
         * @ios
         * @android
         * @property {Boolean} autoMirrored
         * @since 3.1.3
         */
        autoMirrored: boolean;
        readonly android: Partial<{
            /**
             * Returns an image with rounded corners. This method returns the original image for iOS.
             *
             * @method round
             * @param {Number} radius Corner radius
             * @return UI.Image
             * @android
             * @since 2.0.10
             */
            round(radius: number): IImage;
            systemIcon: IImage;
        }>;
        readonly ios: ImageIOSProps;
        /**
         * Returns a Blob instance.
         *
         * @android
         * @ios
         * @method toBlob
         * @return Blob
         * @since 0.1
         */
        toBlob(): IBlob | null;
        /**
         * Creates a new image from existing image with specified width and height.
         * onSuccess and onFailure are optional parameters.
         *
         *     @example
         *     const Image = require('@smartface/native/ui/image');
         *     const ImageView = require('@smartface/native/ui/imageview');
         *     var myImage = Image.createFromFile("images://smartface.png")
         *     var myImageView = new ImageView();
         *     myImageView.image = myImage.resize(myImage.width/2, myImage.height/2); // resize example without callback
         *
         *
         *     const Image = require('@smartface/native/ui/image');
         *     const ImageView = require('@smartface/native/ui/imageview');
         *     var myImage = Image.createFromFile("images://smartface.png")
         *     var myImageView = new ImageView();
         *     myImage.resize(myImage.width/2, myImage.height/2, onSuccess);
         *
         *     function onSuccess(e) {
         *         myImageView.image = e.image
         *     }
         *
         * @method resize
         * @param {Number} width Width pixels of the new bitmap.
         * @param {Number} height Height pixels of the new bitmap.
         * @param {Function} onSuccess Callback for success situation.
         * @param {Object} onSuccess.params
         * @param {UI.Image} onSuccess.params.image Resized image
         * @param {Function} onFailure Callback for failure situation.
         * @param {Object} onFailure.params
         * @param {String} onFailure.params.message Failure message
         * @return UI.Image
         * @android
         * @ios
         * @since 0.1
         */
        resize(width: number, height: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IImage | null | void;
        /**
         * Returns a cropped image from existing image with specified rectangle.
         * onSuccess and onFailure are optional parameters.
         *
         * @method crop
         * @param {Number} x The x pixels of the rectangle top-left corner.
         * @param {Number} y The y pixels of the rectangle top-left corner.
         * @param {Number} width Width pixels of the new bitmap.
         * @param {Number} height Height pixels of the new bitmap.
         * @param {Function} onSuccess Callback for success situation.
         * @param {Object} onSuccess.params
         * @param {UI.Image} onSuccess.params.image Cropped image
         * @param {Function} onFailure Callback for failure situation.
         * @param {Object} onFailure.params
         * @param {String} onFailure.params.message Failure message
         * @return UI.Image
         * @android
         * @ios
         * @since 0.1
         */
        crop(x: number, y: number, width: number, height: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IImage | null | void;
        /**
         * Returns a compressed blob from existing image with given quality.
         * onSuccess and onFailure are optional parameters.
         *
         *     @example
         *     const Image = require('@smartface/native/ui/image');
         *     var myImage = Image.createFromFile("images://smartface.png")
         *     var myBlob = myImage.compress(Image.Format.JPEG, 50);
         *     var myCompressedImage = Image.createFromBlob(myBlob);
         *
         * @method compress
         * @param {UI.Image.Format} format Image format.
         * @param {Number} quality Image quality is between 0 and 100.
         * @param {Function} onSuccess Callback for success situation.
         * @param {Object} onSuccess.params
         * @param {Blob} onSuccess.params.blob Compressed data
         * @param {Function} onFailure Callback for failure situation.
         * @param {Object} onFailure.params
         * @param {String} onFailure.params.message Failure message
         * @return Blob
         * @android
         * @ios
         * @since 0.1
         */
        compress(format: Format, quality: number, onSuccess?: (e: {
            blob: IBlob;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IBlob | null | void;
        /**
         * Returns a rotated image with given angle. Rotate direction is clockwise and angle is between 0-360.
         * onSuccess and onFailure are optional parameters.
         *
         * @method rotate
         * @param {Number} angle The angle value of the rectangle top-left corner.
         * @param {Function} onSuccess Callback for success situation.
         * @param {Object} onSuccess.params
         * @param {UI.Image} onSuccess.params.image Rotated image
         * @param {Function} onFailure Callback for failure situation.
         * @param {Object} onFailure.params
         * @param {String} onFailure.params.message Failure message
         * @return UI.Image
         * @android
         * @ios
         * @since 0.1
         */
        rotate(angle: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IImage | null | void;
    }
    /**
     * @enum {Number} UI.Image.Format
     * @static
     * @since 0.1
     *
     * Specifies image compression type.
     *
     */
    export enum Format {
        /**
         * @property {Number} JPEG
         * @android
         * @ios
         * @static
         * @readonly
         * @since 0.1
         */
        JPEG = 0,
        /**
         * @property {Number} PNG
         * @android
         * @ios
         * @static
         * @readonly
         * @since 0.1
         */
        PNG = 1
    }
    /**
     * @enum {Number} UI.Image.iOS.RenderingMode
     * @since 3.1.3
     * @ios
     */
    export enum RenderingMode {
        /**
         * Use the default rendering mode for the context where the image is used.
         *
         * @property {Number} AUTOMATIC
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        AUTOMATIC = 0,
        /**
         * Always draw the original image, without treating it as a template.
         *
         * @property {Number} ORIGINAL
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        ORIGINAL = 1,
        /**
         * Always draw the image as a template image, ignoring its color information.
         *
         * @property {Number} TEMPLATE
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        TEMPLATE = 2
    }
    export type ImageAndroidProps = {} | {
        /**
         * Returns an image with rounded corners. This method returns the original image for iOS.
         *
         * @method round
         * @param {Number} radius Corner radius
         * @return UI.Image
         * @android
         * @since 2.0.10
         */
        round(radius: number): IImage;
        systemIcon: IImage;
    };
    export type ImageIOSProps = {
        /**
         * Determines how an image is rendered.
         *
         * @method imageWithRenderingMode
         * @param {UI.Image.iOS.RenderingMode} renderingMode
         * @ios
         * @return UI.Image
         * @since 3.1.3
         */
        imageWithRenderingMode(mode: RenderingMode): IImage;
        /**
         * Returns the image of automatically related to system or application direction.
         *
         * @method imageFlippedForRightToLeftLayoutDirection
         * @ios
         * @return UI.Image
         * @since 3.1.3
         */
        imageFlippedForRightToLeftLayoutDirection(): IImage;
        /**
         * Gets the renderingMode of image.
         *
         * @ios
         * @property {UI.Image.iOS.RenderingMode} renderingMode
         * @readonly
         * @since 3.2.0
         */
        renderingMode: RenderingMode;
        /**
         * A Boolean value that indicates whether the image should flip in a right-to-left layout.
         *
         * @ios
         * @property {Boolean} flipsForRightToLeftLayoutDirection
         * @readonly
         * @since 3.2.0
         */
        flipsForRightToLeftLayoutDirection: boolean;
        /**
         * Specifies the possible resizing modes for an image.
         *
         * @method resizableImageWithCapInsetsResizingMode
         * @ios
         * @param {Object} insets
         * @param {Number} insets.top
         * @param {Number} insets.left
         * @param {Number} insets.width  Width in pixels
         * @param {Number} insets.height Height in pixels
         * @param {Number} mode &emsp;UIImageResizingModeTile = 0 <br />&emsp;UIImageResizingModeStretch = 1
         * @return UI.Image
         * @since 1.1.18
         */
        resizableImageWithCapInsetsResizingMode(insets: Rectangle, mode: number): IImage;
    } | {};
    type ImageParams = {
        bitmap?: any;
        roundedBitmapDrawable?: any;
        drawable: any;
        android?: {
            systemIcon?: any;
        };
        path: any;
    };
    /**
     * @since 4.5.0
     */
    export abstract class AbstractImage<TNative extends {
        [key: string]: any;
    } = any> extends NativeMobileComponent<TNative, WithMobileOSProps<Partial<ImageParams>>> implements IImage {
        constructor(params: Partial<ImageParams>);
        compress(format: Format, quality: number, onSuccess?: (e: {
            blob: IBlob;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IBlob | null | void;
        rotate(angle: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): IImage | null | void;
        resize(width: number, height: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): null | IImage | void;
        crop(x: number, y: number, width: number, height: number, onSuccess: (e: {
            image: IImage;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): null | IImage | void;
        get height(): number;
        get width(): number;
        abstract autoMirrored: boolean;
        toBlob(): IBlob | null;
        toString(): string;
        static android: {
            createRoundedImage(params: any): IImage | null;
        };
        /**
         * Creates an Image object which built-in icon is created corresponding systemIcon value.
         * This method is Android only.
         *
         * @android
         * @static
         * @method createSystemIcon
         * @param {Number | String} systemIcon
         * @see https://developer.android.com/reference/android/R.drawable
         * @since 4.0.2
         */
        static createSystemIcon(icon: number | string): IImage;
        /**
         * Creates an image object from given a blob.
         *
         * @param {Blob} blob Contains image datas.
         * @method createFromBlob
         * @return UI.Image
         * @static
         * @android
         * @ios
         * @since 0.1
         */
        static createFromBlob(blob: IBlob): IImage | null;
        /**
         * Used privately inside framework
         * Creates an image object from image.nativeobject.
         *
         * @param {NativeObject} image Contains image datas.
         * @method createFromImage
         * @return UI.Image
         * @static
         * @android
         * @ios
         * @since 0.1
         */
        static createFromImage(image: any): IImage;
        /**
         * Used privately inside framework
         * Creates an image object from file path or image.
         *
         * @param {IImage | string} path Contains image datas.
         * @method createImageFromPath
         * @return UI.Image
         * @static
         * @android
         * @ios
         * @since 0.1
         */
        static createImageFromPath(path: IImage | string): IImage;
        /**
         * Creates a rounded image object from given path. This method works for only Android. It returns undefined for iOS.
         *
         * @param {Object} params
         * @param {String} params.path Image path
         * @param {Number} params.radius Image corner radius
         * @method createRoundedImage
         * @return UI.Image
         * @static
         * @android
         * @since 2.0.10
         */
        static createRoundedImage(params: {
            path: string;
            radius?: number;
        }): IImage;
        /**
         * Creates an Image instance from given file path. Large bitmap loading causes OutOfMemory exception on Android.
         * width and height parameters works for only Android. No-op for iOS.
         * These parameters are used loading large bitmaps efficiently. If you pass these parameters, the bitmap will scaled down.
         *
         *     @example
         *     const Image = require('@smartface/native/ui/image');
         *     var myImage = Image.createFromFile("images://smartface.png");
         *
         * @param {String} path Image file path
         * @param {Number} width Width in pixels
         * @param {Number} height Height in pixels
         * @method createFromFile
         * @return {UI.Image} An Image instance.
         * @android
         * @ios
         * @static
         * @since 0.1
         * @see https://developer.android.com/topic/performance/graphics/load-bitmap.html
         */
        static createFromFile(path: string, width?: number, height?: number): IImage | null;
        static systemDrawableId(systemIcon: number): void;
        /**
         * iOS Specific Properties.
         * @class UI.Image.iOS
         * @since 3.1.3
         */
        static readonly iOS: {
            RenderingMode: typeof RenderingMode;
            Format: typeof Format;
        };
    }
    class Imageimpl extends AbstractImage {
        autoMirrored: boolean;
    }
    const Image: typeof Imageimpl;
    type Image = Imageimpl;
    export default Image;
}
declare module "device/screen/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { IImage } from "ui/image/index";
    /**
     * @enum {String} Device.Screen.OrientationType
     * @static
     * @since 0.1
     */
    export enum OrientationType {
        UNKNOWN = "unknown",
        /**
         * @property {String} PORTRAIT
         * @ios
         * @android
         * @readonly
         * @since 0.1
         */
        PORTRAIT = "portrait",
        /**
         * @property {String} UPSIDEDOWN
         * @ios
         * @android
         * @readonly
         * @since 0.1
         */
        UPSIDEDOWN = "upsidedown",
        /**
         * @property {String} LANDSCAPELEFT
         * @ios
         * @android
         * @readonly
         * @since 0.1
         */
        LANDSCAPELEFT = "landspaceleft",
        /**
         * @property {String} LANDSCAPERIGHT
         * @ios
         * @android
         * @readonly
         * @since 0.1
         */
        LANDSCAPERIGHT = "landspaceright",
        /**
         * @property {String} FACEUP
         * @ios
         * @readonly
         * @since 0.1
         */
        FACEUP = "faceup",
        /**
         * @property {String} FACEDOWN
         * @ios
         * @readonly
         * @since 0.1
         */
        FACEDOWN = "facedown"
    }
    export interface ISCreenIOSProps {
        /**
         * Gets if device screen has support for force touch feature.
         *
         * @ios
         * @property {Boolean} forceTouchAvaliable
         * @readonly
         * @since 0.1
         */
        readonly forceTouchAvaliable?: boolean;
    }
    /**
     * @class Device.Screen
     * @since 0.1
     *
     * This class helps you to get device's screen properties like size, orientation, force touch
     * enabled etc. Also you can capture screen with Device.Screen.capture function.
     *
     *     @example
     *     const Screen = require('@smartface/native/device/screen');
     *     console.log("Device.Screen.dpi: "            + Screen.dpi);
     *     console.log("Device.Screen.width: "          + Screen.width);
     *     console.log("Device.Screen.height: "         + Screen.height);
     *     console.log("Device.Screen.touchSupported: " + Screen.touchSupported);
     *     console.log("Device.Screen.orientation: "    + Screen.orientation);
     *     console.log("Device.Screen.capture(): "      + Screen.capture());
     *
     *
     */
    export interface IScreen<TProps extends MobileOSProps<ISCreenIOSProps, {}> = MobileOSProps<ISCreenIOSProps, {}>> {
        /**
         * Gets current device screen orientation.
         *
         * @android
         * @ios
         * @property {Device.Screen.OrientationType} orientation
         * @readonly
         * @since 0.1
         */
        readonly orientation: OrientationType;
        /**
         * Gets height of device screen.
         *
         * @android
         * @ios
         * @property {Number} height
         * @readonly
         * @since 0.1
         */
        readonly height: number;
        /**
         * Gets width of device screen.
         *
         * @android
         * @ios
         * @property {Number} width
         * @readonly
         * @since 0.1
         */
        readonly width: number;
        /**
         * Gets if device screen has feature support for touching.
         *
         * @android
         * @ios
         * @property {Boolean} touchSupported
         * @readonly
         * @since 0.1
         */
        readonly touchSupported: number;
        /**
         * Gets dpi of device screen.
         *
         * @android
         * @ios
         * @property {Number} dpi
         * @readonly
         * @since 0.1
         */
        readonly dpi: number;
        /**
         * Captures screen and returns result image.
         *
         * @android
         * @ios
         * @method capture
         * @return {UI.Image} captured image.
         * @since 0.1
         */
        capture(): IImage;
        ios?: TProps['ios'];
    }
    const Screen: IScreen;
    export default Screen;
}
declare module "primitive/point2d" {
    export type Point2D = {
        x?: number | null;
        y?: number | null;
    };
}
declare module "primitive/size" {
    export type Size = {
        width: number;
        height: number;
    };
}
declare module "core/native-component" {
    type NativeInstance = Partial<Record<any, any>>;
    export default abstract class NativeComponent<TNative extends NativeInstance = NativeInstance, TProps extends Record<string, any> = Record<string, any>> {
        protected _nativeObject: any;
        constructor(params?: TProps);
        get nativeObject(): any;
        set nativeObject(value: any);
    }
}
declare module "ui/color/index" {
    import NativeComponent from "core/native-component";
    /**
     * This enumeration describes allowed direction types for gradient color.
     */
    export enum GradientDirection {
        /**
         * Indicates gradient color will start from top point with startColor and
         * will end at bottom point with endColor.
         *
         * @android
         * @ios
         * @since 0.1
         */
        VERTICAL = 0,
        /**
         * Indicates gradient color will start from left point with startColor and
         * will end at right point with endColor.
         *
         * @android
         * @ios
         * @since 0.1
         */
        HORIZONTAL = 1,
        /**
         * Indicates gradient color will start from top-left point with startColor and
         * will end at bottom-right point with endColor.
         *
         * @android
         * @ios
         * @since 0.1
         */
        DIAGONAL_LEFT = 2,
        /**
         * Indicates gradient color will start from top-right point with startColor and
         * will end at bottom-left point with endColor.
         *
         * @android
         * @ios
         * @since 0.1
         */
        DIAGONAL_RIGHT = 3
    }
    type ConstructorParams = {
        color: Color | __SF_UIColor;
    };
    /**
     * @since 0.1
     * Color is used to color UI objects and its elements. A Color instance is created by
     * passing RGB-ARGB values or hexadecimal string. There are constant and predefined colors as well.
     *
     *     @example
     *     import Color from '@smartface/native/ui/color';
     *     const myRedColor = Color.create(255, 0, 0);
     *     const myBlueColorWithAlpha = Color.create(100, 0, 0, 255);
     *     const myHEXColor = Color.create("#FFAACC");
     */
    export abstract class AbstractColor extends NativeComponent {
        constructor(params?: ConstructorParams);
        /**
         * Creates a new color with RGB-ARGB or hexadecimal parameters
         *
         *     @example
         *     import Color from '@smartface/native/ui/color';
         *     const myRedColor = Color.create(255, 0, 0);
         *     const myBlueColorWithAlpha = Color.create(100, 0, 0, 255);
         *     const myHEXColor = Color.create("#FFAACC");
         *
         * @android
         * @ios
         * @since 0.1
         */
        static create(alpha: number, red: number, green: number, blue: number): Color;
        /**
         * Creates a new color with RGB-ARGB or hexadecimal parameters
         *
         *     @example
         *     import Color from '@smartface/native/ui/color';
         *     const myRedColor = Color.create(255, 0, 0);
         *     const myBlueColorWithAlpha = Color.create(100, 0, 0, 255);
         *     const myHEXColor = Color.create("#FFAACC");
         *
         * @android
         * @ios
         * @since 0.1
         */
        static create(red: number, green: number, blue: number): Color;
        /**
         * Creates a new color with RGB-ARGB or hexadecimal parameters
         *
         *     @example
         *     import Color from '@smartface/native/ui/color';
         *     const myRedColor = Color.create(255, 0, 0);
         *     const myBlueColorWithAlpha = Color.create(100, 0, 0, 255);
         *     const myHEXColor = Color.create("#FFAACC");
         *
         * @android
         * @ios
         * @since 0.1
         */
        static create(color: string): Color;
        /**
         * @android
         * @ios
         *
         * Creates a gradient color that can be assigned to view's backgroundColor. You
         * can specify start-end colors and direction of gradient.
         * @since 0.1
         */
        static createGradient(params: {
            direction: GradientDirection;
            startColor: Color;
            endColor: Color;
        }): Color;
        abstract red(): number;
        abstract green(): number;
        abstract blue(): number;
        abstract alpha(): number;
        isGradient?: boolean;
        direction: GradientDirection;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static BLACK: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static BLUE: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static CYAN: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static DARKGRAY: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static GRAY: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static GREEN: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static LIGHTGRAY: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static MAGENTA: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static RED: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static TRANSPARENT: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static YELLOW: Color;
        /**
         * @android
         * @ios
         * @since 0.1
         */
        static WHITE: Color;
        /**
         * Returns the red value of a color instance.
         *
         *     @example
       *     import Color from '@smartface/native/ui/color';
         *
         *     const myRGBColor = Color.create(99, 0, 0);
         *     const red = Color.red(myRGBColor);
         *     console.log("" + red);
         *
      
         * @android
         * @ios
         * @since 0.1
         */
        static red(color: Color): number;
        /**
            * Returns the green value of a color instance.
            *
            *     @example
          *     import Color from '@smartface/native/ui/color';
            *
            *     const myRGBColor = Color.create(0, 171, 0);
            *     const green = Color.green(myRGBColor);
            *     console.log("" + green);
            *
         
            * @android
            * @ios
            * @since 0.1
            */
        static green(color: Color): number;
        /**
         * Returns the blue value of a color instance.
         *
         *     @example
         *     import Color from '@smartface/native/ui/color';
         *
         *     const myRGBColor = Color.create(0, 0, 155);
         *     const blue = Color.blue(myRGBColor);
         *     console.log("" + blue);
         *
         * @android
         * @ios
         * @since 0.1
         */
        static blue(color: Color): number;
        /**
         * Returns the alpha value of a color instance.
         *
         *     @example
         *     import Color from '@smartface/native/ui/color';
         *
         *     var myARGBColor = Color.create(42, 0, 0, 255);
         *     var alpha = Color.alpha(myARGBColor);
         *     console.log(alpha);
         *
         * @android
         * @ios
         * @since 0.1
         */
        static alpha(color: Color): number;
        static GradientDirection: GradientDirection;
    }
    /**
     * Only to use type of export
     */
    class ColorImpl extends AbstractColor {
        red(): number;
        green(): number;
        blue(): number;
        alpha(): number;
    }
    type Color = ColorImpl;
    const Color: typeof ColorImpl;
    export default Color;
}
declare module "util/iOS/invocation" {
    import { Point2D } from "primitive/point2d";
    import { Size } from "primitive/size";
    import Color from "ui/color/index";
    namespace Invocation {
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'NSObject'): __SF_NSOBject;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'id'): __SF_NSOBject;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'CGFloat'): number;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'CGSize'): Size;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'CGPoint'): Point2D;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'CGColor'): Color;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'CGRect'): __SF_NSRect;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'NSInteger'): number;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'NSString'): string;
        function invokeInstanceMethod(target: __SF_NSOBject, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: 'BOOL'): boolean;
        function invokeClassMethod(target: string, selector: string, argumentsArray: Invocation.Argument[], returnValueType?: string): __SF_NSOBject | undefined;
        class Argument {
            private _type;
            private _value;
            constructor(params: any);
            get type(): string;
            set type(type: string);
            get value(): any;
            set value(value: any);
        }
    }
    export default Invocation;
}
declare module "util/iOS/keyboardanimationdelegate" {
    interface KeyboardInfoParams {
        userInfo?: {
            UIKeyboardAnimationDurationUserInfoKey: number;
            UIKeyboardAnimationCurveUserInfoKey: number;
        };
        isBeginEditing?: boolean;
    }
    export default class KeyboardAnimationDelegate {
        private _top;
        private _topDistance;
        private _isKeyboadAnimationCompleted;
        private parentView;
        private parentDialog?; /** Might be wrong type */
        nativeObject: any;
        constructor(params: any);
        getParentViewController(): __SF_UIViewController;
        parent(): __SF_UIView;
        defaultTopPosition(): number;
        keyboardShowAnimation(keyboardHeight: number, e: KeyboardInfoParams, isBeginEditing?: boolean): void;
        textFieldShouldBeginEditing(): void;
        keyboardHideAnimation(e: KeyboardInfoParams): void;
        getViewTop(view: __SF_UIView): any;
        static ApplicationKeyboardHeight: number;
        static isKeyboardVisible: boolean;
        static offsetFromTop(instance: KeyboardAnimationDelegate): number;
        static statusBarFrames(self: KeyboardAnimationDelegate): {
            frame: __SF_NSRect;
            windowRect: __SF_NSRect;
            viewRect: __SF_NSRect;
        };
    }
}
declare module "util/Android/androidconfig" {
    namespace AndroidConfig {
        const isEmulator: boolean;
        const packageName: any;
        const sdkVersion: any;
        enum SDK {
            SDK_NOUGAT = 24,
            SDK_MARSHMALLOW = 23,
            SDK_LOLLIPOP = 21,
            SDK_KITKAT = 19
        }
        const activity: any;
        const activityResources: any;
        function getResourceId(resourceName: string, type: any): any;
        function getClass(className: string): any;
        function getSystemService(serviceName: string, serviceClassName: string): any;
    }
    export default AndroidConfig;
}
declare module "device/system/index" {
    /**
     * @enum {String} Device.System.OSType
     * @static
     * @since 2.0.7
     */
    export enum OSType {
        /**
         * @property {String} ANDROID
         * @android
         * @ios
         * @static
         * @readonly
         * @since 2.0.7
         */
        ANDROID = "Android",
        /**
         * @property {String} IOS
         * @android
         * @ios
         * @static
         * @readonly
         * @since 2.0.7
         */
        IOS = "iOS"
    }
    /**
     * @enum {Number} Device.System.BiometryType
     * @since 4.3.1
     * @ios
     * @android
     *
     * The set of available biometric authentication types.
     */
    export enum BiometryType {
        /**
         * The device supports the biometrics (e.g. fingerprint, iris, or face).
         *
         * @property {Number} BIOMETRICS
         * @static
         * @android
         * @readonly
         * @since 4.3.1
         */
        BIOMETRICS = 3,
        /**
         * No biometry type is supported. Works on iOS 11.0+.
         *
         * @property {Number} NONE
         * @static
         * @ios
         * @android
         * @readonly
         * @since 4.3.1
         */
        NONE = 0,
        /**
         * The device supports Touch ID. Works on iOS 11.0+.
         *
         * @property {Number} TOUCHID
         * @static
         * @ios
         * @readonly
         * @since 4.3.1
         */
        TOUCHID = 1,
        /**
         * The device supports Face ID. Works on iOS 11.0+.
         *
         * @property {Number} FACEID
         * @static
         * @ios
         * @readonly
         * @since 4.3.1
         */
        FACEID = 2
    }
    /**
     * @class Device.System
     * @since 0.1
     *
     * System provides operating system specific information of the device.
     *
     *     @example
     *     const System = require('@smartface/native/device/system');
     *     console.log("Device.System.OS: "                             + System.OS);
     *     console.log("Device.System.OSVersion: "                      + System.OSVersion);
     *     console.log("Device.System.android.apiLevel: "               + System.android.apiLevel);
     *     console.log("Device.System.batteryLevel: "                   + System.batteryLevel);
     *     console.log("Device.System.isBatteryCharged: "               + System.isBatteryCharged);
     *     console.log("Device.System.clipboard: "                      + System.clipboard);
     *     console.log("Device.System.language: "                       + System.language);
     *     console.log("Device.System.region: "                         + System.region);
     *     console.log("Device.System.android.isApplicationInstalled: " + System.android.isApplicationInstalled('io.smartface.SmartfaceApp'));
     *     console.log("Device.System.vibrate(): "                      + System.vibrate());
     *     console.log("Device.System.android.menuKeyAvaliable: "       + System.android.menuKeyAvaliable);
     *     console.log("Device.System.fingerPrintAvailable: "           + System.fingerPrintAvailable);
     *
     */
    export class AbstractSystem {
        static OS: OSType.ANDROID | OSType.IOS;
        static OSType: typeof OSType;
        /**
         *
         * Returns the device's current language set.
         * @property {String} language
         * @readonly
         * @static
         * @android
         * @ios
         * @since 0.1
         */
        static language: string;
        /**
         *
         * Returns the device's current region.
         * @property {String} region
         * @readonly
         * @static
         * @android
         * @ios
         * @since 2.0.7
         */
        static region: string;
        /**
         *
         * Returns the battery level of the device in percentage.
         * @property {Number} batteryLevel
         * @readonly
         * @static
         * @android
         * @ios
         * @since 0.1
         */
        static batteryLevel: string;
        /**
         *
         * Indicates whether the device is charged or not.
         * @property {Boolean} isBatteryCharged
         * @readonly
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static isBatteryCharged: boolean;
        /**
         *
         * Returns the operating system version of the device.
         * @property {String} OSVersion
         * @readonly
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static OSVersion: string;
        /**
         *
         * Returns the set of available biometric authentication supported by the device.
         * @property {Device.System.BiometricType} biometricType
         * @readonly
         * @ios
         * @android
         * @static
         * @since 4.3.1
         */
        static biometricType: BiometryType;
        static android: Partial<{
            /**
             *
             * Returns the api level of the Android system.
             * @property {Number} apiLevel
             * @readonly
             * @android
             * @static
             * @since 0.1
             */
            apiLevel: number;
            /**
             *
             * An ordered list of 64 bit ABIs supported by this device. The most preferred ABI is the first element in the list.
             * @property {String[]} supported64BitAbis
             * @readonly
             * @android
             * @static
             * @since 4.2.2
             */
            supported64BitAbis?: Array<String>;
            /**
             *
             * An ordered list of 32 bit ABIs supported by this device. The most preferred ABI is the first element in the list.
             * @property {String[]} supported32BitAbis
             * @readonly
             * @android
             * @static
             * @since 4.2.2
             */
            supported32BitAbis?: Array<String>;
            /**
             *
             * Indicates whether there is the menu key or not on the device.
             * @property {Boolean} menuKeyAvaliable
             * @readonly
             * @static
             * @android
             * @since 0.1
             */
            menuKeyAvaliable?: number;
            /**
             * Returns the package version of an app on the device.
             *
             *     @example
             *     System.android.getPackageVersion({
             *         packageName: "io.smartface.SmartfaceApp",
             *         onSuccess: function(versionName) {
             *             console.log("App version name:" + versionName);
             *         },
             *         onError: function(error) {
             *             console.log("Package doesnt exist");
             *         }
             *     });
             *
             * @method getPackageVersion
             * @param {String} packageName
             * @param {Function} onSuccess
             * @param {Function} onError
             * @static
             * @android
             * @since 0.1
             */
            getPackageVersion?(params: {
                packageName: string | null;
                onSuccess: (versionName: string) => void;
                onError: (error: ErrorType) => void;
            }): void;
        }>;
        static ios: Partial<{
            /**
             * @deprecated
             *
             * Indicates whether finger print operations can be used or not.
             * TouchID should be enabled to access fingerprint on iOS.
             *
             * @property {Boolean} fingerPrintAvaliable
             * @readonly
             * @ios
             * @static
             * @since 0.1
             */
            fingerPrintAvaliable: boolean;
            /**
             * @deprecated
             *
             * Checks if the provided finger print matches with the system's finger print.
             * TouchID should be enabled to access fingerprint on iOS.
             *
             *     @example
             *     System.ios.validateFingerPrint({
             *            message : "Message",
             *            onSuccess : function(){
             *                  console.log("Success");
             *            },
             *            onError : function(){
             *                  console.log("Error");
             *            }
             *      });
             * @method validateFingerPrint
             * @param {String} message
             * @param {Function} onSuccess
             * @param {Function} onError
             * @static
             * @ios
             * @since 0.1
             */
            validateFingerPrint(params: {
                message: string;
                onSuccess: () => void;
                onError: () => void;
            }): void;
        }>;
        /**
         * Checks if the provided finger print matches with the system's finger print.
         * Will be false if TouchID not enabled for iOS and user not enrolled at least one
         * fingerprint for Android or hardware not supported by both of iOS and Android.
         * Requires {@link Application.android.Permissions#USE_FINGERPRINT} permission on AndroidManifest.
         * iOS only propery is deprecated.
         *
         *     @example
         *     System.validateFingerPrint({
         *            android: {
         *                title: "Title"
         *            },
         *            message : "Message",
         *            onSuccess : function(){
         *                  console.log("Success");
         *            },
         *            onError : function(){
         *                  console.log("Error");
         *            }
         *      });
         * @method validateFingerPrint
         * @param {String} message
         * @param {Object} android
         * @param {String} android.title
         * @param {Function} onSuccess
         * @param {Function} onError
         * @static
         * @ios
         * @android
         * @since 1.1.13
         * @deprecated since 4.3.1 Use {@link Device.System#validateBiometric}
         */
        static validateFingerPrint(params: {
            android: Partial<{
                title: string;
            }>;
            message: string;
            onSuccess: () => void;
            onError: () => void;
        }): void;
        /**
         * Shows the biometric prompt to the user. It will trigger onError callback if the biometric not enabled for iOS and user not enrolled at least one
         * for Android or hardware not supported by both of iOS and Android.
         *
         *     @example
         *     System.validateBiometric({
         *            android: {
         *                title: "Title",
         *                cancelButtonText: "Cancel",
         *                subTitle: "SubTitle",
         *                confirmationRequired: true
         *            },
         *            message : "Message",
         *            onSuccess : function(){
         *                  console.log("Success");
         *            },
         *            onError : function(cancelled, error){
         *                  console.log("Error");
         *            }
         *      });
         * @method validateBiometric
         * @param {String} message Sets the message for the biometric. It's required for Android.
         * @param {Object} android
         * @param {String} android.title Sets the title for the biometric. It's required for Android.
         * @param {String} android.subTitle Sets the subtitle for the biometric.
         * @param {String} [android.cancelButtonText = 'Cancel'] Sets the text for the cancel button on the biometric. It's required for Android.
         * @param {Boolean} [android.confirmationRequired = true] Sets a system hint for whether to require explicit user confirmation after a passive biometric (e.g. face) has been recognized but before    onSuccess is called.
         * @param {Function} onSuccess
         * @param {Function} onError
         * @param {String} onError.cancelled A boolean indicating that if the biometric prompt cancelled. `undefined` in iOS.
         * @param {String} onError.error A human-readable error string that can be shown on an UI. `undefined` in iOS.
         * @static
         * @ios
         * @android
         * @since 4.3.1
         */
        static validateBiometric(params: {
            android: {
                title: string;
                cancelButtonText?: string;
                subTitle?: string;
                confirmationRequired?: boolean;
            };
            message: string;
            onSuccess: () => void;
            onError: (cancelled?: boolean, error?: string) => void;
        }): void;
        /**
         * Return value shows that if the device supports feature or not.
         * Also it would be show that fingerprint (for Android) or
         * TouchID (for iOS) is defined or not defined on the phone,
         * You need to add {@link Application.android.Permissions#USE_FINGERPRINT}
         * permission on AndroidManifest under config/Android when you publish project.
         *
         * @property {Boolean} fingerPrintAvailable
         * @readonly
         * @ios
         * @android
         * @static
         * @since 1.1.13
         * @deprecated since 4.3.1 Use {@link Device.System#biometricsAvailable}
         */
        static fingerPrintAvailable: boolean;
        /**
         * Returns true if the device supports the biometric feature and at least one the biometric is enrolled by user.
         *
         * @property {Boolean} biometricsAvailable
         * @readonly
         * @ios
         * @android
         * @static
         * @since 4.3.1
         */
        static biometricsAvailable: boolean;
        /**
         * clipboard can be used to set a text to the device's clipboard or get a text from it.
         *
         * @property {String} clipboard
         * @readonly
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static clipboard: string | null;
        /**
         * Determine if the current running platform is Smartface Emulator or published application
         *
         * @property {String} isEmulator
         * @readonly
         * @android
         * @ios
         * @static
         * @since 4.4.0
         */
        static isEmulator: string;
        /**
         * Vibrates the device for a while. iOS ignores given parameter.
         *
         * @method vibrate
         * @param {Object} params
         * @param {Number} params.millisecond
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static vibrate(params: {
            millisecond: number;
        }): void;
        /**
         * Checks if an app is installed or not.
         * @method isApplicationInstalled
         * @param {String} packageName | schemaName
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static isApplicationInstalled(packageName: string): void;
        /**
         * @enum {Number} Device.System.BiometryType
         * @since 4.3.1
         * @ios
         * @android
         *
         * The set of available biometric authentication types.
         */
        static readonly BiometryType: BiometryType;
    }
    const System: typeof AbstractSystem;
    type System = AbstractSystem;
    export default System;
}
declare module "application/statusbar/index" {
    import Color from "ui/color/index";
    enum StatusBarStyle {
        DEFAULT = 0,
        LIGHTCONTENT = 1
    }
    export abstract class AbstractStatusBar {
        abstract height: number;
        abstract backgroundColor: Color;
        abstract visible: boolean;
        abstract style: StatusBarStyle;
        android: {
            color?: Color;
            transparent?: boolean;
        };
    }
    class StatusBarImpl extends AbstractStatusBar {
        height: number;
        backgroundColor: Color;
        visible: boolean;
        style: StatusBarStyle;
    }
    export type StatusBar = StatusBarImpl;
    export const StatusBar: StatusBar;
}
declare module "ui/view/view-event" {
    export const ViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type ViewEvents = ExtractValues<typeof ViewEvents>;
}
declare module "ui/viewgroup/viewgroup-events" {
    export const ViewGroupEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly ViewAdded: "viewAdded";
        readonly ViewRemoved: "viewRemoved";
    };
    export type ViewGroupEvents = ExtractValues<typeof ViewGroupEvents>;
}
declare module "ui/flexlayout/flexlayout-events" {
    export const FlexLayoutEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly ViewAdded: "viewAdded";
        readonly ViewRemoved: "viewRemoved";
        readonly InterceptTouchEvent: "interceptTouchEvent";
    };
    export type FlexLayoutEvents = ExtractValues<typeof FlexLayoutEvents>;
}
declare module "core/eventemitter/EventType" {
    export type EventType = string | {
        [key: string]: string;
    };
}
declare module "core/eventemitter/extract-event-values" {
    import { EventType } from "core/eventemitter/EventType";
    export type ExtractEventValues<TEvent extends EventType> = Uncapitalize<TEvent extends {
        [key: string]: string;
    } ? ExtractValues<TEvent> : TEvent>;
}
declare module "core/flex" {
    namespace Flex {
        enum Direction {
            /**
             * @property {Number} INHERIT
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            INHERIT = 0,
            /**
             * @property {Number} LTR
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            LTR = 1,
            /**
             * @property {Number} RTL
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            RTL = 2
        }
        /**
         * @enum {Number} UI.FlexLayout.FlexDirection
         * @static
         * @readonly
         * @since 0.1
         *
         */
        enum FlexDirection {
            /**
             * @property {Number} COLUMN
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            COLUMN = 0,
            /**
             * @property {Number} COLUMN_REVERSE
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            COLUMN_REVERSE = 1,
            /**
             * @property {Number} ROW
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            ROW = 2,
            /**
             * @property {Number} ROW_REVERSE
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            ROW_REVERSE = 3
        }
        /**
         * @enum {Number} UI.FlexLayout.JustifyContent
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         * // @todo add description.
         *
         *
         */
        enum JustifyContent {
            /**
             * @property {Number} FLEX_START
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_START = 0,
            /**
             * @property {Number} CENTER
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            CENTER = 1,
            /**
             * @property {Number} FLEX_END
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_END = 2,
            /**
             * @property {Number} SPACE_BETWEEN
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            SPACE_BETWEEN = 3,
            /**
             * @property {Number} SPACE_AROUND
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            SPACE_AROUND = 4
        }
        /**
         * @enum {Number} UI.FlexLayout.AlignContent
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         * // @todo add description.
         *
         *     @example
         *     // @todo add example
         *
         */
        enum AlignContent {
            /**
             * @property {Number} AUTO
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            AUTO = 0,
            /**
             * @property {Number} FLEX_START
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_START = 1,
            /**
             * @property {Number} CENTER
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            CENTER = 2,
            /**
             * @property {Number} FLEX_END
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_END = 3,
            /**
             * @property {Number} STRETCH
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            STRETCH = 4
        }
        /**
         * @enum {Number} UI.FlexLayout.FlexWrap
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         */
        enum FlexWrap {
            /**
             * @property {Number} NOWRAP
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            NOWRAP = 0,
            /**
             * @property {Number} WRAP
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            WRAP = 1
        }
        /**
         * @enum {Number} UI.FlexLayout.AlignItems
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         * // @todo add description.
         *
         *     @example
         *     // @todo add example
         *
         */
        enum AlignItems {
            /**
             * @property {Number} AUTO
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            AUTO = 0,
            /**
             * @property {Number} FLEX_START
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_START = 1,
            /**
             * @property {Number} CENTER
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            CENTER = 2,
            /**
             * @property {Number} FLEX_END
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_END = 3,
            /**
             * @property {Number} STRETCH
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            STRETCH = 4
        }
        /**
         * @enum {Number} UI.FlexLayout.AlignSelf
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         */
        enum AlignSelf {
            /**
             * @property {Number} AUTO
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            AUTO = 0,
            /**
             * @property {Number} FLEX_START
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_START = 1,
            /**
             * @property {Number} CENTER
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            CENTER = 2,
            /**
             * @property {Number} FLEX_END
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            FLEX_END = 3,
            /**
             * @property {Number} STRETCH
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            STRETCH = 4
        }
        /**
         * @enum UI.FlexLayout.PositionType
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         *
         */
        enum PositionType {
            /**
             * @property RELATIVE
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            RELATIVE = 0,
            /**
             * @property ABSOLUTE
             * @static
             * @android
             * @ios
             * @readonly
             * @since 0.1
             */
            ABSOLUTE = 1
        }
    }
    export default Flex;
}
declare module "ui/view/index" {
    import Color from "ui/color/index";
    import { Point2D } from "primitive/point2d";
    import { ViewEvents } from "ui/view/view-event";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps, WithMobileOSProps } from "core/native-mobile-component";
    import { IEventEmitter } from "core/eventemitter/index";
    import { ExtractEventValues } from "core/eventemitter/extract-event-values";
    import Flex from "core/flex";
    import { INativeComponent } from "core/inative-component";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    export interface IViewState<Property = any> {
        normal?: Property;
        disabled?: Property;
        selected?: Property;
        pressed?: Property;
        focused?: Property;
    }
    export type ViewAndroidProps = {
        readonly yogaNode: any;
        overScrollMode: number;
        /**
         * Gets/sets foreground of the view for ripple effect. This property should be set before rippleColor.
         * This property only supported for api level 23 and above.
         *
         * @property {Boolean} [useForeground = false]
         * @android
         * @member UI.View
         * @since 4.0.2
         */
        useForeground: boolean;
        /**
         * Gets/sets ripple effect enabled for view. You should set {@link UI.View#rippleColor rippleColor}
         * to see the effect.
         *
         * @property {Boolean} [rippleEnabled = false]
         * @android
         * @member UI.View
         * @since 3.2.1
         */
        rippleEnabled: boolean;
        /**
         * Gets/sets ripple effect color for view.
         *
         * @property {UI.Color} rippleColor
         * @android
         * @member UI.View
         * @since 3.2.1
         */
        rippleColor: Color;
        /**
         * Gets/Sets the elevation of the view. For the views that has
         * StateListAnimator natively like Button, will lost its own
         * StateListAnimation when elevation value changed.
         * For details : https://developer.android.com/training/material/shadows-clipping.html
         *
         * @property {Number} elevation
         * @android
         * @member UI.View
         * @see https://developer.android.com/training/material/shadows-clipping.html
         * @see https://developer.android.com/reference/android/view/View.html#setStateListAnimator(android.animation.StateListAnimator)
         * @since 1.1.12
         */
        elevation: number;
        /**
         * Gets/sets the depth location of the view relative to its elevation. To put view over button,
         * you have to change zIndex value after Android Lollipop. On android, default elevation value of button is bigger than other view.
         * This property affects after Android Lollipop. No-op before api level 21.
         *
         * @property {Number} zIndex
         * @android
         * @member UI.View
         * @since 2.0.8
         */
        zIndex: number;
        updateRippleEffectIfNeeded: () => void;
    };
    export type ViewIOSProps = {
        /**
         * Setting this property to TRUE causes the receiver to block the delivery of touch events to other views.
         * The default value of this property is false
         *
         * @property {Boolean} [exclusiveTouch = false]
         * @ios
         * @since 2.0.10
         */
        exclusiveTouch: boolean;
        /**
         * A Boolean value that determines whether subviews are confined to the bounds of the view.
         *
         * @property {Boolean} [clipsToBounds = false]
         * @ios
         * @since 1.1.15
         */
        clipsToBounds: number;
        /**
         * A Boolean value that determines whether subviews are confined to the bounds of the view.
         *
         * @property {Boolean} [masksToBounds = false]
         * @ios
         * @since 1.1.15
         */
        masksToBounds: boolean;
        /**
         * The offset (in points) of the shadow. "ios.masksToBounds" property must be false for shadow.
         *
         *     @example
         *     view.ios.masksToBounds = false;
         *     view.ios.shadowOffset = {x:10,y:10};
         *     view.ios.shadowRadius = 5;
         *     view.ios.shadowOpacity = 0.5;
         *     view.ios.shadowColor = Color.GRAY;
         *
         * @property {Object} [shadowOffset = {x: 0.0,y: -3.0}]
         * @property {Number} shadowOffset.x
         * @property {Number} shadowOffset.y
         * @ios
         * @since 2.0.6
         */
        shadowOffset: Point2D;
        /**
         * The blur radius (in points) used to render the shadow. "ios.masksToBounds" property must be false for shadow.
         *
         * @property {Number} [shadowRadius = 3]
         * @ios
         * @since 2.0.6
         */
        shadowRadius: number;
        /**
         * The value in this property must be in the range 0.0 (transparent) to 1.0 (opaque). "ios.masksToBounds" property must be false for shadow.
         *
         * @property {Number} [shadowOpacity = 0]
         * @ios
         * @since 2.0.6
         */
        shadowOpacity: number;
        /**
         * The color of the shadow. "ios.masksToBounds" property must be false for shadow.
         *
         * @property {UI.Color} [shadowColor = UI.Color.BLACK]
         * @ios
         * @since 2.0.6
         */
        shadowColor: Color;
        /**
         *
         * Changes the direction of unreachable child views of all components. These components are HeaderBar, BottomBar, Material Textbox, Searchview, SwipeView etc.
         *
         * @property {UI.View.iOS.SemanticContentAttribute} [viewAppearanceSemanticContentAttribute = UI.View.iOS.SemanticContentAttribute.AUTO]
         * @ios
         * @static
         * @since 3.1.3
         */
        viewAppearanceSemanticContentAttribute: SemanticContentAttribute;
        /**
         * Disables a view transition animation.
         *
         * @method performWithoutAnimation
         * @param {Function} functionWithoutAnimation
         * @ios
         * @since 4.2.1
         */
        performWithoutAnimation: (functionWithoutAnimation: Function) => void;
    };
    export interface IViewProps<TProps extends MobileOSProps<ViewIOSProps, ViewAndroidProps> = MobileOSProps<ViewIOSProps, ViewAndroidProps>> extends INativeComponent {
        /**
         * Gets/sets the transitionId to be used for transitionViews. See transitionViews for more information
         * @property {String} transitionId
         * @android
         * @ios
         * @since 0.1
         */
        transitionId: string;
        /**
         * Gets/sets whether the view is an accessibility element that an assistive app can access.
         *
         * @property {Boolean} accessible
         * @android
         * @ios
         * @member UI.View
         * @since 4.3.2
         */
        accessible: boolean;
        /**
         * A content description briefly describes the view. VoiceOver will read this string when a user selects the associated element.
         *
         * @property {String} accessibilityLabel
         * @android
         * @ios
         * @member UI.View
         * @since 4.3.2
         */
        accessibilityLabel: string;
        /**
         * Defines the opacity of a view. The value of this property is a float number
         * between 0.0 and 1.0. 0 represents view is completely transparent and 1
         * represents view is completely opaque.
         *
         * @property {Number} [alpha = 1]
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         */
        alpha: number;
        /**
         * Gets/sets background color of a view. It allows setting background
         * color with UI.Color instance.
         *
         * @property {UI.Color} [backgroundColor = UI.Color.WHITE]
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         */
        backgroundColor: Color | IViewState<Color>;
        /**
         * Sets/gets border color of bounded view.
         *
         * @property {UI.Color} [borderColor = UI.Color.BLACK]
         * @android
         * @ios
         * @since 0.1
         */
        borderColor: Color;
        /**
         * Sets/gets border thickness of bounded view. Accepts unsigned
         * numbers, 0 means no border.
         *
         * @property {Number} [borderWidth = 0]
         * @android
         * @ios
         * @since 0.1
         */
        borderWidth: number;
        /**
         * Sets/gets corner radius of a view. BorderRadius maximum value must be half of the shortest edge.
         *
         * @property {Number} [borderRadius = 0]
         * @android
         * @ios
         * @since 0.1
         */
        borderRadius: number;
        /**
         * Gets/sets id of a view. It should be unique number for each object
         * inside page. Id will be generated unique by default.
         *
         * @property {Number} id
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         */
        id: string;
        /**
         * Gets/sets test id for view. resource-id for android; accessibilityIdentifier for iOS.
         *
         * @property {Number} testId
         * @android
         * @ios
         * @member UI.View
         * @since 4.3.2
         */
        testId: string;
        /**
         * Gets/sets visibility of view. It is set to true as default.
         *
         * @property {Boolean} [visible = true]
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         */
        visible: boolean;
        /**
         * Gets/sets the degrees that the view is rotated around the pivot point.
         *
         * @property {Number} [rotation = 0]
         * @android
         * @ios
         * @member UI.View
         * @since 1.1.10
         */
        rotation: number;
        /**
         * Gets/sets the degrees that the view is rotated around the horizontal axis through the pivot point.
         * RotationX works different for iOS and Android. Android gives perpective to the view but iOS doesn't.
         * This will cause difference on user interface.
         *
         * @property {Number} [rotationX = 0]
         * @android
         * @ios
         * @member UI.View
         * @since 1.1.10
         */
        rotationX: number;
        /**
         * Gets/sets the degrees that the view is rotated around the vertical axis through the pivot point.
         * RotationY works different for iOS and Android. Android gives perpective to the view but iOS doesn't.
         * This will cause difference on user interface.
         *
         * @property {Number} [rotationY = 0]
         * @android
         * @ios
         * @member UI.View
         * @since 1.1.10
         */
        rotationY: number;
        /**
         * Enables/disables touches to view. When set to false events
         * related to touches won't fire. It is set to true as default.
         *
         * @property {Boolean} [touchEnabled = true]
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         */
        touchEnabled: boolean;
        /**
         * Gets/sets left position of a view relative to its parent.
         *
         * @property {Number} [left = 0]
         * @android
         * @ios
         * @since 0.1
         */
        left: number;
        /**
         * Gets/sets top position of a view relative to its parent.
         *
         * @property {Number} [top = 0]
         * @android
         * @ios
         * @since 0.1
         */
        top: number;
        /**
         * Gets/sets right position of a view relative to its parent. This property works only if
         * view's positionType is UI.FlexLayout.PositionType.ABSOLUTE.
         *
         * @property {Number} [right = 0]
         * @android
         * @ios
         * @since 0.1
         */
        right: number;
        /**
         * Gets/sets bottom position of a view relative to its parent. This property works only if
         * view's positionType is UI.FlexLayout.PositionType.ABSOLUTE.
         *
         * @property {Number} [bottom = 0]
         * @android
         * @ios
         * @since 0.1
         */
        bottom: number;
        /**
         * Gets/sets height of a view.
         *
         * @property {Number} [height = 0]
         * @android
         * @ios
         * @since 0.1
         */
        height: number;
        /**
         * Gets/sets width of a view.
         *
         * @property {Number} [width = 0]
         * @android
         * @ios
         * @since 0.1
         */
        width: number;
        /**
         * Gets/sets minimum width of a view.
         *
         * @property {Number} [minWidth = 0]
         * @android
         * @ios
         * @since 0.1
         */
        minWidth: number;
        /**
         * Gets/sets minimum height of a view.
         *
         * @property {Number} [minHeight = 0]
         * @android
         * @ios
         * @since 0.1
         */
        minHeight: number;
        /**
         * Gets/sets maximum width of a view.
         *
         * @property {Number} [maxWidth = 0]
         * @android
         * @ios
         * @since 0.1
         */
        maxWidth: number;
        /**
         * Gets/sets maximum height of a view.
         *
         * @property {Number} [maxHeight = 0]
         * @android
         * @ios
         * @since 0.1
         */
        maxHeight: number;
        /**
         * Gets/Sets the padding space on the top side of a view.
         *
         * @property {Number} [paddingTop = 0]
         * @android
         * @ios
         * @since 0.1
         */
        paddingTop: number;
        /**
         * Gets/Sets the padding space on the bottom side of a view.
         *
         * @property {Number} [paddingBottom = 0]
         * @android
         * @ios
         * @since 0.1
         */
        paddingBottom: number;
        /**
         * Gets/Sets the padding space on the left side of a view.
         *
         * @property {Number} [paddingLeft = 0]
         * @android
         * @ios
         * @since 0.1
         */
        paddingLeft: number;
        /**
         * Gets/Sets the padding space on the right side of a view.
         *
         * @property {Number} [paddingRight = 0]
         * @android
         * @ios
         * @since 0.1
         */
        paddingRight: number;
        /**
         * Gets/Sets the padding space on the all sides of a view.
         *
         * @property {Number} [padding = 0]
         * @android
         * @ios
         * @since 0.1
         */
        padding: number;
        /**
         * Gets/Sets the margin space on the top side of a view.
         *
         * @property {Number} [marginTop = 0]
         * @android
         * @ios
         * @since 0.1
         */
        marginTop: number;
        /**
         * Gets/Sets the margin space on the bottom side of a view.
         *
         * @property {Number} [marginBottom = 0]
         * @android
         * @ios
         * @since 0.1
         */
        marginBottom: number;
        /**
         * Gets/Sets the margin space on the left side of a view.
         *
         * @property {Number} [marginLeft = 0]
         * @android
         * @ios
         * @since 0.1
         */
        marginLeft: number;
        /**
         * Gets/Sets the margin space required on the right side of a view.
         *
         * @property {Number} [marginRight = 0]
         * @android
         * @ios
         * @since 0.1
         */
        marginRight: number;
        /**
         * Gets/Sets the margin space required on the all sides of a view.
         *
         * @property {Number} [margin = 0]
         * @android
         * @ios
         * @since 0.1
         */
        margin: number;
        /**
         * This property specifies the type of positioning method used for a view.
         * To position a view relative to its parent with top,left,right and bottom
         * properties you must set the position type to absolute.
         *
         * @property {UI.FlexLayout.PositionType} [positionType = UI.FlexLayout.PositionType.RELATIVE]
         * @android
         * @ios
         * @since 0.1
         */
        positionType: Flex.PositionType;
        /**
         * This property specifies how much a view will grow relative to the other views inside the same {@link UI.FlexLayout FlexLayout}.
         *
         * @property {Number} [flexGrow = 0]
         * @android
         * @ios
         * @since 0.1
         */
        flexGrow: number;
        /**
         * AspectRatio keeps the ratio between the width and the height of a view. AspectRatio has higher priority than {@link UI.View#flexGrow flexGrow}.
         *
         * @property {Number} aspectRatio
         * @android
         * @ios
         * @since 0.1
         */
        aspectRatio: number;
        /**
         * This property specifies how much a view will shrink relative to the other views inside the same {@link UI.FlexLayout FlexLayout}.
         *
         * @property {Number} [flexShrink = 1]
         * @android
         * @ios
         * @since 0.1
         */
        flexShrink: number;
        /**
         * This property specifies the initial length of a view in a {@link UI.FlexLayout FlexLayout}.
         *
         * @property {Number} [flexBasis = -1]
         * @android
         * @ios
         * @since 0.1
         */
        flexBasis: number;
        /**
         * This property sets the amount that the view is scaled in X & Y around the pivot point, as a proportion of the view's unscaled width. A value of 1 means that no scaling is applied.
         * Actually {@link UI.flipVertically flipVertically} & {@link UI.flipHorizontally flipHorizontally} functions are assignes -1 to X & Y to mirror the view. So while using scale, need to
         * consider these functions.
         *
         * @property {Object} scale
         * @android
         * @ios
         * @since 4.0.1
         */
        scale: Point2D;
        /**
         * This property specifies how a child view aligns in the cross-axis.
         * It overrides the {@link UI.FlexLayout.AlignItems FlexLayout.AlignItems} property of the parent.
         *
         * @property {UI.FlexLayout.AlignSelf} [alignSelf = UI.FlexLayout.AlignSelf.AUTO]
         * @android
         * @ios
         * @since 0.1
         */
        alignSelf: Flex.AlignSelf;
        android: TProps['android'];
        ios: TProps['ios'];
        /**
         * A Boolean indicating whether sublayers are clipped to the layers bounds. Android sublayers still overlaps the border's width and
         * as known issue,if {@link UI.View#maskedBorders maskedBorders} is used then sublayer won't be clipped.
         *
         * @property {Boolean} [masksToBounds = true]
         * @ios
         * @android
         * @since 4.1.4
         */
        masksToBounds: boolean;
        /**
         * Specified enums indicates that which corner of View will have radius.
         *
         * @property {UI.View.Border[]} [maskedBorders = [View.Border.TOP_LEFT, View.Border.TOP_RIGHT, View.Border.BOTTOM_RIGHT, View.Border.BOTTOM_LEFT]]
         * @ios
         * @android
         * @since 4.1.4
         */
        maskedBorders: Border[];
    }
    /**
     * @class UI.View
     * @since 0.1
     *
     * View class represents a rectangular area on the screen and it is responsible
     * for event handling. View is the base of all UI classes.
     *
     *     @example
     *     const View = require('@smartface/native/ui/view');
     *     const Color = require('@smartface/native/ui/color');
     *     var myView = new View();
     *     myView.width = 300;
     *     myView.height = 500;
     *     myView.top = 50;
     *     myView.left = 50;
     *     myView.backgroundColor = Color.RED;
     *
     */
    export interface IView<TEvent extends string = ViewEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TMobileProps extends MobileOSProps<ViewIOSProps, ViewAndroidProps> = MobileOSProps<ViewIOSProps, ViewAndroidProps>> extends Omit<IViewProps<TMobileProps>, 'nativeObject'>, IEventEmitter<TEvent | ViewEvents>, INativeComponent<TNative> {
        parent: IView | undefined;
        readonly uniqueId: string;
        applyLayout(): void;
        /**
         * This method put a view to the top of other views in z-direction.
         *
         * @method bringToFront
         * @android
         * @ios
         * @since 0.1
         */
        bringToFront(): void;
        /**
         * This method flips the view horizontally.
         *
         * @method flipHorizontally
         * @android
         * @ios
         * @since 3.1.3
         */
        flipHorizontally(): void;
        /**
         * This method flips the view vertically.
         *
         * @method flipVertically
         * @android
         * @ios
         * @since 3.1.3
         */
        flipVertically(): void;
        /**
         * This method returns an object that defines view location on screen.
         * Do not use this method for invisible views in {@link UI.ListView ListView} and {@link UI.GridView GridView}.
         *
         * @method getScreenLocation
         * @return {Object} location
         * @return {Number} location.x
         * @return {Number} location.y
         * @android
         * @ios
         * @since 3.2.0
         */
        getScreenLocation(): Point2D;
        /**
         * Gets the parent view of a view.
         *
         *     @example
         *     const FlexLayout = require('@smartface/native/ui/flexlayout');
         *     const Label = require('@smartface/native/ui/label');
         *
         *     var myFlexLayout = new FlexLayout();
         *     myFlexLayout.id = 5432;
         *
         *     var myLabel = new Label({
         *          text: "Smartface Label"
         *     });
         *     myFlexLayout.addChild(myLabel);
         *     var parentId = myLabel.getParent().id; //is equal to 5432.
         *
         * @return {UI.ViewGroup} Parent view of a view, null if not exists.
         * @method getParent
         * @android
         * @ios
         * @since 0.1
         */
        getParent(): IView | null;
        /**
         * This event is called when a touch screen motion event starts.
         *
         * @event onTouch
         * @deprecated This method is deprecated in favor of EventEmitter. You could get more details for the deprecated events from here https://docs.smartface.io/smartface-native-framework/tips-and-tricks/handling-events
         * @return {Boolean} True if the listener has consumed the event, false otherwise.
         * @param {Object} motionEvent
         * @param {Number} motionEvent.x
         * @param {Number} motionEvent.y
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         * @example
         * ````
         * import View from '@smartface/native/ui/view';
         * import FlexLayout from '@smartface/native/ui/flexlayout';
         * import Button from '@smartface/native/ui/button';
         *
         * this.view1.on(View.Events.Touch, (point) => {
         * 	console.info('view onTouch', point);
         * });
         * this.flexLayout1.on(FlexLayout.Events.Touch, (point) => {
         * 	console.info('flexLayout onTouch', point);
         * });
         * this.button1.on(Button.Events.Touch, (point) => {
         * 	console.info('button onTouch', point);
         * });
         * ````
         */
        onTouch: (e?: Point2D) => void | boolean;
        /**
         * This event is called when a touch screen motion event ends. If touch position inside this view, isInside parameter will be true.
         *
         * @event onTouchEnded
         * @deprecated This method is deprecated in favor of EventEmitter. You could get more details for the deprecated events from here https://docs.smartface.io/smartface-native-framework/tips-and-tricks/handling-events
         * @return {Boolean} True if the listener has consumed the event, false otherwise.
         * @param {Boolean} isInside This argument is deprecated. Use motionEvent's property.
         * @param {Object} motionEvent
         * @param {Boolean} motionEvent.isInside
         * @param {Number} motionEvent.x
         * @param {Number} motionEvent.y
         * @android
         * @ios
         * @member UI.View
         * @since 0.1
         * @example
         * ````
         * import View from '@smartface/native/ui/view';
         * import FlexLayout from '@smartface/native/ui/flexlayout';
         * import Button from '@smartface/native/ui/button';
         *
         * this.view1.on(View.Events.TouchEnded, (isInside, point) => {
         * 	console.info('view onTouchEnded', isInside, point);
         * });
         * this.flexLayout1.on(FlexLayout.Events.TouchEnded, (isInside, point) => {
         * 	console.info('flexLayout onTouchEnded', isInside, point);
         * });
         * this.button1.on(Button.Events.TouchEnded, (isInside, point) => {
         * 	console.info('button onTouchEnded', isInside, point);
         * });
         * ````
         */
        onTouchEnded: (isInside: boolean, point: Point2D) => void | boolean;
        /**
         * This event is called when a parent view takes control of the touch events, like a ListView or ScrollView does when scrolling.
         *
         * @event onTouchCancelled
         * @deprecated This method is deprecated in favor of EventEmitter. You could get more details for the deprecated events from here https://docs.smartface.io/smartface-native-framework/tips-and-tricks/handling-events
         * @return {Boolean} True if the listener has consumed the event, false otherwise.
         * @param {Object} motionEvent
         * @param {Number} motionEvent.x
         * @param {Number} motionEvent.y
         * @android
         * @ios
         * @member UI.View
         * @since 2.0.10
         * @example
         * ````
         * import View from '@smartface/native/ui/view';
         * import FlexLayout from '@smartface/native/ui/flexlayout';
         * import Button from '@smartface/native/ui/button';
         *
         * this.view1.on(View.Events.TouchCancelled, (point) => {
         * 	console.info('view onTouchCancelled', point);
         * });
         * this.flexLayout1.on(FlexLayout.Events.TouchCancelled, (point) => {
         * 	console.info('flexLayout onTouchCancelled', point);
         * });
         * this.button1.on(Button.Events.TouchCancelled, (point) => {
         * 	console.info('button onTouchCancelled', point);
         * });
         * ````
         */
        onTouchCancelled: (point: Point2D) => void | boolean;
        /**
         * @deprecated This method is deprecated in favor of EventEmitter. You could get more details for the deprecated events from here https://docs.smartface.io/smartface-native-framework/tips-and-tricks/handling-events
         * @example
         * ````
         * import View from '@smartface/native/ui/view';
         * import FlexLayout from '@smartface/native/ui/flexlayout';
         * import Button from '@smartface/native/ui/button';
         *
         * this.view1.on(View.Events.TouchMoved, (point) => {
         * 	console.info('view onTouchMoved', point);
         * });
         * this.flexLayout1.on(FlexLayout.Events.TouchMoved, (point) => {
         * 	console.info('flexLayout onTouchMoved', point);
         * });
         * this.button1.on(Button.Events.TouchMoved, (point) => {
         * 	console.info('button onTouchMoved', point);
         * });
         * ````
         */
        onTouchMoved: (e: {
            isInside: boolean;
        } | boolean, point?: Point2D) => void | boolean;
        /**
         * This method marks the view as needs relayout.
         *
         * @method dirty
         * @android
         * @ios
         * @since 4.3.6
         */
        dirty(): void;
        getPosition: () => {
            left: number;
            top: number;
            width: number;
            height: number;
        };
        android: TMobileProps['android'];
        ios: TMobileProps['ios'];
    }
    /**
     * @enum {Number} UI.View.Border
     * @since 4.1.4
     * @ios
     * @android
     *
     * Includes enums of View's borders.
     */
    export enum Border {
        /**
         * View's top-left border.
         *
         * @property {Number} TOP_LEFT
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        TOP_LEFT = 0,
        /**
         * View's top-right border.
         *
         * @property {Number} TOP_RIGHT
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        TOP_RIGHT = 2,
        /**
         * View's bottom-right border.
         *
         * @property {Number} BOTTOM_RIGHT
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        BOTTOM_RIGHT = 4,
        /**
         * View's bottom-left border.
         *
         * @property {Number} BOTTOM_LEFT
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        BOTTOM_LEFT = 0
    }
    /**
     * @enum {Number} UI.View.iOS.SemanticContentAttribute
     * @since 3.1.3
     * @ios
     */
    export enum SemanticContentAttribute {
        /**
         * Layout direction will be the same as the device direction. You can use {@link Application#userInterfaceLayoutDirection userInterfaceLayoutDirection} property to check device direction.
         *
         * @property {Number} AUTO
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        AUTO = 0,
        /**
         * Layout direction is always left to right.
         *
         * @property {Number} FORCELEFTTORIGHT
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        FORCELEFTTORIGHT = 3,
        /**
         * Layout direction is always right to left.
         *
         * @property {Number} FORCERIGHTTOLEFT
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        FORCERIGHTTOLEFT = 4
    }
    export class ViewBase<TEvent extends string = ExtractEventValues<ViewEvents>, TNative extends Record<string, any> = Record<string, any>, TProps extends IViewProps = IViewProps> extends NativeEventEmitterComponent<TEvent | ExtractEventValues<ViewEvents>, TNative, TProps> {
        constructor(params?: Partial<TProps>);
        /**
         * iOS Specific Properties.
         * @class UI.View.iOS
         * @since 3.1.3
         */
        static iOS: {
            SemanticContentAttribute: typeof SemanticContentAttribute;
        };
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
        };
        static Border: typeof Border;
        protected _onTouch: IView['onTouch'];
        protected _onTouchEnded: IView['onTouchEnded'];
        protected _onTouchCancelled: IView['onTouchCancelled'];
        protected _onTouchMoved: IView['onTouchMoved'];
    }
    export class AbstractView<TEvent extends string = ViewEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TProps extends IViewProps = IViewProps> extends NativeEventEmitterComponent<TEvent, TNative, TProps> implements IView<TEvent, TNative, TProps> {
        parent: IView | undefined;
        get uniqueId(): string;
        applyLayout(): void;
        bringToFront(): void;
        flipHorizontally(): void;
        flipVertically(): void;
        getScreenLocation(): Point2D;
        getParent(): IView | null;
        onTouch: (e?: Point2D) => boolean | void;
        onTouchEnded: (isInside: boolean, point: Point2D) => boolean | void;
        onTouchCancelled: (point: Point2D) => boolean | void;
        onTouchMoved: (e: boolean | {
            isInside: boolean;
        }, point?: Point2D) => boolean | void;
        dirty(): void;
        getPosition: () => {
            left: number;
            top: number;
            width: number;
            height: number;
        };
        transitionId: string;
        accessible: boolean;
        accessibilityLabel: string;
        alpha: number;
        backgroundColor: Color | IViewState<Color>;
        borderColor: Color;
        borderWidth: number;
        borderRadius: number;
        id: string;
        testId: string;
        visible: boolean;
        rotation: number;
        rotationX: number;
        rotationY: number;
        touchEnabled: boolean;
        left: number;
        top: number;
        right: number;
        bottom: number;
        height: number;
        width: number;
        minWidth: number;
        minHeight: number;
        maxWidth: number;
        maxHeight: number;
        paddingTop: number;
        paddingBottom: number;
        paddingLeft: number;
        paddingRight: number;
        padding: number;
        marginTop: number;
        marginBottom: number;
        marginLeft: number;
        marginRight: number;
        margin: number;
        positionType: Flex.PositionType;
        flexGrow: number;
        aspectRatio: number;
        flexShrink: number;
        flexBasis: number;
        scale: Point2D;
        alignSelf: Flex.AlignSelf;
        masksToBounds: boolean;
        maskedBorders: Border[];
    }
    const View: ConstructorOf<IView, Partial<IViewProps>>;
    type View<TEvent extends string = ViewEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TMobile extends WithMobileOSProps<IViewProps, ViewIOSProps, ViewAndroidProps> = WithMobileOSProps<IViewProps, ViewIOSProps, ViewAndroidProps>> = IView<TEvent, TNative, TMobile>;
    export default View;
}
declare module "ui/viewgroup/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { IView, AbstractView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import { ViewGroupEvents } from "ui/viewgroup/viewgroup-events";
    type ViewGroupAndroidProps = ViewAndroidProps & {
        /**
         * Called when a child does not want this parent and its ancestors to intercept touch events .
         * This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch
         *
         * @method requestDisallowInterceptTouchEvent
         * @param {Boolean} disallow
         * @android
         * @since 4.0.3
         */
        requestDisallowInterceptTouchEvent(disallow: boolean): void;
    };
    /**
     * @class UI.ViewGroup
     * @since 0.1
     * @extends UI.View
     * A ViewGroup is a view that can contain other views (called children).
     * ViewGroup is parent class of all layouts. ViewGroup is an abstract class. You can't create instance from it.
     *
     *     @example
     *     const FlexLayout = require('@smartface/native/ui/flexlayout');
     *     const Label = require('@smartface/native/ui/label');
     *     var myFlexLayout = new FlexLayout();
     *     var myLabel = new Label({
     *          text: "Smartface Label"
     *     });
     *     myFlexLayout.addChild(myLabel);
     */
    export interface IViewGroup<TEvent extends string = ViewGroupEvents, TNative = any, TMobileProps extends MobileOSProps<ViewIOSProps, ViewGroupAndroidProps> = MobileOSProps<ViewIOSProps, ViewGroupAndroidProps>> extends IView<TEvent | ViewGroupEvents, TNative, TMobileProps> {
        /**
         * This function adds a child view to a viewgroup.
         *
         * @param {UI.View} view The child view to add.
         * @android
         * @ios
         * @method addChild
         * @since 0.1
         */
        addChild(view: IView): void;
        /**
         * Remove a child view from viewgroup.
         *
         * @param {UI.View} view The child view to remove.
         * @android
         * @ios
         * @method removeChild
         * @since 0.1
         */
        removeChild(view: IView): void;
        /**
         * Removes all child views from viewgroup.
         *
         * @method removeAll
         * @android
         * @ios
         * @since 0.1
         */
        removeAll(): void;
        /**
         * Gets the count of children in a viewgroup.
         *
         * @returns {Number} The number of children in the layout, or 0 if there is no child exists within the layout.
         * @method getChildCount
         * @android
         * @ios
         * @since 0.1
         */
        getChildCount(): number;
        /**
         * Gets the array of children inside viewgroup.
         *
         * @returns {UI.View[]}
         * @method getChildList
         * @android
         * @ios
         * @since 3.1.3
         */
        getChildList(): IView[];
        /**
         * Finds a child view with specified id within the layout.
         *
         *     @example
         *     const FlexLayout = require('@smartface/native/ui/flexlayout');
         *     const Label = require('@smartface/native/ui/label');
         *     var myFlexLayout = new FlexLayout();
         *     var myLabel = new Label({
         *          text: "Smartface Label",
         *          id: 11235
         *     });
         *     myFlexLayout.addChild(myLabel);
         *     var childView = myFlexLayout.findChildById(11235);
         *
         * @param {Number} id The specified id of the view.
         * @returns {UI.View} Founded view within the layout, or null if view does not exists within the layout.
         * @method findChildById
         * @android
         * @ios
         * @since 0.1
         */
        findChildById(id: string): void;
        /**
         * This event is called when a view added to this view's hierarchy.
         *
         * @param {UI.View} view The subview that will be added.
         * @event onViewAdded
         * @android
         * @ios
         * @since 1.1.8
         * @deprecated
         * @example
         * ````
         * import ViewGroup from '@smartface/native/ui/viewgroup';
         *
         * const viewGroup = new ViewGroup();
         * viewGroup.on(ViewGroup.Events.ViewAdded, (params) => {
         *  console.info('onViewAdded', params);
         * });
         * ````
         */
        onViewAdded: (view: IView) => void;
        /**
         * This event is called when a view removed from this view's hierarchy.
         *
         * @param {UI.View} view The subview that will be removed.
         * @deprecated
         * @event onViewRemoved
         * @android
         * @ios
         * @since 1.1.8
         * @example
         * ````
         * import ViewGroup from '@smartface/native/ui/viewgroup';
         *
         * const viewGroup = new ViewGroup();
         * viewGroup.on(ViewGroup.Events.ViewRemoved, (params) => {
         *  console.info('onViewRemoved', params);
         * });
         * ````
         */
        onViewRemoved: (view: IView) => void;
    }
    export class AbstractViewGroup<TEvent extends string = ViewGroupEvents, TNative = any, TProps extends IViewGroup = IViewGroup> extends AbstractView<TEvent, TNative, TProps> implements IViewGroup<TEvent> {
        addChild(view: IView): void;
        removeChild(view: IView): void;
        removeAll(): void;
        getChildCount(): number;
        getChildList(): IView[];
        findChildById(id: string): void;
        onViewAdded: (view: IView) => void;
        onViewRemoved: (view: any) => void;
    }
    const ViewGroup: typeof AbstractViewGroup;
    type ViewGroup = AbstractViewGroup;
    export default ViewGroup;
}
declare module "ui/flexlayout/index" {
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import { ConstructorOf } from "core/constructorof";
    import Color from "ui/color/index";
    import { IViewGroup } from "ui/viewgroup/index";
    import { MobileOSProps } from "core/native-mobile-component";
    import Flex from "core/flex";
    export type FlexLayoutIOSProps = IViewGroup['ios'];
    export type FlexLayoutAndroidProps = IViewGroup['android'] & {
        readonly yogaNode: any;
        /**
         * Gets/sets foreground of the view for ripple effect. This property should be set before rippleColor.
         * This property only supported for api level 23 and above.
         *
         * @property {Boolean} [useForeground = false]
         * @android
         * @member UI.View
         * @since 4.0.2
         */
        useForeground: boolean;
        /**
         * Gets/sets ripple effect enabled for view. You should set {@link UI.View#rippleColor rippleColor}
         * to see the effect.
         *
         * @property {Boolean} [rippleEnabled = false]
         * @android
         * @member UI.View
         * @since 3.2.1
         */
        rippleEnabled: boolean;
        /**
         * Gets/sets ripple effect color for view.
         *
         * @property {UI.Color} rippleColor
         * @android
         * @member UI.View
         * @since 3.2.1
         */
        rippleColor: Color;
        /**
         * Allows you to watch events as they are dispatched to your children,
         * and take ownership of the current gesture at any point.
         *
         * @event onInterceptTouchEvent
         * @deprecated
         * @return {Boolean} Return true to steal motion events from the children
         * @android
         * @member UI.FlexLayout
         * @since 0.1
         * @example
         * ````
         * import FlexLayout from '@smartface/native/ui/flexlayout';
         *
         * const flexLayout = new FlexLayout();
         * flex.on(Flex.Events.InterceptTouchEvent, () => {
         * 	console.info('onInterceptTouchEvent');
         * });
         * ````
         */
        onInterceptTouchEvent: () => boolean;
        /**
         * Gets/Sets the elevation of the view. For the views that has
         * StateListAnimator natively like Button, will lost its own
         * StateListAnimation when elevation value changed.
         * For details : https://developer.android.com/training/material/shadows-clipping.html
         *
         * @property {Number} elevation
         * @android
         * @member UI.FlexLayout
         * @see https://developer.android.com/training/material/shadows-clipping.html
         * @see https://developer.android.com/reference/android/view/View.html#setStateListAnimator(android.animation.StateListAnimator)
         * @since 1.1.12
         */
        elevation: number;
        /**
         * Gets/sets the depth location of the view relative to its elevation. To put view over button,
         * you have to change zIndex value after Android Lollipop. On android, default elevation value of button is bigger than other view.
         * This property affects after Android Lollipop. No-op before api level 21.
         *
         * @property {Number} zIndex
         * @android
         * @member UI.FlexLayout
         * @since 2.0.8
         */
        zIndex: number;
    };
    /**
     * @class UI.FlexLayout
     * @since 0.1
     * @extends UI.ViewGroup
     *
     * FlexLayout is a viewgroup which has same behaviour of Flexbox on CSS.
     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes
     * Its purpose is to provide a easy way to scale, align and distribute space among items in a container,
     * even when their size is unknown and/or dynamic. FlexLayout has the ability to alter its item's width/height to
     * fill the available space.
     *
     *     @example
     *     const FlexLayout = require('@smartface/native/ui/flexlayout');
     *     var myFlexLayout = new FlexLayout({
     *         flexGrow:1
     *     });
     *
     *     const Label = require('@smartface/native/ui/label');
     *     const Color = require('@smartface/native/ui/color');
     *     var myLabel1 = new Label({
     *         width: 100,
     *         height: 50,
     *         text: "First label",
     *         backgroundColor: Color.RED
     *     });
     *     myFlex.addChild(myLabel1);
     *     var myLabel2 = new Label({
     *         width: 100,
     *         height: 50,
     *         text: "Second label",
     *         backgroundColor: Color.CYAN
     *     });
     *     myFlex.addChild(myLabel2);
     *
     *     page.layout.addChild(myFlexLayout);
     *
     */
    export interface IFlexLayout<TEvent extends string = FlexLayoutEvents, TMobileProps extends MobileOSProps<FlexLayoutIOSProps, FlexLayoutAndroidProps> = MobileOSProps<FlexLayoutIOSProps, FlexLayoutAndroidProps>> extends IViewGroup<TEvent | FlexLayoutEvents, any, TMobileProps> {
        /**
         * This property specifies where items will start to be positioned.
         * If you set RTL(right to left) objects will be positioned by starting from right edge of the Flex.
         * If you set LTR(left to right) objects will be positioned by starting from left edge of the Flex.
         *
         *     @example
         *     const FlexLayout = require('@smartface/native/ui/flexlayout');
         *     var myFlexLayout = new FlexLayout({
         *         flexGrow : 1
         *         direction: Flex.Direction.RTL
         *     });
         *
         * @property {UI.Flex.Direction} [direction = UI.Flex.Direction.INHERIT]
         * @since 0.1
         */
        direction: Flex.Direction;
        /**
         * This property specifies how children will be placed(horizontally or vertical) in Flex.
         * It defines the main axis.
         * It works like flex-direction on CSS.
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
         *
         *
         * @property {UI.Flex.FlexDirection} [flexDirection = UI.Flex.FlexDirection.ROW]
         * @android
         * @ios
         * @since 0.1
         */
        flexDirection: Flex.FlexDirection;
        /**
         * This property specifies the distribution of children along the main-axis.
         * It works like justify-content on CSS.
         * See:  https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content
         *
         * @property {UI.Flex.JustifyContent} [justifyContent = UI.Flex.JustifyContent.FLEX_START]
         * @since 0.1
         */
        justifyContent: Flex.JustifyContent;
        /**
         * This property aligns FlexLayout rows when there is space available in the cross-axis,
         * similar to how justify-content aligns individual child within the main-axis.
         * This property has no effect when there is only one row of children.
         *
         *
         * @property {UI.Flex.AlignContent} [alignContent = UI.Flex.AlignContent.STRETCH]
         * @android
         * @ios
         * @since 0.1
         */
        alignContent: Flex.AlignContent;
        /**
         * This property aligns children along the cross-axis of their container.
         * If UI.Flex.FlexDirection is row, this property controls the alignment in vertical direction.
         * It works like align-items on CSS.
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/align-items
         *
         * @property {UI.Flex.AlignItems} [alignItems = UI.Flex.AlignItems.STRETCH]
         * @android
         * @ios
         * @since 0.1
         */
        alignItems: Flex.AlignItems;
        /**
         * This property specifies whether children of FlexLayout are forced into a single row
         * or can be wrapped onto other rows
         * It works like flex-wrap on CSS.
         * See:  https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap
         *
         *
         * @property {UI.Flex.FlexWrap} [flexWrap = UI.Flex.FlexWrap.NO_WRAP]
         * @android
         * @ios
         * @since 0.1
         */
        flexWrap: Flex.FlexWrap | null;
        /**
         * This functions recalculates the positioning parameters.
         * It is useful to call this method when you want to change layout parameters on runtime.
         * If you change view's position, you should call applyLayout from the Page.layout. You shouldn't call applyLayout from its parent or itself
         *
         * @method applyLayout
         * @android
         * @ios
         */
        applyLayout(): void;
        content: IFlexLayout | undefined;
    }
    const FlexLayout: ConstructorOf<IFlexLayout, Partial<IFlexLayout>>;
    type FlexLayout = IFlexLayout;
    export default FlexLayout;
}
declare module "ui/font/font" {
    import NativeComponent from "core/native-component";
    import { Size } from "primitive/size";
    export enum FontStyle {
        DEFAULT = "DEFAULT",
        IOS_SYSTEM_FONT = "iOS-System-Font",
        NORMAL = 1,
        BOLD = 2,
        ITALIC = 4,
        BOLD_ITALIC = 6
    }
    export abstract class AbstractFont extends NativeComponent {
        constructor(params?: Partial<AbstractFont>);
        /**
         * Gets size of font.
         *
         * @android
         * @ios
         * @since 4.2.3
         */
        private _size;
        get size(): number;
        set size(value: number);
        /**
        * This method returns the string size
        *
        * @android
        * @ios
        * @since 1.1.18
        */
        sizeOfString(string: string, maxWidth: number): Size;
        /**
         * @android
         * @ios
         * @since 0.1
         * Creates a font instance with the given family name, size and style.
         * Assigning font style is deprecated usage (may not work mostly) instead
         * font name parameter must be specified according to actual name of font.
         * To obtain actual font name for iOS, use {@link UI.Font#allFontNames  allFontNames} method.
         * The actual name is same as named of font file in Android.
         *
         *     @example
         *     import Font from '@smartface/native/ui/font';
         *     import Label from '@smartface/native/ui/label';
         *     const myLabel = new Label({
         *         font: Font.create("Arial-ItalicMT", 16)
         *     });
         *     myLabel.text = "Label text";
         */
        static create(fontFamily: string, size: number, style?: FontStyle): AbstractFont | null;
        /**
         * @android
         * @ios
         * Creates a font instance with the given file path and size.
         *
         *     @example
         *     import Font from '@smartface/native/ui/font';
         *     import Label from '@smartface/native/ui/label';
         *     const myLabel = new Label({
         *         font: Font.createFromFile("assets://MyFont.ttf", 16)
         *     });
         *     myLabel.text = "Label text";
         *
         * @since 0.1
         *
         * @static
         */
        static createFromFile(path: string, size: number): AbstractFont;
        /**
         * iOS Only Static Properties
         */
        static ios: Partial<{
            /**
             * @method allFontNames
             * @ios
             * Returns supported font names.
             *
             *     @example
             *     import Font from '@smartface/native/ui/font';
             *     const fontNames = Font.ios.allFontNames();
             *     for (const index in fontNames) {
             *         console.log(fontNames[index]);
             *     }
             *
             * @since 0.1
             */
            allFontNames(): string[];
        }>;
        /**
         * Default font family. This might be different for Android and iOS.
         *
         * @android
         * @ios
         * @since 0.1
         */
        static DEFAULT: FontStyle.DEFAULT;
        static IOS_SYSTEM_FONT: FontStyle.IOS_SYSTEM_FONT;
        /**
         * Represents normal font style
         *
         * @android
         * @ios
         * @since 0.1
         */
        static NORMAL: FontStyle.NORMAL;
        /**
         * Represents bold font style
         *
         * @android
         * @ios
         * @since 0.1
         */
        static BOLD: FontStyle.BOLD;
        /**
         * Represents italic font style
         *
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        static ITALIC: FontStyle.ITALIC;
        /**
         * Represents both bold and italic font style
         *
         * @android
         * @ios
         * @since 0.1
         */
        static BOLD_ITALIC: FontStyle.BOLD_ITALIC;
    }
}
declare module "ui/font/index" {
    import { AbstractFont } from "ui/font/font";
    class FontImpl extends AbstractFont {
        get size(): number;
        sizeOfString(string: string, maxWidth: number): {
            width: number;
            height: number;
        };
    }
    const Font: typeof FontImpl;
    type Font = FontImpl;
    export default Font;
}
declare module "ui/badge/index" {
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { ConstructorOf } from "core/constructorof";
    import { INativeComponent } from "core/inative-component";
    import { IViewState } from "ui/view/index";
    export interface IBadge extends INativeComponent {
        /**
         * Gets/sets text of badge.
         *
         * @property {String} text
         * @android
         * @ios
         * @since 3.1.0
         */
        text: string;
        /**
         * Gets/sets visible of badge.
         *
         * @property {Boolean} visible
         * @android
         * @ios
         * @since 3.1.0
         */
        visible: boolean;
        /**
         * Gets/sets backgroundColor of badge.
         *
         * @property {UI.Color} backgroundColor
         * @android
         * @ios
         * @since 3.1.0
         */
        backgroundColor: Color | null;
        /**
         * Gets/sets textColor of badge.
         *
         * @property {UI.Color} textColor
         * @android
         * @ios
         * @since 3.1.0
         */
        textColor: Color | IViewState<Color>;
        /**
         * Gets/sets font of badge.
         *
         * @property {UI.Font} font
         * @android
         * @ios
         * @since 3.1.0
         */
        font: Font | null;
        /**
         * Gets/sets border color of badge.
         *
         * @property {UI.Color} borderColor
         * @android
         * @ios
         * @since 3.1.0
         */
        borderColor: Color | null;
        /**
         * Gets/sets border width of badge.
         *
         * @property {Number} borderWidth
         * @android
         * @ios
         * @since 3.1.0
         */
        borderWidth: number;
        /**
         * Set Badge offset, Badge center point defaults to the top right corner of its parent. When using badge in tab bar items, this method must be implement
         * at the initialize time.
         *
         * @method move
         * @param {Number} x
         * @param {Number} y
         * @android
         * @ios
         * @since 3.0.0
         */
        move(x: number, y: number): void;
        moveX?: any;
        moveY?: any;
    }
    const Badge: ConstructorOf<IBadge, Partial<IBadge> & {
        parameters?: any;
    }>;
    type Badge = IBadge;
    export default Badge;
}
declare module "global/attributedstring/attributedstring" {
    import { INativeComponent } from "core/inative-component";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    /**
     * @class AttributedString
     * @since 3.0.0
     * A string that has associated attributes for portions of its text.
     *
     *     @example
     *     const AttributedString = require("@smartface/native/ui/attributedstring");
     *     var attributeString = new AttributedString();
     *     attributeString.string = " Third";
     *     attributeString.link = "Third Link";
     *     attributeString.backgroundColor = Color.RED;
     *     attributeString.underline = true;
     *     attributeString.font = Font.create("Times New Roman",30,Font.NORMAL);
     *     attributeString.ios.underlineColor = Color.YELLOW;
     */
    export type iOSProps = Partial<{
        /**
         * Gets/sets underlineColor on AttributedString.
         *
         * @property {UI.Color} underlineColor
         * @ios
         * @since 3.0.0
         */
        underlineColor?: Color;
        /**
         * Gets/sets strikethroughColor on AttributedString.
         *
         * @property {UI.Color} strikethroughColor
         * @ios
         * @since 3.2.1
         */
        strikethroughColor?: Color;
    }>;
    export interface IAttributedString extends INativeComponent {
        /**
         * Gets/sets backgroundColor on AttributedString.
         *
         * @property {UI.Color} backgroundColor
         * @android
         * @ios
         * @since 3.0.0
         */
        backgroundColor: Color;
        /**
         * Gets/sets string on AttributedString.
         *
         * @property {String} [string = ""]
         * @android
         * @ios
         * @since 3.0.0
         */
        string: string;
        /**
         * Gets/sets font on AttributedString.
         *
         * @property {UI.Font} [font = null]
         * @android
         * @ios
         * @since 3.0.0
         */
        font: Font;
        /**
         * Gets/sets foregroundColor on AttributedString.
         *
         * @property {UI.Color} foregroundColor
         * @android
         * @ios
         * @since 3.0.0
         */
        foregroundColor: Color;
        /**
         * Gets/sets link on AttributedString. If you want handle label click method, must set link string.
         *
         * @property {String} link
         * @android
         * @ios
         * @since 3.0.0
         */
        link?: string;
        /**
         * Gets/sets strikethrough on AttributedString.
         *
         * @property {boolean} [strikethrough = false]
         * @android
         * @ios
         * @since 3.2.1
         */
        strikethrough: boolean;
        /**
         * Gets/sets underline on AttributedString.
         *
         * @property {boolean} [underline = false]
         * @android
         * @ios
         * @since 3.0.0
         */
        underline: boolean;
        ios: Partial<{
            /**
             * Gets/sets underlineColor on AttributedString.
             *
             * @property {UI.Color} underlineColor
             * @ios
             * @since 3.0.0
             */
            underlineColor?: Color;
            /**
             * Gets/sets strikethroughColor on AttributedString.
             *
             * @property {UI.Color} strikethroughColor
             * @ios
             * @since 3.2.1
             */
            strikethroughColor?: Color;
        }>;
    }
}
declare module "global/attributedstring/index" {
    import { ConstructorOf } from "core/constructorof";
    import { IAttributedString } from "global/attributedstring/attributedstring";
    const AttributedString: ConstructorOf<IAttributedString, Partial<IAttributedString>>;
    type AttributedString = IAttributedString;
    export default AttributedString;
}
declare module "ui/tabbaritem/index" {
    import Font from "ui/font/index";
    import Image from "ui/image/index";
    import { IBadge } from "ui/badge/index";
    import AttributedString from "global/attributedstring/index";
    import { ConstructorOf } from "core/constructorof";
    import { INativeComponent } from "core/inative-component";
    import { IPage } from "ui/page/index";
    /**
     * @class UI.TabBarItem
     * @since 1.1.10
     *
     * This class represents the page controller when added to a bottom tab bar. Router navigates
     * UI.TabBarItem.page when the tab bar item is clicked.
     *
     *     @example
     *     const TabBarItem = require('@smartface/native/ui/tabbaritem');
     *     const BottomTabBar = require('@smartface/native/ui/bottomtabbar');
     *     const Image = require('@smartface/native/ui/image');
     *
     *     var myHomeImage = Image.createFromFile("images://home.png");
     *     var myTab = new BottomTabBar();
     *     var myItem = new TabBarItem({
     *         title: "Home",
     *         icon: myHomeImage,
     *         route: 'pages/pgHome'
     *     });
     *     myTab.add('home', myItem);
     */
    export interface ITabbarItem extends INativeComponent {
        /**
         * Gets/sets the title of tab item.
         *
         * @property {String} title
         * @android
         * @ios
         * @since 1.1.10
         */
        title: string;
        /**
         * Gets/sets the icon  of tab item.
         *
         * @property {Object} icon
         * @property {UI.Image | String} icon.normal
         * @property {UI.Image | String} icon.selected
         * @android
         * @ios
         * @since 1.1.10
         */
        icon: {
            normal: Image | string;
            selected: Image | string;
        } | Image | string | undefined;
        /**
         * Gets badge of tab bar item. Badge that is displayed in the upper-right corner of the item with a surrounding red oval. Badge usage isn't currently supported if this TabBarItem is belongs to TabBarController.
         * For iOS, when tabBarItem icon size is big, default position of badge might be wrong. You should call move function for fix this problem. Badge should not be given in constructor.
         *
         *     @example
         *     page.parentController.tabBar.items[0].badge.text = "5"; //ParentController must be BottomTabbarController
         *     page.parentController.tabBar.items[0].badge.visible = true;
         *
         * @property {UI.Badge} badge
         * @android
         * @ios
         * @readonly
         * @since 4.0.1
         */
        badge: IBadge;
        /**
         * Gets/sets the route related to tab item. When an tab bar item is pressed, its route is shown.
         *
         * @property {String/UI.Navigator} route
         * @android
         * @ios
         * @since 1.1.10
         */
        route: string;
        android: Partial<{
            /**
             * Gets/sets attributed title of tab bar item.
             *
             * @property {UI.AttributedString} attributedTitle
             * @android
             * @since 4.0.2
             */
            attributedTitle: AttributedString;
            /**
             * Gets/sets the system icon  of tab item. Built-in icons can be set with the corresponding systemIcon value.
             *
             *     @example
             *     var myItem = new TabBarItem({
             *         android: {
             *             systemIcon: 17301545   // OR 'ic_dialog_email'
             *         },
             *         title: "Page1"
             *     });
             *
             *
             * @property {Number | String} systemIcon
             * @android
             * @see https://developer.android.com/reference/android/R.drawable
             * @since 4.0.2
             */
            systemIcon: number | string;
        }>;
        ios: Partial<{
            /**
             * Gets/sets font of tab bar item.
             *
             * @property {UI.Font} font
             * @ios
             * @since 4.0.2
             */
            font: Font;
        }>;
        invalidate(): void;
        setProperties(params: {
            itemTitle: string;
            itemIcon: ITabbarItem['icon'];
            systemIcon?: string | number;
        }): void;
        tabBarItemParent: IPage | null;
    }
    const TabbarItem: ConstructorOf<ITabbarItem, Partial<ITabbarItem>>;
    type TabbarItem = ITabbarItem;
    export default TabbarItem;
}
declare module "ui/page/page-events" {
    export const PageEvents: {
        readonly Hide: "hide";
        readonly Load: "load";
        readonly Show: "show";
        readonly OrientationChange: "orientationChange";
        readonly SafeAreaPaddingChange: "safeAreaPaddingChange";
    };
    export type PageEvents = ExtractValues<typeof PageEvents>;
}
declare module "ui/tabbarcontroller/tabbarcontroller-events" {
    export const TabBarControllerEvents: {
        readonly Hide: "hide";
        readonly Load: "load";
        readonly Show: "show";
        readonly OrientationChange: "orientationChange";
        readonly SafeAreaPaddingChange: "safeAreaPaddingChange";
        /**
         * This event called when a tab is chosen by the user.
         * Returns an {@link UI.Page Page} instance based on index.
         *
         * @event onPageCreate
         * @param index
         * @return UI.Page
         * @android
         * @ios
         * @since 3.2.0
         */
        readonly PageCreate: "pageCreate";
        /**
         * This event called when a tab is chosen by the user.
         *
         * @event onSelected
         * @param index
         * @android
         * @ios
         * @since 3.2.0
         */
        readonly Selected: "selected";
    };
    export type TabBarControllerEvents = ExtractValues<typeof TabBarControllerEvents>;
}
declare module "ui/shared/android/overscrollmode" {
    enum OverScrollMode {
        ALWAYS,
        AUTO,
        NEVER
    }
    export default OverScrollMode;
}
declare module "ui/headerbaritem/index" {
    import AttributedString from "global/attributedstring/index";
    import Image from "ui/image/index";
    import Font from "ui/font/index";
    import Color from "ui/color/index";
    import Badge from "ui/badge/index";
    import { Point2D } from "primitive/point2d";
    import View from "ui/view/index";
    import NativeComponent from "core/native-component";
    import { INativeComponent } from "core/inative-component";
    /**
     * Defines system-supplied images for bar button items. [Apple Documentation](https://developer.apple.com/documentation/uikit/uibarbuttonsystemitem?language=objc)
     *
     * @enum {Number} UI.HeaderBarItem.iOS.SystemItem
     * @since 3.2.1
     * @ios
     */
    export enum SystemItem {
        /**
         * The system Done button. Localized.
         *
         * @property {Number} DONE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        DONE = 0,
        /**
         * The system Cancel button. Localized.
         *
         * @property {Number} CANCEL
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        CANCEL = 1,
        /**
         * The system Edit button. Localized.
         *
         * @property {Number} EDIT
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        EDIT = 2,
        /**
         * The system Save button. Localized.
         *
         * @property {Number} SAVE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        SAVE = 3,
        /**
         * The system plus button containing an icon of a plus sign.
         *
         * @property {Number} ADD
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        ADD = 4,
        /**
         * Blank space to add between other items. The space is distributed equally between the other items. Other item properties are ignored when this value is set.
         *
         * @property {Number} FLEXIBLESPACE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        FLEXIBLESPACE = 5,
        /**
         * Blank space to add between other items. Only the width property is used when this value is set.
         *
         * @property {Number} FIXEDSPACE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        FIXEDSPACE = 6,
        /**
         * The system compose button.
         *
         * @property {Number} COMPOSE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        COMPOSE = 7,
        /**
         * The system reply button.
         *
         * @property {Number} REPLY
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        REPLY = 8,
        /**
         * The system action button.
         *
         * @property {Number} ACTION
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        ACTION = 9,
        /**
         * The system organize button.
         *
         * @property {Number} ORGANIZE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        ORGANIZE = 10,
        /**
         * The system bookmarks button.
         *
         * @property {Number} BOOKMARKS
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        BOOKMARKS = 11,
        /**
         * The system search button.
         *
         * @property {Number} SEARCH
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        SEARCH = 12,
        /**
         * The system refresh button.
         *
         * @property {Number} REFRESH
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        REFRESH = 13,
        /**
         * The system stop button.
         *
         * @property {Number} STOP
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        STOP = 14,
        /**
         * The system camera button.
         *
         * @property {Number} CAMERA
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        CAMERA = 15,
        /**
         * The system trash button.
         *
         * @property {Number} TRASH
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        TRASH = 16,
        /**
         * The system play button.
         *
         * @property {Number} PLAY
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        PLAY = 17,
        /**
         * The system pause button.
         *
         * @property {Number} PAUSE
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        PAUSE = 18,
        /**
         * The system rewind button.
         *
         * @property {Number} REWIND
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        REWIND = 19,
        /**
         * The system fast forward button.
         *
         * @property {Number} FASTFORWARD
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        FASTFORWARD = 20,
        /**
         * The system undo button.
         *
         * @property {Number} UNDO
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        UNDO = 21,
        /**
         * The system redo button.
         *
         * @property {Number} REDO
         * @static
         * @ios
         * @readonly
         * @since 3.2.1
         */
        RED = 22
    }
    /**
     * @class UI.HeaderBarItem
     * @since 0.1
     *
     * HeaderBarItem is a button object that can be shown in header bar of a page.
     * Items set to header bar will be shown on the right side of header bar. You
     * can enable/disable items and listen press event.
     *
     *     @example
     *     const UI = require('@smartface/native/ui');
     *     var myPage = new UI.Page();
     *     var myItem = new UI.HeaderBarItem({
     *         title: "Smartface",
     *         onPress: function() {
     *             console.log("Smartface item pressed!");
     *         }
     *     });
     *     myPage.headerBar.setItems([myItem]);
     */
    export interface IHeaderBarItem extends INativeComponent {
        /**
         * Gets/sets title of header bar item. If image is not set, title will be
         * shown in the header bar.
         *
         * Title won't show if item is set as left item to header bar.
         *
         * @property {String} title
         * @android
         * @ios
         * @since 0.1
         */
        title: string;
        /**
         * Gets/sets size of header bar item. Size must be obtained life cycle of page. Otherwise returning value will be undefined.
         *
         * @property {Object} size
         * @property {Number} size.width
         * @property {Number} size.height
         * @readonly
         * @android
         * @ios
         * @since 4.0.1
         */
        readonly size: {
            readonly width: number;
            readonly height: number;
        } | undefined;
        android: Partial<{
            /**
             * Gets/sets attributed title of header bar item. If image is not set, attributed title will be
             * shown in the header bar.
             *
             * Attributed title won't show if item is set as left item to header bar.
             *
             * @property {UI.AttributedString} attributedTitle
             * @android
             * @since 4.0.0
             */
            attributedTitle: AttributedString;
            /**
             * Gets/sets the system icon  of header bar item. Built-in icons can be set with the corresponding systemIcon value.
             *
             *     @example
             *     var myItem = new HeaderBarItem({
             *         android: {
             *             systemIcon: 17301545   // OR 'ic_dialog_email'
             *         },
             *         color: Color.RED,
             *         onPress: function() {
             *             console.log("You pressed Done item!");
             *         }
             *     });
             *     this.headerBar.setItems([myItem]);
             *
             * @property {Number | String} systemIcon
             * @android
             * @see https://developer.android.com/reference/android/R.drawable
             * @since 4.0.2
             */
            systemIcon: number | string;
            /**
                 * Gets/sets elevation of the header bar.
                 * @android
                 * @example
                 * ```const Page = require('@smartface/native/ui/page');
                            const myPage = new Page();
                            myPage.headerBar.android.elevation = 10;
                            ```
                 */
            elevation: number;
            /**
             * Gets/sets the content inset of headerbar. Minimum API Level 21 required.
             * The content inset affects the valid area for Headerbar content other than the navigation button and menu.
             * Insets define the minimum margin for these custom views like titleLayout and can be used to effectively align HeaderBar content along well-known gridlines.
             */
            contentInset: {
                left: number;
                right: number;
            };
            /**
             * Gets/sets the logo visibility of the HeaderBar. If logo is disable, logo image will newer shown. This property will work only for Android.
             * @default false
             * @android
             */
            logoEnabled: boolean;
            /**
                   * Gets/sets subtitle of the header bar. If not set subtitle will not show. This property will work only for Android.
                   * @example
                   * ```const Page = require('@smartface/native/ui/page');
                      const myPage = new Page();
                      myPage.headerBar.android.subtitle = 'Hello from HeaderBar Subtitle!';
                      ```
                   */
            subtitle: string;
            /**
             * Gets/sets titleFont of header bar subtitle.
             * @android
             */
            subtitleFont: Font;
        }>;
        ios: Partial<{
            /**
             * Gets systemItem of header bar item. SystemItem only set in constructor of headerBarItem.
             *
             *     @example
             *     var myItem = new HeaderBarItem({
             *         ios:{
             *             systemItem : HeaderBarItem.iOS.SystemItem.TRASH
             *         },
             *         onPress: function() {
             *             console.log("You pressed TRASH item!");
             *         }
             *     });
             *     this.headerBar.setItems([myItem]);
             *
             * @property {UI.HeaderBarItem.iOS.SystemItem} systemItem
             * @readonly
             * @ios
             * @since 3.2.1
             */
            systemItem: SystemItem;
            /**
             * Gets/sets font of header bar item.
             *
             * @property {UI.Font} font
             * @ios
             * @since 4.0.0
             */
            font: Font;
            /**
             * A Boolean value that indicates whether the header bar is translucent. For iOS, you should access this property from page.parentController.
             * @ios
             * @default false
             */
            translucent: boolean;
            /**
             * Gets/sets titleFont of header bar title. You should access this property from page.parentController.
             */
            titleFont: Font;
            /**
             * Gets/sets backBarButtonItem of the header bar. When it set, it will change the next page's back button appearance.
             * This change can be observed only on the pages that added to navigator style router.
             * Default value is undefined, it gets title value from previous page's header bar title property.
             * Setting onPress callback of HeaderBarItem will not effect backBarButtonItem's onPress behaviour.
             * This property will work only for iOS. You should access this property from page.parentController
             */
            backBarButtonItem: IHeaderBarItem;
        }>;
        /**
         * Gets/sets Image Object or Image Path of header bar item. Image is set to null as default.
         *
         * If image is already set on HeaderBarItem, title should not be set for some native behaviours.
         *
         * @property {UI.Image | String} image
         * @android
         * @ios
         * @since 0.1
         */
        image: Image | string | null;
        /**
         * Gets/sets customView of header bar item. Default is undefined. In Android, customView cannot be assigned as {@link UI.HeaderBar#setLeftItem left item}.
         * Given customView overrides following HeaderBarItem properties; image, title, font, systemIcon and systemItem.
         *
         * @property {UI.View} customView
         * @android
         * @ios
         * @since 4.1.5
         */
        customView: View | undefined;
        /**
         * Gets/sets enabled status of header bar item. Enabled is set to true as
         * default.
         *
         * @property {Boolean} enabled
         * @android
         * @ios
         * @since 0.1
         */
        enabled: boolean;
        /**
         * This method returns an object that defines view location on screen.
         *
         * @method getScreenLocation
         * @return {Object} location
         * @return {Number} location.x
         * @return {Number} location.y
         * @android
         * @ios
         * @since 3.2.0
         */
        getScreenLocation(): Point2D;
        /**
         * Gets/sets callback for press event. If enabled property is set to false
         * press callback won't be called.
         *
         * @property {Function} onPress
         * @android
         * @ios
         * @since 0.1
         */
        onPress: (() => void) | null;
        /**
         * Gets/sets color of the item's text/image.
         *
         * @property {UI.Color} color
         * @android
         * @ios
         * @since 0.1
         */
        color: Color | null;
        /**
         * Gets badge of header bar item. Badge that is displayed in the upper-right corner of the item with a surrounding red oval. Badge should not be given in constructor. In Android,
         * badge does not appear when assigned to {@link UI.HeaderBar#setLeftItem left item} of HeaderBar.
         *
         *     @example
         *     var headerBarItem = new HeaderBarItem();
         *     headerBarItem.title = "Item";
         *     headerBarItem.badge.text = "5";
         *     headerBarItem.badge.visible = true;
         *     page.headerBar.setItems([headerBarItem]);
         *
         * @property {UI.Badge} badge
         * @android
         * @ios
         * @readonly
         * @since 3.0.0
         */
        badge: Badge;
        /**
         * A content description briefly describes the view. VoiceOver will read this string when a user selects the associated element.
         *
         * @property {String} accessibilityLabel
         * @android
         * @ios
         * @member UI.HeaderBarItem
         * @since 4.4.1
         */
        accessibilityLabel: string;
    }
    export class AbstractHeaderBarItem extends NativeComponent implements IHeaderBarItem {
        constructor(params?: Partial<AbstractHeaderBarItem>);
        title: string;
        readonly size: {
            readonly width: number;
            readonly height: number;
        };
        android: Partial<{
            attributedTitle: AttributedString;
            systemIcon: number | string;
            elevation: number;
            contentInset: {
                left: number;
                right: number;
            };
            logoEnabled: boolean;
            subtitle: string;
            subtitleFont: Font;
        }>;
        ios: Partial<{
            systemItem: SystemItem;
            font: Font;
            translucent: boolean;
            titleFont: Font;
            backBarButtonItem: IHeaderBarItem;
        }>;
        image: Image | string | null;
        customView: View;
        enabled: boolean;
        getScreenLocation(): Point2D;
        onPress: (() => void) | null;
        color: Color | null;
        badge: Badge;
        accessibilityLabel: string;
    }
    const HeaderBarItem: typeof AbstractHeaderBarItem;
    type HeaderBarItem = AbstractHeaderBarItem;
    export default HeaderBarItem;
}
declare module "ui/headerbar/index" {
    import AttributedString from "global/attributedstring/index";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import View, { IView } from "ui/view/index";
    import HeaderBarItem from "ui/headerbaritem/index";
    import { LargeTitleDisplayMode } from "ui/page/index";
    import Image from "ui/image/index";
    /**
     * @class UI.HeaderBar
     *
     * HeaderBar class represents Navigation Bar for iOS and Action Bar for Android. It is a bar
     * shown on top of page under statusBar object. You can manage application navigation by setting
     * buttons and you can show title of page on HeaderBar.
     *
     * Creating instance of HeaderBar class is not valid. You can access header bar of page
     * via UI.Page.headerBar property. Some properties should change from parentController of page for iOS.
     *
     * On iOS you should work with header bar in scope of onLoad and onShow callbacks, otherwise
     * behaviour is undefined.
     *
     * If the HeaderBar is visible, the pages starts under the HeaderBar, otherwise you should check
     * behaviour of the {@link UI.StatusBar}.
     *
     *     @example
     *     const Page = require('@smartface/native/ui/page');
     *     const Color = require('@smartface/native/ui/color');
     *     const HeaderBarItem = require('@smartface/native/ui/headerbaritem');
     *
     *     var myPage = new Page({
     *         onLoad: function() {
     *             var page = this;
     *             var headerBar = System.OS === "Android" ? page.headerBar : page.parentController.headerBar;
     *             headerBar.backgroundColor = Color.MAGENTA;
     *             page.headerBar.title = "Header Bar";
     *
     *             var myItem = new HeaderBarItem({
     *                 title: "Done",
     *                 onPress: function() {
     *                     console.log("You pressed Done item!");
     *                 }
     *             });
     *             this.headerBar.setItems([myItem]);
     *         },
     *         onShow: function() {
     *             var page = this;
     *             var headerBar = System.OS === "Android" ? page.headerBar : page.parentController.headerBar;
     *             headerBar.visible = true;
     *         }
     *     });
     *
     */
    type IHeaderBar = {
        removeViewFromHeaderBar(view: IView): void;
        addViewToHeaderBar(view: IView): void;
        /**
         * Defines the opacity of a view. The value of this property is a float number between 0.0 and 1.0. For iOS, you should access this property from page.parentController.
         * 0 represents view is completely transparent and 1 represents view is completely opaque.
         *
         * @property {Number} [alpha = 1]
         * @android
         * @ios
         * @since 4.0.0
         */
        alpha: number;
        /**
         * Gets/sets transparency of header bar. For iOS, you should access this property from page.parentController.
         *
         * @property {Boolean} [transparent = true]
         * @ios
         * @android
         * @since 4.0.0
         */
        transparent: boolean;
        /**
         * Gets/sets border visibility of headerbar. For iOS, you should access this property from page.parentController.
         *
         * @property {Boolean} [borderVisibility = true]
         * @android
         * @ios
         * @since 3.0.3
         */
        borderVisibility: boolean;
        /**
         * Gets/sets background color of the header bar. If not set, header bar will have default
         * background color depending on device's OS and OS version. For iOS, you should access this property from page.parentController.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     const Color = require('@smartface/native/ui/color');
         *     var myPage = new Page({
         *         onLoad: function() {
         *             var page = this;
         *             var headerBar = System.OS === "Android" ? page.headerBar : page.parentController.headerBar;
         *             headerBar.backgroundColor = Color.RED;
         *         }
         *     });
         *
         * @property {UI.Color} [backgroundColor = Color.create("#00A1F1")]
         * @android
         * @ios
         * @since 0.1
         */
        backgroundColor: Color;
        /**
         * Gets/sets item color of the header bar. This property will change color of the left item and color of all header bar items. For iOS, you should access this property from page.parentController.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     const Color = require('@smartface/native/ui/color');
         *     var myPage = new Page({
         *         onLoad: function() {
         *             var page = this;
         *             var headerBar = System.OS === "Android" ? page.headerBar : page.parentController.headerBar;
         *             headerBar.itemColor = Color.BLUE;
         *         }
         *     });
         *
         * @property {UI.Color} [itemColor = Color.WHITE]
         * @android
         * @ios
         * @since 0.1
         */
        itemColor: Color;
        /**
         * Gets/sets background image of the HeaderBar. For iOS, you should access this property from page.parentController.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     const Image = require('@smartface/native/ui/image');
         *     var myPage = new Page({
         *         onLoad: function() {
         *             var page = this;
         *             var headerBar = System.OS === "Android" ? page.headerBar : page.parentController.headerBar;
         *             headerBar.backgroundImage = Image.createFromFile('images://smartface.png');
         *         }
         *     });
         *
         * @property {UI.Image} [backgroundImage = null]
         * @android
         * @ios
         * @since 0.1
         */
        backgroundImage: Image;
        /**
         * Gets/sets the navigation indicator visibility of the headerBar.
         * If false navigation indicator will not show, otherwise will show
         * as back icon if left item not set.
         *
         * @property {Boolean} [leftItemEnabled = false]
         * @android
         * @ios
         * @since 0.1
         */
        leftItemEnabled: boolean;
        /**
         * Gets the height of the header bar. Height is a read only property and
         * its value may change depending on device and screen density. For iOS, you should access this property from page.parentController.
         *
         * @property {Number} height
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        height: number;
        /**
         * Gets/sets the title layout of the HeaderBar. Title layout allows you to assign custom view.
         * For iOS, layouts are centered on the header bar and may be resized to fit.
         *
         * @property {UI.View} titleLayout
         * @android
         * @ios
         * @since 3.2.1
         */
        titleLayout?: View<any>;
        /**
         * Gets/sets title of the header bar.
         *
         * @property {String} title
         * @android
         * @ios
         * @since 0.1
         */
        title: string;
        /**
         * Gets/sets title color of the header bar. For iOS, you should access this property from page.parentController.
         *
         * @property {UI.Color} [titleColor = Color.BLACK]
         * @android
         * @ios
         * @since 0.1
         */
        titleColor: Color;
        /**
         * Gets/sets visibility of the header bar. For iOS, you should access this property from page.parentController.
         *
         * @property {boolean} [visible = true]
         * @android
         * @ios
         * @since 0.1
         */
        visible: boolean;
        /**
         * This function allows you to set header bar items to the right of page's headerBar.
         * Given items should be instance of UI.HeaderBarItem class. Items will be
         * added to header bar in given array order starting from right of header bar.
         *
         * @method setItems
         * @param {Array<UI.HeaderBarItem>} items Array of HeaderBarItem objects to add
         * @since 0.1
         */
        setItems(items: HeaderBarItem[]): void;
        /**
         * Sets left item of header bar to given item.
         *
         *     @example
         *      const Page = require('@smartface/native/ui/page');
         *      const HeaderBarItem = require('@smartface/native/ui/headerbaritem');
         *      var myPage = new Page();
         *      myPage.onLoad = function(e){
         *          var leftItem = new HeaderBarItem();
         *          leftItem.title = "Left Item";
         *          myPage.headerBar.setLeftItem(leftItem);
         *      }
         *
         * @method setLeftItem
         * @param {UI.HeaderBarItem} item HeaderBarItem to add.
         */
        setLeftItem(item: HeaderBarItem): void;
        android: Partial<{
            /**
             * Gets/sets attributed title of the header bar.
             *
             * @property {UI.AttributedString} attributedTitle
             * @android
             * @since 4.0.0
             */
            attributedTitle?: AttributedString;
            /**
             * Gets/sets attributed subtitle of the header bar.
             *
             * @property {UI.AttributedString} attributedSubtitle
             * @android
             * @since 4.0.0
             */
            attributedSubtitle?: AttributedString;
            /**
             * Gets/sets titleFont of header bar subtitle.
             *
             * @property {UI.Font} subtitleFont
             * @android
             * @since 4.0.0
             */
            subtitleFont?: Font;
            /**
             * Gets/sets the content inset of headerbar. Minimum API Level 21 required. The content inset affects the valid area for Headerbar content other than
             * the navigation button and menu. Insets define the minimum margin for these custom views like {@link UI.HeaderBar#titleLayout titleLayout}  and
             * can be used to effectively align HeaderBar content along well-known gridlines.
             *
             * @property {Object} contentInset
             * @property {Number} contentInset.left
             * @property {Number} contentInset.right
             * @android
             * @since 3.2.1
             */
            contentInset: {
                left: number;
                right: number;
            };
            /**
             * Gets/sets the logo of the HeaderBar image which will shown left
             * side of the left item. You should enable the logo with logoEnabled.
             * If log is not set, the logo image will not shown.
             * This property will work only for Android.
             *
             *     @example
             *     const Page = require('@smartface/native/ui/page');
             *     const Image = require('@smartface/native/ui/image');
             *     var myPage = new Page();
             *     var myImage = Image.createFromFile('images://icon.png');
             *     myPage.headerBar.android.logoEnabled = true;
             *     myPage.headerBar.android.logo = myImage;
             *
             * @property {UI.Image} [logo = null]
             * @android
             * @since 0.1
             */
            logo?: Image | null;
            /**
             * Gets/sets the logo visibility of the HeaderBar. If logo is disable,
             * logo image will newer shown. This property will work only for Android.
             *
             * @property {Boolean} [logoEnabled = false]
             * @android
             * @since 0.1
             */
            logoEnabled?: boolean | null;
            /**
             * Gets/sets subtitle of the header bar. If not set subtitle will not show.
             * This property will work only for Android.
             *
             *     @example
             *     import Page from '@smartface/native/ui/page';
             *     const myPage = new Page();
             *     myPage.headerBar.android.subtitle = 'Hello from HeaderBar Subtitle!';
             *
             * @property {String} subtitle
             * @android
             * @since 0.1
             */
            subtitle?: string;
            /**
             * Gets/sets subtitle color of the header bar. If not set subtitle will not show.
             * This property will work only for Android.
             *
             *     @example
             *     import Page from '@smartface/native/ui/page';
             *     const myPage = new Page();
             *     myPage.headerBar.android.subtitleColor = Color.create('#00A1F1');
             *
             * @property {Color} subtitleColor
             * @android
             * @since 0.1
             */
            subtitleColor?: Color;
            /**
             * Gets/sets elevation of the header bar.
             *
             *     @example
             *     const Page = require('@smartface/native/ui/page');
             *     var myPage = new Page();
             *     myPage.headerBar.android.elevation = 10;
             *
             * @property {Number} elevation
             * @android
             * @since 3.2.2
             */
            elevation?: number;
            /**
             * Gets/sets the space between left item and title of headerbar. Minimum API Level 24 required.
             *
             * @property {Number} [contentInsetStartWithNavigation = 0]
             * @android
             * @since 4.3.6
             * @see https://material.io/components/app-bars-top#specs
             */
            contentInsetStartWithNavigation?: number;
            /**
             * Gets/Sets the padding space on the all sides of a headerbar.
             *
             * @property {Object} [padding = { top : 0, left : 0, right : 4, bottom : 0 }]
             * @property {Number} padding.top padding space on the top side of a headerbar
             * @property {Number} padding.left padding space on the left side of a headerbar
             * @property {Number} padding.right padding space on the right side of a headerbar
             * @property {Number} padding.bottom padding space on the bottom side of a headerbar
             *
             * @android
             * @since 4.3.6
             */
            padding?: {
                top?: number;
                left?: number;
                right?: number;
                bottom?: number;
            };
        }>;
        ios: Partial<{
            /**
             * Gets/sets titleFont of header bar title. You should access this property from page.parentController.
             *
             *     @example
             *     const Page = require('@smartface/native/ui/page');
             *     const Font = require("@smartface/native/ui/font");
             *     var myPage = new Page({
             *         onLoad: function() {
             *             this.parentController.headerBar.ios.titleFont = Font.create(Font.DEFAULT, 10);
             *         }
             *     });
             *
             * @property {UI.Font} titleFont
             * @ios
             * @since 4.0.0
             */
            titleFont?: Font;
            /**
             * A Boolean value that indicates whether the header bar is translucent. For iOS, you should access this property from page.parentController.
             *
             * @property {Boolean} translucent
             * @ios
             * @since 4.0.2
             */
            translucent: boolean;
            /**
             * Gets/sets backBarButtonItem of the header bar.
             * When it set, it will change the next page's back button appearance.
             * This change can be observed only on the pages that added to navigator style router.
             * Default value is undefined, it gets title value from previous page's header bar title property.
             * Setting onPress callback of HeaderBarItem will not effect backBarButtonItem's onPress behaviour.
             * This property will work only for iOS.
             *
             *     @example
             *      const HeaderBarItem = require('@smartface/native/ui/headerbaritem');
             *     const Page = require('@smartface/native/ui/page');
             *
             *     var myPage = new Page();
             *     var backBarButtonItem = new HeaderBarItem({
             *          title : "Back"
             *     });
             *     myPage.headerBar.ios.backBarButtonItem = backBarButtonItem;
             *
             * @property {HeaderBarItem} backBarButtonItem
             * @ios
             * @since 0.1
             */
            backBarButtonItem?: HeaderBarItem;
            /**
             * Gets/sets the mode to use how to display title of header bar.
             * This property will work only for iOS.
             * If "prefersLargeTitles" property of navigator is false, this property has no effect and title will display as small title.
             *
             *     @example
             *     const Page = require('@smartface/native/ui/page');
             *     var myPage = new Page();
             *     myPage.headerBar.ios.largeTitleDisplayMode = Page.iOS.LargeTitleDisplayMode.ALWAYS;
             *
             * @property {Page.iOS.LargeTitleDisplayMode} largeTitleDisplayMode
             * @ios
             * @since 0.1
             */
            largeTitleDisplayMode?: LargeTitleDisplayMode;
            /**
             * Used to add a different Image in place of iOS default back action on NavigationController
             * Setting this will also set backIndicatorTransitionMaskImage as true.
             * Setting this as something else(like null) will set the backIndicatorTransitionMaskImage as false.
             *
             * @example
             *     const Page = require('@smartface/native/ui/page');
             *     var myPage = new Page();
             *     myPage.headerBar.ios.backIndicatorImage = Image.createFromFile("images://smartface.png");
             *
             * @property {Page.iOS.PrefersLargeTitles}
             * @ios
             * @since 0.1
             */
            backIndicatorImage?: Image;
            /**
             * The image used as a mask for content during push and pop transitions.
             * This property will be set automatically if backIndicatorImage is set as a valid image.
             *
             * @example
             *     const Page = require('@smartface/native/ui/page');
             *     var myPage = new Page();
             *     myPage.headerBar.ios.backIndicatorImage = Image.createFromFile("images://smartface.png");
             *     //myPage.headerBar.ios.backIndicatorTransitionMaskImage = true; //Above line will set this to true, therefore no need to state this.
             *
             * @property {Page.iOS.PrefersLargeTitles}
             * @ios
             * @since 0.1
             */
            backIndicatorTransitionMaskImage?: Image;
            /**
             * When this property is set to true, the navigation bar allows the title to be displayed out-of-line and using a larger font.
             * The navigation item used to build the bar must specify whether it wants its title displayed in the large or small format.
             * Use the largeTitleDisplayMode property to configure the title's appearance.
             *
             * @example
             *     const Page = require('@smartface/native/ui/page');
             *     var myPage = new Page();
             *     myPage.headerBar.ios.prefersLargeTitles = true;
             *
             * @property {Page.iOS.PrefersLargeTitles}
             * @ios
             * @since 0.1
             */
            prefersLargeTitles?: boolean;
            setVisible(visible: boolean, animated?: boolean): void;
            leftItemEnabled: boolean;
        }>;
    };
    export default IHeaderBar;
}
declare module "ui/bottomtabbar/index" {
    import { ConstructorOf } from "core/constructorof";
    import { INativeComponent } from "core/inative-component";
    import Color from "ui/color/index";
    import TabBarItem from "ui/tabbaritem/index";
    /**
     * @class UI.BottomTabBar
     * @since 1.1.10
     *
     * BottomTabBar represents a bottom navigation bar. You can specify bar color and item color.
     *
     * @see https://smartface.github.io/router/class/src/native/BottomTabBarRouter.js~BottomTabBarRouter.html
     *
     */
    export interface IBottomTabBar extends INativeComponent {
        /**
         * Gets/sets background color of the tab bar items.
         *
         * @property {UI.Color} backgroundColor
         * @android
         * @ios
         * @since 1.1.10
         */
        backgroundColor: Color;
        /**
         * Gets the maximum number of items that add to bottom tab bar.
         *
         * @since 1.1.10
         * @property {Number} maxItemCount
         * @android
         * @readonly
         */
        android: Partial<{
            maxItemCount: boolean;
            /**
             * Enable/disable the default animation of BottomTabBar item. Might be used while badge being used.
             *
             * @since 4.0.1
             * @property {Boolean} disableItemAnimation
             * @android
             * @removed since 4.2.2
             */
            disableItemAnimation: boolean;
        }>;
        /**
         * Gets/sets title and icon color of the tab bar items.
         *
         * @property {Object} itemColor
         * @property {UI.Color} itemColor.normal
         * @property {UI.Color} itemColor.selected
         * @android
         * @ios
         * @since 1.1.10
         */
        itemColor: {
            normal: Color;
            selected: Color;
        };
        /**
         * Gets/sets items of the tab bar.
         *
         * @android
         * @ios
         * @since 3.2.0
         */
        items: TabBarItem[] | null;
        ios: Partial<{
            /**
             * A Boolean value that indicates whether the tab bar is translucent.
             *
             * @property {Boolean} translucent
             * @ios
             * @since 4.0.2
             */
            translucent: boolean;
        }>;
    }
    const BottomTabBar: ConstructorOf<IBottomTabBar, Partial<IBottomTabBar>>;
    type BottomTabBar = IBottomTabBar;
    export default BottomTabBar;
}
declare module "ui/bottomtabbarcontroller/bottomtabbarcontroller-events" {
    export const BottomTabbarControllerEvents: {
        readonly SelectByIndex: "selectByIndex";
        readonly ShouldSelectByIndex: "shouldSelectByIndex";
    };
    export type BottomTabbarControllerEvents = ExtractValues<typeof BottomTabbarControllerEvents>;
}
declare module "ui/bottomtabbarcontroller/index" {
    import { IController } from "ui/navigationcontroller/index";
    import BottomTabBar from "ui/bottomtabbar/index";
    import { ConstructorOf } from "core/constructorof";
    /**
     * @class UI.BottomTabbarController
     * @since 3.2
     *
     * BottomTabbarController is used for navigating between tab bar items with given tags.
     *
     *     @example
     *     const Page = require('@smartface/native/ui/page');
     *     const BottomTabbarController = require('@smartface/native/ui/bottomtabbarcontroller');
     *
     *     var bottomTabBarController = new BottomTabBarController();
     *     bottomTabBarController.childControllers = [page1, page2, navigationController1, navigationController2];
     *     bottomTabBarController.selectedIndex = 2;
     *
     *     bottomTabBarController.shouldSelectByIndex = function (e){return true || false}
     *     bottomTabBarController.didSelectByIndex = function (e){}
     *
     * @see https://smartface.github.io/router/class/src/native/BottomTabBarRouter.js~BottomTabBarRouter.html
     */
    export interface IBottomTabBarController extends IController {
        isInsideBottomTabBar: boolean;
        shouldSelectViewController: (index: any) => boolean;
        didSelectViewController: (index: any) => void;
        /**
         * Gets/sets child controllers of BottomTabbarController instance.
         *
         * @property {Array} childControllers
         * @android
         * @ios
         * @since 3.2.0
         */
        childControllers: IController[];
        /**
         * Gets/sets tab bar view of BottomTabbarController instance.
         *
         * @property {UI.BottomTabBar} tabbar
         * @readonly
         * @android
         * @ios
         * @since 3.2.0
         */
        readonly tabBar: BottomTabBar;
        /**
         * Gets/sets the selected tab bar item.
         *
         * @property Number selectedIndex
         * @android
         * @ios
         * @since 3.2.0
         */
        selectedIndex: number;
        /**
         * Return true if you want the item to be displayed as the selected index.
         *
         * @event shouldSelectByIndex
         * @deprecated
         * @param params
         * @param Number params.index
         * @return Boolean
         * @android
         * @ios
         * @since 3.2.0
         * @example
         * ````
         * import BottomTabbarController from '@smartface/native/ui/bottomtabbarcontroller';
         *
         * const bottomTabbarController = new BottomTabbarController();
         * bottomTabbarController.on(BottomTabBarController.Events.ShouldSelectByIndex, (params) => {
         *  console.info('shouldSelectByIndex', params);
         * });
         * ````
         */
        shouldSelectByIndex(params: {
            index: number;
        }): boolean;
        /**
         *  Called when an item in the bottom tabbar item is selected.
         *
         * @event didSelectByIndex
         * @deprecated
         * @param params
         * @param Number params.index
         * @android
         * @ios
         * @since 3.2.0
         * @example
         * ````
         * import BottomTabBarController from "./bottomtabbarcontroller";
         *
         * const bottomTabBarController = new BottomTabBarController();
         * bottomTabBarController.on(BottomTabBarController.Events.SelectByIndex, (params) => {
         *  console.info('selectByIndex', params);
         * });
         * ````
         */
        didSelectByIndex(params: {
            index: number;
        }): void;
    }
    const BottomTabbarController: ConstructorOf<IBottomTabBarController, Partial<IBottomTabBarController>>;
    type BottomTabbarController = IBottomTabBarController;
    export default BottomTabbarController;
}
declare module "ui/navigationcontroller/navigationcontroller.ios" {
    import { AbstractNavigationController, Controller, IController, INavigationController, OperationType } from "ui/navigationcontroller/index";
    import NativeComponent from "core/native-component";
    import TabBarController from "ui/tabbarcontroller/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    export default class NavigationControllerIOS extends AbstractNavigationController implements INavigationController, IController {
        private _android;
        private _ios;
        view: NavigationView;
        protected model: NavigationModel;
        pageID: number;
        tabBar?: TabBarController;
        isActive: boolean;
        popupBackNavigator: boolean;
        parentController: undefined;
        isInsideBottomTabBar: boolean;
        constructor(params: Partial<INavigationController>);
        getCurrentController(): IController;
        show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean;
            onCompleteCallback?: () => void;
        }): void;
        get android(): {};
        get ios(): {};
        get childControllers(): INavigationController['childControllers'];
        set childControllers(value: INavigationController['childControllers']);
        get headerBar(): HeaderBar;
        set headerBar(value: HeaderBar);
        push(params: {
            controller: Controller;
            animated?: boolean;
        }): void;
        pop(params?: {
            animated: boolean;
        }): void;
        popTo(params: {
            controller: Controller;
            animated?: boolean;
        }): void;
        willShow: (params: {
            controller: Controller;
            animated?: boolean;
        }) => void;
        onTransition: (e: {
            controller?: Controller;
            operation: OperationType;
            currentController?: Controller;
            targetController?: Controller;
        }) => void;
        present(params: {
            controller: Controller;
            animated: boolean;
            onComplete: () => void;
        }): void;
        dismiss(params: {
            onComplete: () => void;
            animated: boolean;
        }): void;
        private getVisiblePage;
        private willShowViewController;
        private didShowViewController;
        private animationControllerForOperationFromViewControllerToViewController;
        static OperationType: typeof OperationType;
    }
    class NavigationView extends NativeComponent<__SF_UINavigationController> {
        viewModel: undefined;
        private __navigationControllerDelegate;
        constructor(params?: {
            viewModel?: any;
        });
        push(page: NavigationControllerIOS, animated?: boolean): void;
        pop(animated?: boolean): void;
        popTo(page: NavigationControllerIOS, animated?: boolean): void;
        present(controllerToPresent: __SF_UIViewController, animated?: boolean, completionBlock?: () => void): void;
        dismiss(completionBlock: () => void, animated?: boolean): void;
        setNativeChildViewControllers(nativeChildPageArray: __SF_UIViewController[]): void;
    }
    class NavigationModel {
        pageToPush: IController;
        childControllers: IController[];
        pushPage(page: IController): void;
        popPage(): void;
        popToPage(page: IController): void;
        popToIndex(index: number): void;
        pageForIndex(index: number): IController;
    }
}
declare module "ui/navigationcontroller/headerbar" {
    import { default as IHeaderBar } from "ui/headerbar/index";
    import View, { IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import { IHeaderBarItem } from "ui/headerbaritem/index";
    import { MobileOSProps, NativeMobileComponent } from "core/native-mobile-component";
    import NavigationControllerIOS from "ui/navigationcontroller/navigationcontroller.ios";
    export class HeaderBar extends NativeMobileComponent<__SF_UINavigationBar, IHeaderBar> implements IHeaderBar {
        appearance?: __SF_UINavigationBarAppearance;
        navigationController?: NavigationControllerIOS;
        private _transparent;
        private _transparentEmptyImage;
        private _titleColor;
        private _visible;
        private _prefersLargeTitles;
        private _backIndicatorImage;
        private _backIndicatorTransitionMaskImage;
        private _titleFont?;
        private _borderVisibility;
        leftItemEnabled: boolean;
        titleLayout?: View;
        title: string;
        setItems(items: IHeaderBarItem[]): void;
        setLeftItem(item: IHeaderBarItem): void;
        constructor(params: Partial<IHeaderBar> & {
            navigationController?: NavigationControllerIOS;
        });
        removeViewFromHeaderBar(view: IView<'touch' | 'touchCancelled' | 'touchEnded' | 'touchMoved', {
            [key: string]: any;
        }, MobileOSProps<ViewIOSProps, ViewAndroidProps>>): void;
        addViewToHeaderBar(view: IView<'touch' | 'touchCancelled' | 'touchEnded' | 'touchMoved', {
            [key: string]: any;
        }, MobileOSProps<ViewIOSProps, ViewAndroidProps>>): void;
        get transparent(): IHeaderBar['transparent'];
        set transparent(value: IHeaderBar['transparent']);
        get alpha(): IHeaderBar['alpha'];
        set alpha(value: IHeaderBar['alpha']);
        get titleColor(): IHeaderBar['titleColor'];
        set titleColor(value: IHeaderBar['titleColor']);
        get visible(): IHeaderBar['visible'];
        set visible(value: IHeaderBar['visible']);
        get itemColor(): IHeaderBar['itemColor'];
        set itemColor(value: IHeaderBar['itemColor']);
        get backgroundColor(): IHeaderBar['backgroundColor'];
        set backgroundColor(value: IHeaderBar['backgroundColor']);
        get backgroundImage(): IHeaderBar['backgroundImage'];
        set backgroundImage(value: IHeaderBar['backgroundImage']);
        get height(): IHeaderBar['height'];
        get borderVisibility(): IHeaderBar['borderVisibility'];
        set borderVisibility(value: IHeaderBar['borderVisibility']);
        private __updateTitleTextAttributes;
        private iosProperties;
    }
}
declare module "util/Android/transition/viewcontroller" {
    import Page from "ui/page/index";
    import { IController, INavigationController } from "ui/navigationcontroller/index";
    import FragmentTransition from "util/Android/transition/fragmenttransition";
    /** TODO: Check this out after bottomtabbar, navigationcontroller and page is completed */
    type PageWithController = Page | INavigationController;
    export type ControllerParams = {
        controller: IController;
        animation?: boolean;
        animated?: boolean;
        isComingFromPresent?: boolean;
        onCompleteCallback?: () => void;
        animationType?: FragmentTransition.AnimationType;
    };
    namespace ViewController {
        function activateRootController(controller: IController): void;
        function deactivateRootController(controller: IController): void;
        function setIsActiveOfController(controller: IController, __isActive: boolean): void;
        function activateController(controller: IController): void;
        function deactivateController(controller: IController): void;
        function setController(params: ControllerParams): void;
        function getCurrentPageFromController(controller: PageWithController): Page | IController | null;
        function setIsInsideBottomTabBarForAllChildren(controller: IController): void;
    }
    export default ViewController;
}
declare module "ui/tabbarcontroller/index" {
    import TabBarItem, { ITabbarItem } from "ui/tabbaritem/index";
    import Color from "ui/color/index";
    import Page, { AbstractPage, IPage, PageAndroidParams, PageIOSParams, PageOrientation } from "ui/page/index";
    import { TabBarControllerEvents } from "ui/tabbarcontroller/tabbarcontroller-events";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import { MobileOSProps } from "core/native-mobile-component";
    import FlexLayout from "ui/flexlayout/index";
    import { IController } from "ui/navigationcontroller/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import View from "ui/view/index";
    import { StatusBar } from "application/statusbar/index";
    import { ControllerParams } from "util/Android/transition/viewcontroller";
    export enum BarTextTransform {
        AUTO = 0,
        NONE = 1,
        UPPERCASE = 2
    }
    export enum LargeTitleDisplayMode {
        AUTOMATIC = 0,
        ALWAYS = 1,
        NEVER = 2
    }
    export enum PresentationStyle {
        COVERVERTICAL = 0,
        FLIPHORIZONTAL = 1,
        CROSSDISSOLVE = 2,
        PARTIALCURL = 3
    }
    export interface ITabBarControllerIOSProps extends PageIOSParams {
        barTextTransform: BarTextTransform;
    }
    export interface ITabBarControllerAndroidProps extends PageAndroidParams {
    }
    export interface ITabBarController<TEvent extends string = TabBarControllerEvents> extends IPage<TEvent | TabBarControllerEvents, MobileOSProps<ITabBarControllerIOSProps, ITabBarControllerAndroidProps>> {
        /**
         * Gets the tab bar height of the TabBarController. You can change barHeight on Android, but not iOS.
         * This property is read-only for iOS.
         * @property {Number} barHeight
         * @android
         * @ios
         * @since 3.2.0
         */
        barHeight: number;
        /**
         * Gets/sets the tab bar item array of the TabBarController.
         * @property {UI.TabBarItem[]} items
         * @android
         * @ios
         * @since 3.2.0
         */
        items: TabBarItem[];
        /**
         * Gets/sets the divider color of the TabBarController.
         * @property {UI.Color} [dividerColor = UI.Color.BLACK]
         * @android
         * @since 3.2.0
         */
        dividerColor: Color;
        /**
         * Gets/sets the divider padding of the TabBarController.
         * @property {Number} [dividerPadding = 0]
         * @android
         * @since 3.2.0
         */
        dividerPadding: number;
        /**
         * Gets/sets the divider width of the TabBarController.
         * @property {Number} [dividerWidth = 0]
         * @android
         * @since 3.2.0
         */
        dividerWidth: number;
        /**
         * Gets/sets the indicator color of the TabBarController.
         * @property {UI.Color} [indicatorColor = UI.Color.create("#00A1F1")]
         * @android
         * @ios
         * @since 3.2.0
         */
        indicatorColor: Color;
        /**
         * Gets/sets the auto capitalize title of the items of TabBarController.
         * @property {Boolean} [autoCapitalize = true]
         * @android
         * @ios
         * @since 3.2.1
         */
        autoCapitalize: boolean;
        /**
         * Gets/sets the indicator height of the TabBarController.
         * @property {Number} indicatorHeight
         * @android
         * @ios
         * @since 3.2.0
         */
        indicatorHeight: number;
        /**
         * Gets/sets over-scroll mode for top tab bar.
         *
         * @property {UI.Android.OverScrollMode} [overScrollMode = UI.Android.OverScrollMode.ALWAYS]
         * @android
         * @since 3.2.0
         */
        overScrollMode: OverScrollMode;
        /**
         * Gets/sets bar color of tabs.
         * @property {UI.Color} [barColor = Color.WHITE]
         * @android
         * @ios
         * @since 3.2.0
         */
        barColor: Color;
        /**
         * Gets/sets whether to enable scrollable tabs.
         * @property {Boolean} scrollEnabled
         * @android
         * @ios
         * @since 3.2.0
         */
        scrollEnabled: boolean;
        /**
         * Gets the selected index of TabBarController.
         * @property {Number} selectedIndex
         * @android
         * @ios
         * @since 3.2.0
         */
        selectedIndex: number;
        /**
         * Sets the selected index of TabBarController.
         * @method setSelectedIndex
         * @param {Number} index
         * @param {Boolean} [animated=true]
         * @android
         * @ios
         * @since 3.2.0
         */
        setSelectedIndex(index: number, animated: boolean): void;
        /**
         * Gets/sets the icon color of the tabs. You can specify text colors for the different states (normal, selected) used for the tabs.
         * @property {UI.Color|Object} textColor
         * @android
         * @ios
         * @since 3.2.0
         */
        iconColor: {
            normal: Color;
            selected: Color;
        } | Color;
        /**
         * Gets/sets the text color of the tabs. You can specify text colors for the different states (normal, selected) used for the tabs.
         * @property {UI.Color|Object} textColor
         * @android
         * @ios
         * @since 3.2.0
         */
        textColor: {
            normal: Color;
            selected: Color;
        } | Color;
        /**
         * Enables/Disables paging behavior.
         *
         * @property {Boolean} [pagingEnabled = true]
         * @android
         * @ios
         * @since 4.3.2
         */
        pagingEnabled: boolean;
        /**
         * This event called when a tab is chosen by the user.
         * Returns an {@link UI.Page Page} instance based on index.
         *
         * @event onPageCreate
         * @param index
         * @deprecated
         * @return UI.Page
         * @android
         * @ios
         * @since 3.2.0
         * @example
         * ````
         * import TabbarController from '@smartface/native/ui/tabbarcontroller';
         *
         * const tabbarController = new TabbarController();
         * tabbarController.on(TabbarController.Events.PageCreate, (params) => {
         * 	console.info('onPageCreate', params);
         * });
         * ````
         */
        onPageCreate: (index: number) => Page;
        /**
         * This event called when a tab is chosen by the user.
         *
         * @event onSelected
         * @deprecated
         * @param index
         * @android
         * @ios
         * @since 3.2.0
         * @example
         * ````
         * import TabbarController from '@smartface/native/ui/tabbarcontroller';
         *
         * const tabbarController = new TabbarController();
         * tabbarController.on(TabbarController.Events.Selected, (params) => {
         * 	console.info('onSelected', params);
         * });
         * ````
         */
        onSelected: (index: number) => void;
    }
    export abstract class AbstractTabBarController<TEvent extends string = TabBarControllerEvents> extends AbstractPage<TEvent> implements ITabBarController<TEvent> {
        orientation: PageOrientation;
        transitionViews: View[];
        layout: FlexLayout;
        statusBar: StatusBar;
        headerBar?: HeaderBar | undefined;
        static iOS: {
            BarTextTransform: typeof BarTextTransform;
            LargeTitleDisplayMode: typeof LargeTitleDisplayMode;
            PresentationStyle: typeof PresentationStyle;
        };
        barHeight: number;
        items: ITabbarItem[];
        dividerColor: Color;
        dividerPadding: number;
        dividerWidth: number;
        indicatorColor: Color;
        autoCapitalize: boolean;
        indicatorHeight: number;
        overScrollMode: OverScrollMode;
        barColor: Color;
        scrollEnabled: boolean;
        selectedIndex: number;
        abstract setSelectedIndex(index: number, animated: boolean): void;
        iconColor: {
            normal: Color;
            selected: Color;
        } | Color;
        textColor: {
            normal: Color;
            selected: Color;
        } | Color;
        pagingEnabled: boolean;
        onPageCreate: (index: number) => Page;
        onSelected: (index: number) => void;
    }
    class TabBarControllerImpl extends AbstractTabBarController {
        setSelectedIndex(index: number, animated: boolean): void;
        getCurrentController(): IController;
        show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean | undefined;
            onCompleteCallback?: (() => void) | undefined;
        }): void;
        onOrientationChange(e: {
            orientation: PageOrientation[];
        }): void;
        present(params?: ControllerParams): void;
        dismiss(params?: ControllerParams): void;
    }
    /**
     * @class UI.TabBarController
     * @extends UI.Page
     * @since 3.2.0
     *
     * This class extends from {@link UI.Page Page}. But you shouldn't use directly layout of the {@link UI.TabBarController TabBarController}.
     *
     *     @example
     *     import extend = from "js-base/core/extend";
     *     import TabBarController = from '@smartface/native/ui/tabbarcontroller';
     *     import Color = from '@smartface/native/ui/color';
     *     import TabBarItem = from '@smartface/native/ui/tabbaritem';
     *     import Page = from '@smartface/native/ui/page';
     *
     *     const backgroundColors = [Color.RED, Color.YELLOW, Color.BLUE, Color.GREEN, Color.MAGENTA];
     *     const SamplePage = extend(Page)(
     *         (_super, params) => {
     *             _super(this, params);
     *         }
     *     );
     *
     *     const TabBarController1 = extend(TabBarController)(
     *         (_super, params) => {
     *             _super(this, {
     *                 items: createTabBarItems(5)
     *             });
     *
     *             const pages = [];
     *             this.onPageCreate = (index: number) => {
     *                 if (!pages[index]) {
     *                     pages[index] = new SamplePage({ index: index });
     *                     pages[index].layout.backgroundColor = backgroundColors[index];
     *                 }
     *                 return pages[index];
     *             };
     *
     *             this.onShow = () => {
     *                 this.headerBar.visible = false;
     *             };
     *
     *             this.onLoad = () => {
     *                 this.scrollEnabled = true;
     *                 this.indicatorColor = Color.BLACK;
     *                 this.indicatorHeight = 5;
     *                 this.barColor = Color.LIGHTGRAY;
     *                 this.iconColor = {
     *                     normal: Color.BLACK,
     *                     selected: Color.BLUE
     *                 };
     *                 this.textColor = {
     *                     normal: Color.BLACK,
     *                     selected: Color.BLUE
     *                 };
     *             };
     *
     *             this.onSelected = (index: number) => {
     *                 console.log("Selected item index: " + index);
     *             };
     *         }
     *     );
     *
     *     function createTabBarItems(itemCount) {
     *         const items = [];
     *         for (let i = 0; i < itemCount; i++) {
     *             items.push(new TabBarItem({
     *                 title: "Category " + i
     *             }));
     *         }
     *         return items;
     *     }
     *
     */
    const TabBarController: typeof TabBarControllerImpl;
    type TabBarController = TabBarControllerImpl;
    export default TabBarController;
}
declare module "ui/navigationcontroller/index" {
    import { INativeComponent } from "core/inative-component";
    import TabBarController from "ui/tabbarcontroller/index";
    import { IBottomTabBar } from "ui/bottomtabbar/index";
    import { ControllerParams } from "util/Android/transition/viewcontroller";
    import FragmentTransaction from "util/Android/transition/fragmenttransition";
    import NativeComponent from "core/native-component";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    /**
     * @enum {Number} UI.NavigationController.OperationType
     *
     * Operation type of NavigationController.
     * @static
     * @since 3.2
     *
     */
    export enum OperationType {
        /**
         * @property {Number} PUSH
         * Push operation
         * @ios
         * @android
         * @static
         * @readonly
         * @since 3.2
         */
        PUSH = 0,
        /**
         * @property {Number} POP
         * Pop operation
         * @ios
         * @android
         * @static
         * @readonly
         * @since 3.2
         */
        POP = 1
    }
    export interface IController extends INativeComponent {
        pageID?: number;
        popupBackNavigator: any;
        isActive: boolean;
        parentController: IController;
        childControllers?: IController[];
        isInsideBottomTabBar?: boolean;
        headerBar?: HeaderBar;
        tabBar?: IController | IBottomTabBar | TabBarController;
        getCurrentController(): IController | null;
        show(params?: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean;
            onCompleteCallback?: () => void;
        }): any;
    }
    export type Controller = IController;
    /**
     * @class UI.NavigationController
     * @since 3.2
     *
     *     @example
     *     const Page = require('@smartface/native/ui/page');
     *     const NavigationController = require('@smartface/native/ui/navigationcontroller');
     *
     *     var page1 = new Page();
     *     var navigationController = new NavigationController(); //// OR IT CAN TAKES a controller object like tabbarcontroller AS AN ARGUMENT
     *     navigationController.childControllers = [page1];
     *     navigationController.headerBar.translucent = true;
     *     var page2 = new Page();
     *     page2.navigationItem.title = "Page1";
     *     navigationController.push({controller: page2, animation: true});
     *
     *     var page3 = new Page();
     *     page3.parentController.headerBar.backgroundColor = Color.RED;
     *     navigationController.push({controller: page3, animation: true});
     *
     *     var page4 = new Page();
     *     navigationController.push({controller: page4, animation: true});
     *     navigationController.childControllers; /// Returns [page1,page2,page3,page4];
     *     navigationController.popTo({controller: page2, animation: true});
     *     navigationController.childControllers; /// Returns [page1,page2];
     *
     *     navigationController.pop();
     *     navigationController.childControllers; /// Returns [page1];
     *
     *     navigationController.willShow = function ({controller: controller, animation: animation}) {};
     *     navigationController.onTransition = function ({currentController: currentController, targetController: targetController, operation: operation}) /// => operation means (push || pop)
     */
    export interface INavigationController extends INativeComponent, IController, ControllerParams {
        /**
         * Gets/sets child controllers of NavigationController instance.
         *
         * @property {Array} childControllers
         * @android
         * @ios
         * @since 3.2.0
         */
        childControllers: Controller[];
        /**
         * Gets headerBar of NavigationController instance.
         *
         * @property {UI.HeaderBar} headerBar
         * @android
         * @ios
         * @readonly
         * @since 3.2.0
         */
        headerBar: HeaderBar;
        /**
         * Show page with animation parameter. Animated parameter is set to true as default.
         *
         * @method push
         * @param params
         * @param {UI.Page|UI.BottomTabBarController} params.controller
         * @param Boolean [params.animated = true]
         * @android
         * @ios
         * @since 3.2.0
         */
        push(params: {
            controller: Controller;
            animated?: boolean;
        }): void;
        /**
         * Pop the last page from the navigation controller's page back stack.
         *
         * @method pop
         * @param params
         * @param Boolean [params.animated = true]
         * @android
         * @ios
         * @since 3.2.0
         */
        pop(params?: {
            animated?: boolean;
        }): void;
        /**
         * Until the given page is found, the pages popped from back stack.
         *
         * @method popTo
         * @param params
         * @param {UI.Page|UI.BottomTabBarController} params.controller
         * @param Boolean [params.animated = true]
         * @android
         * @ios
         * @since 3.2.0
         */
        popTo(params: {
            controller: Controller;
            animated?: boolean;
        }): void;
        /**
         * This event is triggered before the page is displayed.
         *
         * @event willShow
         * @param params
         * @param {UI.Page|UI.NavigationController} params.controller
         * @param UI.AnimationType params.animated
         * @android
         * @since 3.2.0
         */
        willShow: (params: {
            controller: Controller;
            animated?: boolean;
        }) => void;
        /**
         * This event is triggered before the page is displayed.
         *
         * @event onTransition
         * @param params
         * @param {UI.Page|UI.NavigationController} params.currentController
         * @param {UI.PageUI.NavigationController} params.targetController
         * @param UI.NavigationController.OperationType params.operation
         * @android
         * @since 3.2.0
         */
        onTransition: (e: {
            controller: Controller;
            operation: OperationType;
            currentController?: Controller;
            targetController?: Controller;
        }) => void;
        /**
         * This function shows up the pop-up controller.
         *
         *
         * @method present
         * @param {Object} params
         * @param {UI.Page|UI.NavigationController} params.controller
         * @param {Boolean} params.animated
         * @param {Function} params.onComplete
         * @android
         * @ios
         * @since 4.0.0
         *
         */
        present(params: {
            controller: Controller;
            animated: boolean;
            onComplete: () => void;
        }): void;
        /**
         * This function dismiss presently shown pop-up controller.
         *
         * @method dismiss
         * @param {Object} params
         * @param {Function} params.onComplete
         * @param {Boolean} params.animated
         * @android
         * @ios
         * @since 4.0.0
         */
        dismiss(params: {
            onComplete: () => void;
            animated: boolean;
        }): void;
        parentController: INavigationController;
        isInsideBottomTabBar: boolean;
        isActive: boolean;
        popupBackNavigator: any;
    }
    export abstract class AbstractNavigationController extends NativeComponent implements INavigationController {
        constructor(params?: Partial<INavigationController>);
        abstract push(params: {
            controller: IController;
            animated?: boolean;
        }): void;
        abstract pop(params?: {
            animated?: boolean;
        }): void;
        abstract popTo(params: {
            controller: IController;
            animated?: boolean;
        }): void;
        abstract present(params: {
            controller: IController;
            animated: boolean;
            onComplete: () => void;
        }): void;
        abstract dismiss(params: {
            onComplete: () => void;
            animated: boolean;
        }): void;
        abstract getCurrentController(): IController;
        abstract show(params?: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean;
            onCompleteCallback?: () => void;
        }): void;
        abstract childControllers: Controller[];
        abstract willShow: (params: {
            controller: Controller;
            animated?: boolean;
        }) => void;
        abstract onTransition: (e: {
            controller: Controller;
            operation: OperationType;
            currentController?: Controller;
            targetController?: Controller;
        }) => void;
        abstract headerBar: HeaderBar;
        protected __isActive: boolean;
        protected _childControllers: Controller[];
        protected _willShowCallback: (opts?: {
            controller: IController;
            animated?: boolean;
        }) => void;
        protected _onTransitionCallback: (opts?: {
            controller: Controller;
            operation: OperationType;
            currentController?: Controller;
            targetController?: Controller;
        }) => void;
        protected _headerBar: HeaderBar;
        parentController: INavigationController;
        controller: IController;
        animation?: boolean;
        animated?: boolean;
        isComingFromPresent?: boolean;
        onCompleteCallback?: () => void;
        animationType?: FragmentTransaction.AnimationType;
        tabBar?: TabBarController;
        pageID: number;
        popupBackNavigator: boolean;
        isActive: boolean;
        isInsideBottomTabBar: boolean;
        static OperationType: typeof OperationType;
    }
    const NavigationController: typeof AbstractNavigationController;
    type NavigationController = AbstractNavigationController;
    export default NavigationController;
}
declare module "ui/page/index" {
    import { StatusBar } from "application/statusbar/index";
    import { IEventEmitter } from "core/eventemitter/index";
    import { INativeComponent } from "core/inative-component";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import FlexLayout, { IFlexLayout } from "ui/flexlayout/index";
    import NavigationController, { IController } from "ui/navigationcontroller/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import TabBarController from "ui/tabbarcontroller/index";
    import View from "ui/view/index";
    import { PageEvents } from "ui/page/page-events";
    export enum PageOrientation {
        UNKNOWN = 0,
        PORTRAIT = 1,
        PORTRAITUPSIDEDOWN = 2,
        LANDSCAPELEFT = 3,
        LANDSCAPERIGHT = 4
    }
    export enum LargeTitleDisplayMode {
        AUTOMATIC = 0,
        ALWAYS = 1,
        NEVER = 2
    }
    export enum PresentationStyle {
        COVERVERTICAL = 0,
        FLIPHORIZONTAL = 1,
        CROSSDISSOLVE = 2,
        PARTIALCURL = 3
    }
    export const Orientation: {
        PORTRAIT: PageOrientation[];
        UPSIDEDOWN: PageOrientation[];
        AUTOPORTRAIT: PageOrientation[];
        LANDSCAPELEFT: PageOrientation[];
        LANDSCAPERIGHT: PageOrientation[];
        AUTOLANDSCAPE: PageOrientation[];
        AUTO: PageOrientation[];
    };
    export interface PageAndroidParams {
        /**
         * This event will be triggered when user clicks back button on the Device.
         *
         * @event onBackButtonPressed
         * @deprecated
         * @android
         * @since 0.1
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.BackButtonPressed, () => {
         * 	console.info('backButtonPressed);
         * });
         * ````
         */
        onBackButtonPressed(): void;
        transitionViewsCallback?: {
            onTransitionStart: () => void;
            onTransitionEnd: () => void;
        };
    }
    interface ControllerParams {
        controller: IPage | NavigationController;
        animated: boolean;
        onComplete: () => void;
    }
    export interface PageIOSParams {
        /**
         * Sets padding values to page's layout.
         * This will override padding values of its layout. Padding values are defined by Apple for each orientation.
         *
         * @ios
         * @since 0.1
         */
        safeAreaLayoutMode?: boolean;
        /**
         * This event will be triggered when padding values of layout changed.
         *
         * @event onSafeAreaPaddingChange
         * @deprecated
         * @param {Object} paddingObject Includes top,left,right and bottom padding values.
         * @ios
         * @since 0.1
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.SafeAreaPaddingChange, () => {
         * 	console.info('onSafeAreaPaddingChange');
         * });
         * ````
         */
        onSafeAreaPaddingChange: ((padding: {
            left: number;
            top: number;
            right: number;
            bottom: number;
        }) => void) | undefined;
        present(): void;
        presentationStyle: number;
        navigationItem: HeaderBar;
    }
    export interface IPage<TEvent extends string = PageEvents, TMobile extends MobileOSProps<PageIOSParams, PageAndroidParams> = MobileOSProps<PageIOSParams, PageAndroidParams>, TNative = any> extends INativeComponent<TNative>, IEventEmitter<TEvent | PageEvents> {
        contextMenu: {
            items: any[];
            headerTitle: string;
        };
        android: TMobile['android'];
        ios: TMobile['ios'];
        isInsideBottomTabBar: boolean;
        /**
         * This event is called once when page is created.
         * You can create views and add them to page in this callback.
         *
         * @android
         * @ios
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.Load, () => {
         * 	console.info('onLoad');
         * });
         * ````
         */
        onLoad: () => void;
        /**
         * Gets/sets custom transition views. Used with custom transitions to map a {@link UI.View View}
         * from a removed or hidden {@link UI.Page Page} to a {@link UI.View View} from a shown or added {@link UI.Page Page}.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     var myPage = new Page({
         *         var page = this;
         *         onShow: function() {
         *             page.headerBar.visible = true;
         *
         *             page.imageView1.transitionID = "view1";
         *             page.imageView2.transitionID = "view2";
         *
         *             page.transitionViews = [page.imageView1, page.imageView2];
         *         }
         *     });
         *
         *     var myDetailPage = new Page({
         *         var page = this;
         *         onShow: function() {
         *             page.headerBar.visible = true;
         *         }
         *
         *         page.imageView1.transitionID = "view2";
         *         page.imageView2.transitionID = "view1";
         *     });
         *
         * @property {UI.View[]} transitionViews
         * @android
         * @ios
         * @readonly
         * @since 3.2.0
         */
        transitionViews: View[];
        /**
         * Gets the main layout of Page which is an instance of UI.FlexLayout. You
         * should add views to the layout of the page.
         *
         * @property {UI.FlexLayout} layout
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        readonly layout: IFlexLayout;
        /**
         * This event is called when a page appears on the screen (everytime).
         * It will be better to set headerBar and statusBar properties in this callback.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     const Application = require('@smartface/native/application');
         *     var myPage = new Page({
         *         onShow: function() {
         *             this.headerBar.visible = true;
         *         }
         *         Application.statusBar.visible = true;
         *     });
         *
         * @android
         * @ios
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.Show, () => {
         * 	console.info('onShow');
         * });
         * ````
         */
        onShow: () => void;
        /**
         * This event is called when a page disappears from the screen.
         *
         * @event onHide
         * @android
         * @ios
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.Hide, () => {
         * 	console.info('onHide');
         * });
         * ````
         */
        onHide: () => void;
        /**
         * This function shows up the pop-up page. Pop-up pages behave exactly as UI.Page .
         *
         *     @example
         *     const self = this; //Current page
         *     const Color = require('@smartface/native/ui/color');
         *
         *     var popuPage = new Page();
         *     popuPage.layout.backgroundColor = Color.BLUE;
         *
         *     const Button = require('@smartface/native/ui/button');
         *     var myButton = new Button({
         *     width: 150,
         *     height: 80,
         *     text: "Smartface Button",
         *     onPress: function() {
         *      self.dismiss(function() {
         *      console.log("dismiss")
         *      });
         *     }
         *     });
         *     popuPage.layout.addChild(myButton);
         *
         *     self.popupBtn.onPress = function() {
         *         self.present({
         *             controller: popuPage,
         *             animated: true,
         *             onComplete: function() {
         *                 console.log("Page3 presented...");
         *             };
         *         });
         *     }
         *
         *
         * @method present
         * @param {Object} params
         * @param {UI.Page|UI.NavigationController} params.controller
         * @param {Boolean} params.animated
         * @param {Function} params.onComplete
         * @android
         * @ios
         * @deprecated
         * @since 3.1.1
         *
         */
        present(params: ControllerParams): void;
        /**
         * This function dismiss presently shown pop-up page.
         *
         * @method dismiss
         * @param {Object} params
         * @param {Function} params.onComplete
         * @android
         * @ios
         * @since 3.1.1
         * @deprecated
         */
        dismiss(params?: ControllerParams): void;
        /**
         * Gets status bar object. This property is readonly, you can not set
         * status bar to a page but you can change properties of page's status bar.
         *
         * @property {UI.StatusBar} statusBar
         * @android
         * @ios
         * @readonly
         * @removed 4.0.0 Use {@link Application.statusBar} instead
         * @since 0.1
         */
        statusBar: StatusBar;
        /**
         * Gets header bar object of a  page. This property is readonly, you can not
         * set header bar to a page but you can change properties of page's header bar.
         * In Android, header bar properties should be implemented in onLoad or onShow of page.
         * Otherwise given settings might be losed.
         *
         * @property {UI.HeaderBar} headerBar
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        readonly headerBar?: HeaderBar;
        /**
         * Gets/sets the orientation of the Page. This property must be set as constructor parameter.
         * {@link UI.Page.Orientation Orientation} constants can use with bitwise or operator. The default value of the
         * orientation defined in project.json.
         *
         *     @example
         *     const Page = require('@smartface/native/ui/page');
         *     var myPage1 = new Page({
         *          orientation: Page.Orientation.LANDSCAPELEFT
         *     });
         *
         * @property {UI.Page.Orientation} [orientation = UI.Page.Orientation.PORTRAIT]
         * @android
         * @ios
         * @since 0.1
         */
        orientation: PageOrientation;
        /**
         * This event will be called when orientation of the Page changes.
         * iOS fires this event before orientation changed but Android fires after changed.
         *
         *
         * @event onOrientationChange
         * @deprecated
         * @param {Object} e
         * @param {UI.Page.Orientation} e.orientation
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import Page from '@smartface/native/ui/page';
         *
         * const page = new Page();
         * page.on(Page.Events.OrientationChange, (params) => {
         * 	console.info('onOrientationChange', params);
         * });
         * ````
         */
        onOrientationChange(e: {
            orientation: PageOrientation[];
        }): void;
        skipDefaults?: boolean;
        readonly parentController: IController;
    }
    export abstract class AbstractPage<TEvent extends string = PageEvents, TNative = any, TProps extends IPage = IPage> extends NativeEventEmitterComponent<TEvent | PageEvents, TNative, TProps> implements IController, IPage {
        private _skipDefaults;
        get skipDefaults(): boolean;
        set skipDefaults(value: boolean);
        constructor(params?: Partial<TProps>);
        contextMenu: {
            items: any[];
            headerTitle: string;
        };
        childControllers?: IController[];
        tabBar?: TabBarController;
        abstract getCurrentController(): IController;
        abstract show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean;
            onCompleteCallback?: () => void;
        }): any;
        parentController: IController;
        pageID: number;
        popupBackNavigator: any;
        isActive: boolean;
        isInsideBottomTabBar: boolean;
        abstract orientation: PageOrientation;
        abstract transitionViews: View[];
        abstract onOrientationChange(e: {
            orientation: PageOrientation[];
        }): void;
        onLoad: () => void;
        onShow: () => void;
        onHide: () => void;
        abstract present(params?: ControllerParams): void;
        abstract dismiss(params?: ControllerParams): void;
        abstract readonly layout: FlexLayout;
        abstract readonly statusBar: StatusBar;
        abstract readonly headerBar?: HeaderBar;
        static iOS: {
            LargeTitleDisplayMode: typeof LargeTitleDisplayMode;
            PresentationStyle: typeof PresentationStyle;
        };
        static Orientation: typeof Orientation;
    }
    class PageImpl extends AbstractPage implements IPage {
        orientation: PageOrientation;
        transitionViews: View[];
        layout: FlexLayout;
        statusBar: StatusBar;
        headerBar?: HeaderBar | undefined;
        getCurrentController(): IController;
        show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean | undefined;
            onCompleteCallback?: (() => void) | undefined;
        }): any;
        onOrientationChange(e: {
            orientation: PageOrientation[];
        }): void;
        present(params?: ControllerParams): void;
        dismiss(params?: ControllerParams): void;
    }
    const Page: typeof PageImpl;
    type Page = PageImpl;
    export default Page;
}
declare module "ui/sliderdrawer/sliderdrawer-events" {
    export const SliderDrawerEvents: {
        readonly Show: "show";
        readonly Load: "load";
        readonly Hide: "hide";
    };
    export type SliderDrawerEvents = ExtractValues<typeof SliderDrawerEvents>;
}
declare module "ui/sliderdrawer/index" {
    import { IEventEmitter } from "core/eventemitter/index";
    import { INativeComponent } from "core/inative-component";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import { IFlexLayout } from "ui/flexlayout/index";
    import { SliderDrawerEvents } from "ui/sliderdrawer/sliderdrawer-events";
    export enum SliderDrawerPosition {
        /**
         * @property {Number} LEFT
         *
         * Position the SliderDrawer to left.
         *
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        LEFT = 0,
        /**
         * @property {Number} RIGHT
         *
         * Position the SliderDrawer to right.
         *
         * @static
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        RIGHT = 1
    }
    /**
     * @enum {Number} UI.SliderDrawer.State
     * @static
     * @readonly
     * @since 1.1.8
     *
     * Define the state of SliderDrawer.
     *
     */
    export enum SliderDrawerState {
        /**
         * @property {Number} OPEN
         *
         * Indicates the slider drawer is open.
         *
         * @static
         * @android
         * @ios
         * @readonly
         * @since 1.1.8
         */
        OPEN = 0,
        /**
         * @property {Number} CLOSED
         *
         * Indicates the slider drawer is closed.
         *
         * @static
         * @android
         * @ios
         * @readonly
         * @since 1.1.8
         */
        CLOSED = 1,
        /**
         * @property {Number} DRAGGED
         *
         * Indicates the slider drawer is dragged.
         *
         * @static
         * @android
         * @ios
         * @readonly
         * @since 1.1.8
         */
        DRAGGED = 2
    }
    export interface ISliderDrawer<TEvent extends string = SliderDrawerEvents> extends IEventEmitter<TEvent | SliderDrawerEvents>, INativeComponent, MobileOSProps {
        /**
         * Gets/sets position of the SliderDrawer.
         *
         * @property {UI.SliderDrawer.Position} [drawerPosition = UI.SliderDrawer.Position.LEFT]
         * @android
         * @ios
         * @since 0.1
         */
        drawerPosition: SliderDrawerPosition;
        /**
         * Gets state of the SliderDrawer.
         *
         * @property {UI.SliderDrawer.State} state
         * @android
         * @ios
         * @readonly
         * @since 1.1.8
         */
        readonly state: SliderDrawerState;
        /**
         * Gets/sets layout of the SliderDrawer.
         *
         * @property {UI.FlexLayout} [layout = UI.FlexLayout]
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        readonly layout: IFlexLayout;
        /**
         * Enables/disables the SliderDrawer.
         *
         * @property {Boolean} [enabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        enabled: boolean;
        /**
         * This function allows you to show SliderDrawer on the screen.
         *
         * @method show
         * @android
         * @ios
         * @since 0.1
         */
        show(): void;
        /**
         * This function allows you to hide SliderDrawer if it is on the screen.
         *
         * @method hide
         * @android
         * @ios
         * @since 0.1
         */
        hide(): void;
        /**
         * This event is called user opens the SliderDrawer.
         *
         * @event onShow
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SliderDrawer from '@smartface/native/ui/sliderdrawer';
         *
         * const sliderDrawer = new SliderDrawer();
         * sliderDrawer.on(SliderDrawer.Events.Show, () => {
         * 	console.info('onShow');
         * });
         * ````
         */
        onShow: () => void | null;
        /**
         * This event is called when user closes the SliderDrawer.
         *
         * @event onHide
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SliderDrawer from '@smartface/native/ui/sliderdrawer';
         *
         * const sliderDrawer = new SliderDrawer();
         * sliderDrawer.on(SliderDrawer.Events.Hide, () => {
         * 	console.info('onHide');
         * });
         * ````
         */
        onHide: () => void | null;
        /**
         * This event is called when SliderDrawer begins to load.
         *
         * @event onLoad
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SliderDrawer from '@smartface/native/ui/sliderdrawer';
         *
         * const sliderDrawer = new SliderDrawer();
         * sliderDrawer.on(SliderDrawer.Events.Load, () => {
         * 	console.info('onLoad');
         * });
         * ````
         */
        onLoad: () => void | null;
        height: number;
        width: number;
        backgroundColor: Color;
    }
    export class AbstractSliderDrawer<TEvent extends string = SliderDrawerEvents> extends NativeEventEmitterComponent<TEvent | SliderDrawerEvents> implements ISliderDrawer<TEvent | SliderDrawerEvents> {
        constructor(params?: Partial<ISliderDrawer>);
        backgroundColor: Color;
        readonly state: SliderDrawerState;
        width: number;
        height: number;
        drawerPosition: SliderDrawerPosition;
        readonly layout: IFlexLayout;
        enabled: boolean;
        show(): void;
        hide(): void;
        onShow: () => void;
        onHide: () => void;
        onLoad: () => void;
        static State: typeof SliderDrawerState;
        static Position: typeof SliderDrawerPosition;
    }
    const SliderDrawer: typeof AbstractSliderDrawer;
    type SliderDrawer = AbstractSliderDrawer;
    export default SliderDrawer;
}
declare module "application/android/navigationbar/navigationbar" {
    import Color from "ui/color/index";
    export enum NavigationBarStyle {
        DARKCONTENT = 0,
        LIGHTCONTENT = 1
    }
    /**
     * @class Application.Android.NavigationBar
     *
     * This class represents Android navigation bar (includes soft keys) object. Creating instance of
     * NavigationBar is not valid since you can't use in anywhere.
     *
     * @since 4.0.0
     */
    export class NavigationBarBase {
        color: Color;
        /**
         * Style is an enum. It defines navigation bar appearance style.
         * Gets/sets transparency of status bar.This property works only for Android version
         * OREO 8.1.0 (API 27) or above.
         *
         * @property {Application.Android.NavigationBar.Style} [style = Application.Android.NavigationBar.Styles.DARKCONTENT]
         * @android
         * @since 4.0.0
         */
        style: NavigationBarStyle;
    }
}
declare module "application/android/navigationbar/index" {
    import { NavigationBarBase } from "application/android/navigationbar/navigationbar";
    const NavigationBar: NavigationBarBase;
    type NavigationBar = NavigationBarBase;
    export default NavigationBar;
}
declare module "application/application" {
    import Page from "ui/page/index";
    import NavigationController from "ui/navigationcontroller/index";
    import SliderDrawer from "ui/sliderdrawer/index";
    import { EventEmitter } from "core/eventemitter/index";
    import { ApplicationEvents } from "application/application-events";
    import BottomTabBar from "ui/bottomtabbar/index";
    import { StatusBar } from "application/statusbar/index";
    import NavigationBar from "application/android/navigationbar/index";
    import { NavigationBarStyle } from "application/android/navigationbar/navigationbar";
    /**
     * @enum {Number} Application.LayoutDirection
     * @since 3.1.3
     * @ios
     * @android
     */
    enum LayoutDirection {
        /**
         * Layout direction is left to right.
         *
         * @property {Number} LEFTTORIGHT
         * @ios
         * @android
         * @readonly
         * @since 3.1.3
         */
        LEFTTORIGHT = 0,
        /**
         * Layout direction is right to left.
         *
         * @property {Number} RIGHTTOLEFT
         * @ios
         * @android
         * @readonly
         * @since 3.1.3
         */
        RIGHTTOLEFT = 1
    }
    /**
     * @enum Application.Android.KeyboardMode
     * @since 3.1.0
     *
     * Enable to change keyboard mode.
     *
     *     @example
     *     const Application  =require("@smartface/native/application");
     *     Application.android.keyboardMode = Application.Android.KeyboardMode.KeyboardAdjustResize;
     *
     */
    enum KeyboardMode {
        /**
         * Set to have a screen not adjust for a shown keyboard.
         *
         * @property KeyboardAdjustNothing
         * @readonly
         * @since 3.1.0
         */
        KeyboardAdjustNothing = 48,
        /**
         * Set to have a screen pan when an keyboard is shown,
         * so it doesn't need to deal with resizing but just panned by the framework to ensure the current input focus is visible.
         *
         * @property KeyboardAdjustPan
         * @readonly
         * @since 3.1.0
         */
        KeyboardAdjustPan = 32,
        /**
         * Set to allow the screen to be resized when an keyboard is shown,
         * so that its contents are not covered by the keyboard.
         *
         * @property KeyboardAdjustResize
         * @readonly
         * @since 3.1.0
         */
        KeyboardAdjustResize = 16,
        /**
         * Set as nothing specified. The system will try to pick one or the other depending on the contents of the screen.
         *
         * @property KeyboardAdjustUnspecified
         * @readonly
         * @since 3.1.0
         */
        KeyboardAdjustUnspecified = 0,
        /**
         * Always make the keyboard visible when this window receives input focus.
         *
         * @property AlwaysVisible
         * @readonly
         * @since 3.1.0
         */
        AlwaysVisible = 5,
        /**
         * Always hides any keyboard when this screen receives focus.
         *
         * @property AlwaysHidden
         * @readonly
         * @since 3.1.0
         */
        AlwaysHidden = 3
    }
    /**
     * @class Application
     * @since 0.1
     *
     * A set of collection for application based properties and methods.
     */
    export class ApplicationBase extends EventEmitter<ApplicationEvents> {
        /**
         * The received bytes from the application.
         *
         * @property {Number} byteReceived
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        byteReceived: number;
        /**
         * The sent bytes from the application
         *
         * @property {Number} byteSent
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        byteSent: number;
        /**
         * Gets/sets sliderDrawer of the Application.
         *
         * @property {UI.SliderDrawer} [sliderDrawer = null]
         * @android
         * @ios
         * @since 3.2.0
         */
        sliderDrawer: SliderDrawer;
        /**
         * This property allows you to prevent the screen from going to sleep while your app is active.
         *
         * @property {Boolean} [keepScreenAwake = false]
         * @android
         * @ios
         * @since 4.3.1
         */
        keepScreenAwake: boolean;
        /**
         * Exists the application.
         *
         * @method exit
         * @android
         * @ios
         * @since 0.1
         */
        exit: () => void;
        /**
         * Restarts the application.
         *
         * @method restart
         * @android
         * @ios
         * @since 0.1
         */
        restart: () => void;
        /**
         * Set root controller of the application.
         *
         * @method setRootController
         * @param {Object} params
         * @param {UI.Page|UI.NavigationController} controller
         * @param {Boolean} [animated=false]
         * @android
         * @ios
         * @since 3.2.0
         */
        setRootController: (controller: NavigationController) => void;
        /**
         * Launches another application and passes data. For Android, you can open application chooser with
         * isShowChooser parameter and set chooser dialog title with chooserTitle.
         * If an app can open a given URL resource onSuccess callback will be triggered otherwise onFailure will be triggered.
         *
         *     @example
         *     // Calling application's Google Play Store page. Will work only for iOS
         *     Application.call({
         *         uriScheme: "market://details",
         *         data: {
         *             'id': Application.android.packageName
         *         }
         *     });
         *     // Open caller app with phone number.
         *     Application.call({ uriScheme: "tel:+901234567890", data: {} });
         *     // Call another application with its own url schema.
         *     Application.call({
         *         uriScheme: "mySchema://",
         *         data: {
         *             key: encodeURIComponent("Smartace Encoded Data")
         *         },
         *         onSuccess: function() {
         *             alert("Application call completed")
         *         },
         *         onFailure: function() {
         *             alert("Application call failed")
         *         }
         *     });
         *     // Call another application with package name and activity name. Works only for Android.
         *     Application.call({ uriScheme: "io.smartface.SmartfaceDev|io.smartface.SmartfaceDev.A", data: {} });
         *     // Call Smartface Emulator with url schema.
         *     Application.call({ uriScheme: "smartface-emulator://", data : {} });
         *     // Open Youtube with Chooser for Android
         *     Application.call({
         *         uriScheme: "https://www.youtube.com/watch?v=VMLU9mfzHYI",
         *         data: {},
         *         onSuccess: function() {
         *             alert("Application call completed")
         *         },
         *         onFailure: function() {
         *             alert("Application call failed")
         *         },
         *         isShowChooser: true,
         *         chooserTitle: "Select an Application"
         *     });
         *
         *
         * @method call
         * @param {Object} params
         * @param {String} params.uriScheme
         * @param {Object} params.data parameter should be url encoded if necessary.
         * @param {Function} params.onSuccess Added in 1.1.13.
         * @param {Function} params.onFailure Added in 1.1.13.
         * @param {Boolean} params.isShowChooser Added in 1.1.13.
         * @param {String} params.chooserTitle Added in 1.1.13.
         * @param {String} params.action  Such as <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_VIEW">android.intent.action.VIEW</a>
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        call: (params: {
            uriScheme?: string;
            data?: {};
            onSuccess?: (value?: any) => void;
            onFailure?: (value?: any) => void;
            isShowChooser?: boolean;
            chooserTitle?: string;
            action?: string;
        }) => void;
        /**
         * Checks URL's scheme can be handled or not by some app that installed on the device.
         *
         * To pass this method, URL schemes must be declared into "Info.plist" file for iOS
         * and AndroidManifest.xml file for Android.
         *
         *     @example for Google Maps
         *
         *		(Info.plist entry)
         *      <key>LSApplicationQueriesSchemes</key>
         *      <array>
         *          <string>comgooglemaps</string>
         *      </array>
         *
         *      After entry add on, urlScheme can be check;
         * 	 	const Application = require("@smartface/native/application");
         *      var isAppAvaible = Application.canOpenUrl("comgooglemaps://");
         *
         * 		(AndroidManifest.xml entry)
         * 		<manifest ...>
         * 			...
         * 			<queries>
         *  			<intent>
         *					<action android:name="android.intent.action.VIEW" />
         *  				<data android:scheme="geo"/>
         *				</intent>
         * 			</queries>
         * 		</manifest>
         *
         * 	 	const Application = require("@smartface/native/application");
         *      var isAppAvaible = Application.canOpenUrl("geo://");
         *
         * @method canOpenUrl
         * @param {String} url
         * @return {Boolean}
         * @ios
         * @android
         * @since 4.3.6
         * @see https://developer.android.com/training/package-visibility
         */
        canOpenUrl: (url: string) => boolean;
        ios: Partial<{
            /**
             * The event is called when a user taps a universal link.
             *
             * @event onUserActivityWithBrowsingWeb
             * @param {String} url Universal link.
             * @return {Boolean} YES to indicate that your app handled the activity or NO to let iOS know that your app did not handle the activity.
             * @ios
             * @since 3.1.2
             */
            onUserActivityWithBrowsingWeb: (url: string) => boolean;
            /**
             * Application bundle identifier.
             *
             * @property {String} bundleIdentifier
             * @readonly
             * @ios
             * @since 3.0.2
             */
            bundleIdentifier: any;
            /**
             * It indicates the directionality of the language in the user interface of the app.
             *
             * @property {Application.LayoutDirection} userInterfaceLayoutDirection
             * @readonly
             * @ios
             * @since 3.1.3
             */
            userInterfaceLayoutDirection: any;
            registeredRemoteWithSuccessCallback: any;
            registeredRemoteWithFailureCallback: any;
        }>;
        /**
         * Gets status bar object. This property is readonly, you can not set
         * status bar but you can change properties of status bar of application.
         *
         * @property {UI.StatusBar} statusBar
         * @android
         * @ios
         * @readonly
         * @since 3.2.0
         */
        statusBar: StatusBar;
        LayoutDirection: typeof LayoutDirection;
        android: Partial<{
            /**
             * Set/Get the layout direction from a Locale.
             *
             * @property {String} locale
             * @readonly
             * @android
             * @since 3.1.3
             */
            locale: string;
            /**
             * Get current layout direction.
             *
             * @property {Application.LayoutDirection} getLayoutDirection
             * @readonly
             * @android
             * @since 3.1.3
             */
            readonly getLayoutDirection: LayoutDirection;
            /**
             * Application package name.
             *
             * @property {String} packageName
             * @readonly
             * @android
             * @since 0.1
             */
            packageName: string;
            /**
             * This method checks for a permission is shown before to user
             * and the program is about to request the same permission again.
             *
             * @method shouldShowRequestPermissionRationale
             * @param {String} permission
             * @return {Boolean}
             * @android
             * @since 1.2
             */
            shouldShowRequestPermissionRationale: (permission: string) => boolean;
            /**
             * Triggered when user press back key. The default implementation finishes the application,
             * but you can override this to do whatever you want.
             *
             * @event onBackButtonPressed
             * @android
             * @deprecated
             * @since 3.2.0
             * @example
             * ````
             * import Application from '@smartface/native/application';
             *
             * Application.on(Application.Events.BackButtonPressed, () => {
             * 	console.info('onBackButtonPressed');
             * });
             * ````
             */
            onBackButtonPressed: () => void;
            /**
             * Called to process touch screen events. You can assign callback to intercept all touch screen events before they are dispatched to the window (except independent windows like dialog and etc.).
             * Be sure to call this implementation for touch screen events that should be handled normally. Callback might be fired several times.
             *
             *     @example
             *     const Application = require("@smartface/native/application");
             *     Application.android.dispatchTouchEvent = function(){
             *        return true; //Consume all touches & do not pass to window
             *     }
             *
             * @event dispatchTouchEvent
             * @android
             * @return {Boolean}
             * @since 4.0.3
             */
            dispatchTouchEvent: () => boolean;
            /**
             * This event is called after Application.requestPermissions function. This event is
             * fired asynchronous way, there is no way to make sure which request is answered.
             *
             * @since 1.2
             * @event onRequestPermissionsResult
             * @param {Object} e
             * @param {Number} e.requestCode
             * @param {Boolean} e.result
             * @android
             * @deprecated
             * @since 1.2
             */
            onRequestPermissionsResult: (e: {
                requestCode: number;
                result: boolean;
            }) => void;
            navigationBar?: NavigationBar;
            /**
             * This function checks if one of the dangerous permissions is granted at beginning or not.
             * For android versions earlier than 6.0, it will return value exists in manifest or not.
             * For permissions in same category with one of the permissions is approved earlier, checking
             * will return as it is not required to request for the same category permission.
             *
             * @method checkPermission
             * @param {String} permission
             * @return {Boolean}
             * @android
             * @since 1.2
             */
            checkPermission: (permission: string) => boolean;
            /**
             * With requestPermissions, the System Dialog will appear to ask for
             * permission grant by user for dangerous(privacy) permissions.
             * {@link Application.android#onRequestPermissionsResult onRequestPermissionsResult} will be fired after user interact with permission dialog.
             *
             *     @example
             *     const Application = require("@smartface/native/application");
             *     Application.android.requestPermissions(1002, Application.Android.Permissions.WRITE_EXTERNAL_STORAGE)
             *     Application.android.onRequestPermissionsResult = function(e){
             *         console.log(JSON.stringify(e));
             *     }
             *
             * @method requestPermissions
             * @param {Number} requestIdentifier This number  will be returned in {@link Application.android.onRequestPermissionsResult onRequestPermissionsResult} when the user give permission or not.
             * @param {String} permission
             * @android
             * @since 1.2
             */
            requestPermissions: (requestIdentifier: number, permission: string) => void;
            keyboardMode: KeyboardMode;
        }>;
        Android: Partial<{
            KeyboardMode: typeof KeyboardMode;
            NavigationBar: {
                style: NavigationBarStyle;
            };
            /**
             * @enum Application.Android.Permissions
             * @since 1.1.16
             *
             * Permission enum for Application.
             * Permission managements should be developed OS specific in the applications.
             * Application.android.Permissions deprecated since 1.1.16. Use Application.Android.Permissions instead.
             */
            Permissions: {
                /**
                 * Allows to read the calendar data.
                 *
                 * @property READ_CALENDAR
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_CALENDAR: any;
                /**
                 * Allows an application to write the user's calendar data.
                 *
                 * @property WRITE_CALENDAR
                 * @readonly
                 * @since 1.1.16
                 */
                readonly WRITE_CALENDAR: any;
                /**
                 * Required to be able to access the camera device.
                 *
                 * @property CAMERA
                 * @readonly
                 * @since 1.1.16
                 */
                readonly CAMERA: any;
                /**
                 * Allows an application to read the user's contacts data.
                 *
                 * @property READ_CONTACTS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_CONTACTS: any;
                /**
                 * Allows an application to write the user's contacts data.
                 *
                 * @property WRITE_CONTACTS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly WRITE_CONTACTS: any;
                /**
                 * Allows access to the list of accounts in the Accounts Service.
                 *
                 * @property GET_ACCOUNTS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly GET_ACCOUNTS: any;
                /**
                 * Allows an app to access precise location.
                 *
                 * @property ACCESS_FINE_LOCATION
                 * @readonly
                 * @since 1.1.16
                 */
                readonly ACCESS_FINE_LOCATION: any;
                /**
                 * Allows an app to access approximate location.
                 *
                 * @property ACCESS_COARSE_LOCATION
                 * @readonly
                 * @since 1.1.16
                 */
                readonly ACCESS_COARSE_LOCATION: any;
                /**
                 * Allows an application to record audio.
                 *
                 * @property RECORD_AUDIO
                 * @readonly
                 * @since 1.1.16
                 */
                readonly RECORD_AUDIO: any;
                /**
                 * Allows read only access to phone state, including the phone number of the device,
                 * current cellular network information, the status of any ongoing calls, and a list
                 * of any PhoneAccounts registered on the device.
                 *
                 * @property READ_PHONE_STATE
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_PHONE_STATE: any;
                /**
                 * Allows an application to initiate a phone call without going through the
                 * Dialer user interface for the user to confirm the call.
                 *
                 * @property CALL_PHONE
                 * @readonly
                 * @since 1.1.16
                 */
                readonly CALL_PHONE: any;
                /**
                 * Allows an application to read the user's call log.
                 *
                 * @property READ_CALL_LOG
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_CALL_LOG: any;
                /**
                 * Allows an application to write (but not read) the user's call log data.
                 *
                 * @property WRITE_CALL_LOG
                 * @readonly
                 * @since 1.1.16
                 */
                readonly WRITE_CALL_LOG: any;
                /**
                 * Allows an application to add voicemails into the system.
                 *
                 * @property ADD_VOICEMAIL
                 * @readonly
                 * @since 1.1.16
                 */
                readonly ADD_VOICEMAIL: any;
                /**
                 * Allows an application to use SIP service.
                 *
                 * @property USE_SIP
                 * @readonly
                 * @since 1.1.16
                 */
                readonly USE_SIP: any;
                /**
                 * Allows an application to see the number being dialed during an
                 * outgoing call with the option to redirect the call to a different
                 * number or abort the call altogether.
                 *
                 * @property PROCESS_OUTGOING_CALLS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly PROCESS_OUTGOING_CALLS: any;
                /**
                 * Allows an application to access data from sensors
                 * that the user uses to measure what is happening inside
                 * his/her body, such as heart rate.
                 *
                 * @property BODY_SENSORS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly BODY_SENSORS: any;
                /**
                 * Allows an application to send SMS messages.
                 *
                 * @property SEND_SMS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly SEND_SMS: any;
                /**
                 * Allows an application to receive SMS messages.
                 *
                 * @property RECEIVE_SMS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly RECEIVE_SMS: any;
                /**
                 * Allows an application to read SMS messages.
                 *
                 * @property READ_SMS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_SMS: any;
                /**
                 * Allows an application to receive WAP push messages.
                 *
                 * @property RECEIVE_WAP_PUSH
                 * @readonly
                 * @since 1.1.16
                 */
                readonly RECEIVE_WAP_PUSH: any;
                /**
                 * Allows an application to monitor incoming MMS messages.
                 *
                 * @property RECEIVE_MMS
                 * @readonly
                 * @since 1.1.16
                 */
                readonly RECEIVE_MMS: any;
                /**
                 * Allows to read from external storage.
                 * If you granted {@link Application.Android.Permissions#WRITE_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE} permission,
                 * you don't need this to granted this permission.
                 *
                 * @property READ_EXTERNAL_STORAGE
                 * @readonly
                 * @since 1.1.16
                 */
                readonly READ_EXTERNAL_STORAGE: any;
                /**
                 * Allows to write to external storage.
                 *
                 * @property WRITE_EXTERNAL_STORAGE
                 * @readonly
                 * @since 1.1.16
                 */
                readonly WRITE_EXTERNAL_STORAGE: any;
                /**
                 * Allows applications to write the apn settings and read sensitive fields of an existing apn settings like user and password.
                 *
                 * @property WRITE_APN_SETTINGS
                 * @readonly
                 * @since 4.3.2
                 */
                readonly WRITE_APN_SETTINGS: any;
            };
        }>;
        /**
         * Set the configure the native theme.
         *
         * @method setAppTheme
         * @param {String} currentTheme
         * @android
         * @since 4.0.2
         */
        setAppTheme: (theme: string) => void;
        /**
         * Triggered when unhandelled error occurs.
         *
         * @since 1.2
         * @event onUnhandledError
         * @param {Object} error
         * @param {String} error.message
         * @param {String} error.stack
         * @deprecated
         * @android
         * @ios
         * @since 1.2
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.UnhandledError, (error) => {
         * 	console.info('onUnhandledError', error);
         * });
         * ````
         */
        onUnhandledError: (error: UnhandledError) => void;
        /**
         * Triggered before exiting application.
         *
         * @since 0.1
         * @event onExit
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.Exit, () => {
         * 	console.info('onExit');
         * });
         * ````
         */
        onExit(): void;
        /**
         * Triggered after a push (remote) notification recieved. This event will be
         * fired only if application is active and running.
         *
         * @event onReceivedNotification
         * @param {Object} data
         * @param {Object} data.remote
         * @param {Object} data.local
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.ReceivedNotification, (params) => {
         * 	console.info('onReceivedNotification', params);
         * });
         * ````
         */
        onReceivedNotification: (data: Partial<{
            remote: {
                [key: string]: any;
            };
            local: {
                [key: string]: any;
            };
        }>) => void;
        /**
         * Triggered when application is called by another application.
         * For Android, onApplicationCallReceived will be triggered when
         * the application started from System Launcher. For this reason,
         * if data does not contain key that you can handle, you should ignore this call.
         *
         * @event onApplicationCallReceived
         * @param {Object} e
         * @param {Object} e.data Data sent by application.
         * @param {String} e.eventType Can be "call" or "callback".
         * This parameter is available only for Android. For iOS this always returns "call".
         * For example; Application A calls application B, eventType becomes "call" for application B.
         * When application B is done its job and application A comes foreground and eventType becomes
         * "callback" for Android.
         * @param {Number} e.result This parameter is available only for Android and when eventType is
         * "callback". Returns Android Activity result code.
         * @see https://developer.android.com/training/basics/intents/result.html
         * @android
         * @ios
         * @deprecated
         * @since 1.1.13
         * @see https://developer.android.com/training/sharing/receive.html
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.ApplicationCallReceived, (params) => {
         * 	console.info('onApplicationCallReceived', params);
         * });
         * ````
         */
        onApplicationCallReceived: (e: {
            data: {
                [key: string]: any;
            };
        }) => void;
        /**
         * Triggered when application is opened by an app shortcut.
         * App shortcuts is also named Home Screen Quick Actions in iOS.
         *
         * @event onAppShortcutReceived
         * @param {Object} e
         * @param {Object} e.data Data comes from extras of app shortcut intent in Android
         * or UserInfo of app shortcut in iOS.
         *
         * @android
         * @ios
         * @deprecated
         * @since 4.3.6
         * @see https://developer.android.com/guide/topics/ui/shortcuts
         * @see https://developer.apple.com/documentation/uikit/menus_and_shortcuts/add_home_screen_quick_actions
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.AppShortcutReceived, (params) => {
         * 	console.info('onAppShortcutReceived', params);
         * });
         * ````
         */
        onAppShortcutReceived: (e: {
            data: {
                [key: string]: any;
            };
        }) => void;
        /**
         * Triggered after application bring to foreground state. In Android, it triggered even the user is leaving another activity(even the activities launched by your app).
         * That means Permissions & derived from Dialog components are makes this callback to triggered.
         *
         * @since 0.1
         * @event onMaximize
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.Maximize, () => {
         * 	console.info('onMaximize');
         * });
         * ````
         */
        onMaximize: () => void;
        /**
         * Triggered after application bring to background state. Background state means that user is in another app or on the home screen. In Android, it triggered even the user is launching another activity(even the activities launched by your app).
         * That means Permissions & derived from Dialog components are make this callback to triggered.
         *
         * @since 0.1
         * @event onMinimize
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         * @example
         * ````
         * import Application from '@smartface/native/application';
         *
         * Application.on(Application.Events.Minimize, () => {
         * 	console.info('onMinimize');
         * });
         * ````
         */
        onMinimize: () => void;
        /**
         * This function hides keyboard.
         *
         * @method hideKeyboard
         * @android
         * @ios
         * @since 3.0.1
         */
        hideKeyboard: () => void;
        /**
         * The specified release channel within project.json.
         *
         * @property {String} currentReleaseChannel
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        currentReleaseChannel: string;
        /**
         * The application name within project.json
         *
         * @property {String} smartfaceAppName
         * @readonly
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         */
        smartfaceAppName: string;
        /**
         * The application name within project.json
         *
         * @property {String} appName
         * @readonly
         * @android
         * @ios
         * @since 4.0.7
         */
        appName: string;
        /**
         * The application version within project.json
         *
         * @property {Number} version
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        version: string;
        Events: typeof ApplicationEvents;
        /**
         * Indicates whether the voiceover is enabled. Voiceover is also called a screen reader on Android.
         *
         * @property {Boolean} isVoiceOverEnabled
         * @readonly
         * @android
         * @ios
         * @since 4.3.6
         */
        isVoiceOverEnabled: Boolean;
        currentPage: Page;
        registOnItemSelectedListener(): void;
        tabBar?: BottomTabBar;
        __mDrawerLayout: any;
    }
}
declare module "application/index" {
    import { ApplicationBase } from "application/application";
    const Application: ApplicationBase;
    export default Application;
}
declare module "util/Android/transition/fragmenttransition" {
    namespace FragmentTransaction {
        enum AnimationType {
            RIGHTTOLEFT = "0",
            LEFTTORIGHT = "1"
        }
        let pageCount: number;
        function generatePageID(): number;
        function push(params: any): void;
        function pop(params: any): void;
        function replace(params: any): void;
        function revealTransition(transitionViews: any, page: any, animated?: boolean): void;
        function popUpTransition(page: any, animation: any): void;
        function dismissTransition(page: any, animation: any): void;
        function checkBottomTabBarVisible(page: any): void;
        function addSharedElement(params: any): void;
        function leftToRightTransitionAnimation(fragmentTransaction: any): void;
        function rightToLeftTransitionAnimation(fragmentTransaction: any): void;
        function setPopUpAnimationsCache(): any;
    }
    export default FragmentTransaction;
}
declare module "util/Android/attributedtitle" {
    import AttributedString from "global/attributedstring/index";
    export default class AttributedTitle {
        private context;
        private _attributedTitle;
        constructor(context: any);
        get attributedTitle(): AttributedString;
        set attributedTitle(value: AttributedString);
    }
}
declare module "util/Android/directionbasedconverter" {
    import View from "ui/view/index";
    import FragmentTransaction from "util/Android/transition/fragmenttransition";
    namespace DirectionBasedConverter {
        function convertArray(array: any[]): any[];
        function convertIndex(array: any[], index: number): number;
        function getAnimationType(animationType: FragmentTransaction.AnimationType): FragmentTransaction.AnimationType | undefined;
        function setLayoutDirection(nativeLayout: any): void;
        function flipHorizontally(view: View): void | View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<import("ui/view").IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>;
        function convertMargin(layoutParams: any, left: number, top: number, right: number, bottom: number): any;
    }
    export default DirectionBasedConverter;
}
declare module "util/Android/unitconverter" {
    namespace AndroidUnitConverter {
        const displayMetrics: any;
        const density: any;
        function pixelToDp(pixel: number): number;
        function dpToPixel(dp: number): number;
    }
    export default AndroidUnitConverter;
}
declare module "util/Android/headerbaritempadding" {
    namespace Paddings {
        const horizontal: number;
        const vertical: number;
    }
    export default Paddings;
}
declare module "util/Android/layoutparams" {
    namespace LayoutParams {
        const MATCH_PARENT = -1;
        const WRAP_CONTENT = -2;
    }
    export default LayoutParams;
}
declare module "util/Android/requestcodes" {
    export enum WebView {
        REQUEST_CODE_LOLIPOP = 1111,
        RESULT_CODE_ICE_CREAM = 2222
    }
    export enum EmailComposer {
        EMAIL_REQUESTCODE = 57
    }
    export enum Sound {
        PICK_SOUND = 1004
    }
    export const Multimedia: Readonly<{
        CAMERA_REQUEST: number;
        PICK_FROM_GALLERY: number;
        PICK_MULTIPLE_FROM_GALLERY: number;
        CropImage: {
            CROP_CAMERA_DATA_REQUEST_CODE: number;
            CROP_GALLERY_DATA_REQUEST_CODE: number;
        };
    }>;
    export enum Contacts {
        PICK_REQUEST_CODE = 1001,
        PICKFROM_REQUEST_CODE = 1005
    }
    export enum DocumentPicker {
        PICK_DOCUMENT_CODE = 2000
    }
    export enum Location {
        CHECK_SETTINGS_CODE
    }
}
declare module "util/Android/systemservices" {
    enum SystemServices {
        INPUT_METHOD_SERVICE = "input_method",
        INPUT_METHOD_MANAGER = "android.view.inputmethod.InputMethodManager"
    }
    export default SystemServices;
}
declare module "util/Android/typevalue" {
    namespace TypeValue {
        const COMPLEX_UNIT_DIP = 1;
        const COMPLEX_UNIT_SP = 2;
    }
    export default TypeValue;
}
declare module "util/Android/textviewsizecalculator" {
    export function calculateStringSize(params: any): {
        height: number;
        width: number;
    };
}
declare module "util/copyObjectPropertiesWithDescriptors" {
    /**
     * This internal method will be used for inheriting OS specific getter and setters.
     * This also helps for composition between multiple objects across different files.
     *
     * @param target
     * @param args
     * @example
     * ```
     * // base class
     * const self = this;
     *  const android = {
          get test() {
            return self._test;
          },
          set test(value: string) {
            self._test = value;
          }
        };
        // child class
        const self = this;
     *  const android = {
          get test() {
            this.doStuffBefore();
            return self._test;
          },
          set test(value: string) {
            this.setOtherStuff();
            self._test = value;
          }
        };
        // Not always necessary
     *  const otherAndroid = {
          get test() {
            this.doStuffBefore();
            return self._test;
          }
        };
        copyObjectPropertiesWithDescriptors(this._android, android, otherAndroid)
     * ```
     */
    export default function copyObjectPropertiesWithDescriptors(target: Record<string, any>, ...args: Record<string, any>[]): void;
}
declare module "util/index" {
    export { default as Exception } from "util/exception";
    export { default as TypeUtil } from "util/type";
    export { default as UIControlEvents } from "util/iOS/uicontrolevents";
    export * as YogaEnums from "util/iOS/yogaenums";
    export { default as UIDatePickerMode } from "util/iOS/uidatepickermode";
    export { default as KeyboardAnimationDelegate } from "util/iOS/keyboardanimationdelegate";
    export { default as Invocation } from "util/iOS/invocation";
    export { default as FragmentTransition } from "util/Android/transition/fragmenttransition";
    export { default as viewController } from "util/Android/transition/viewcontroller";
    export { default as AndroidConfig } from "util/Android/androidconfig";
    export { default as AttributedTitle } from "util/Android/attributedtitle";
    export { default as DirectionBasedConverter } from "util/Android/directionbasedconverter";
    export { default as HeaderBarItemPadding } from "util/Android/headerbaritempadding";
    export { default as LayoutParams } from "util/Android/layoutparams";
    export * as RequestCodes from "util/Android/requestcodes";
    export { default as SystemServices } from "util/Android/systemservices";
    export * as TextViewSizeCalculator from "util/Android/textviewsizecalculator";
    export { default as TypeValue } from "util/Android/typevalue";
    export { default as UnitConverter } from "util/Android/unitconverter";
    export { default as copyObjectPropertiesWithDescriptors } from "util/copyObjectPropertiesWithDescriptors";
}
declare module "core/native-mobile-component" {
    import NativeComponent from "core/native-component";
    export type MobileOSProps<TIOS = {
        [key: string]: any;
    }, TAND = {
        [key: string]: any;
    }> = {
        ios: Partial<TIOS>;
        android: Partial<TAND>;
    };
    export type WithMobileOSProps<TProps extends Record<string, any> = {}, TIOS extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TAND extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }> = MobileOSProps<TIOS, TAND> & TProps;
    export abstract class NativeMobileComponent<TNative extends Record<string, any> = Record<string, any>, TProps extends WithMobileOSProps<{
        [key: string]: any;
    }> = WithMobileOSProps<{
        [key: string]: any;
    }>> extends NativeComponent<TNative> {
        private _ios;
        protected _android: TProps['android'];
        constructor({ android, ios, ...rest }?: Partial<TProps>);
        protected addAndroidProps(props: TProps['android']): void;
        protected addIOSProps(props: TProps['ios']): void;
        get ios(): TProps['ios'];
        get android(): TProps['android'];
    }
}
declare module "core/native-event-emitter-component" {
    import { EventListenerCallback, IEventEmitter } from "core/eventemitter/index";
    import { NativeMobileComponent, WithMobileOSProps } from "core/native-mobile-component";
    export default abstract class NativeEventEmitterComponent<TEvent extends string, TNative extends Record<string, any> = Record<string, any>, TProps extends WithMobileOSProps = WithMobileOSProps> extends NativeMobileComponent<TNative, WithMobileOSProps<TProps>> implements IEventEmitter<TEvent> {
        private emitter;
        on(eventName: TEvent, callback: EventListenerCallback): () => void;
        once(eventName: TEvent, callback: EventListenerCallback): () => void;
        off(eventName: TEvent, callback: EventListenerCallback): void;
        emit(event: TEvent, ...args: any[]): void;
    }
}
declare module "device/accelerometer/accelerometer-events" {
    export const AccelerometerEvents: {
        /**
         * Callback to capture accelerometer events.
         *
         * @since 0.1
         * @event Accelerate
         * @param {Object} event
         * @param {Number} event.x
         * @param {Number} event.y
         * @param {Number} event.z
         * @android
         * @ios
         */
        readonly Accelerate: "accelerate";
    };
    export type AccelerometerEvents = ExtractValues<typeof AccelerometerEvents>;
}
declare module "device/accelerometer/index" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { AccelerometerEvents } from "device/accelerometer/accelerometer-events";
    /**
     * @class Device.Accelerometer
     * @since 0.1
     *
     * Accelerometer is an interface for accessing accelerometer data on the device.
     *
     *     @example
     *     const Accelerometer = require('@smartface/native/device/accelerometer');
     *     Accelerometer.start();
     *     Accelerometer.onAccelerate = function(e) {
     *         console.log("x: " + e.x + "  y : " + e.y + "  z : " + e.z);
     *         if (event.z > 9) {
     *             Accelerometer.stop();
     *         }
     *     };
     *
     */
    export interface IAccelerometer extends NativeEventEmitterComponent<AccelerometerEvents> {
        /**
         * Starts capturing accelerometer values.
         *
         * @method start
         * @android
         * @ios
         * @since 0.1
         */
        start: () => void;
        /**
         * Stops capturing.
         *
         * @method stop
         * @android
         * @ios
         * @since 0.1
         */
        stop: () => void;
        /**
         * Callback to capture accelerometer events.
         *
         * @since 0.1
         * @event onAccelerate
         * @param {Object} event
         * @param {Number} event.x
         * @param {Number} event.y
         * @param {Number} event.z
         * @android
         * @ios
         * @deprecated
         * @example
         * ````
         * import AcceleroMeter from '@smartface/native/device/accelerometer';
         *
         * AcceleroMeter.on(AcceleroMeter.Events.Accelerate, (params) => {
         *  console.info('onAccelerate', params);
         * });
         * ````
         */
        onAccelerate: (e: {
            x: number;
            y: number;
            z: number;
        }) => void;
        ios: Partial<{
            /**
             * The interval, in millisecond, for providing accelerometer updates to the block handler.
             *
             * @property {Number} [accelerometerUpdateInterval = 100]
             * @ios
             * @since 4.0.2
             */
            accelerometerUpdateInterval: number;
        }>;
    }
    const Accelerometer: IAccelerometer;
    type Accelerometer = IAccelerometer;
    export default Accelerometer;
}
declare module "device/location/location-events" {
    export const LocationEvents: {
        readonly LocationChanged: "locationChanged";
    };
    export type LocationEvents = ExtractValues<typeof LocationEvents>;
}
declare module "device/location/index" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import { LocationEvents } from "device/location/location-events";
    export interface ILocationAndroidProps {
        /**
         * Check whether current location settings are satisfied. If the location service is on, onComplete callback triggers.
         * Shows an dialog to open the location service when the location service is off.
         *
         * @method checkSettings
         * @param {Object} params
         * @param {Function} params.onSuccess
         * @param {Function} params.onFailure
         * @param {Object} params.onFailure.params
         * @param {Device.Location.Android.SettingsStatusCodes} params.onFailure.params.statusCode
         * @android
         * @static
         * @since 4.0.2
         */
        checkSettings(handlers: {
            onSuccess: () => void;
            onFailure: (e: {
                statusCode: LocationBase.Android.SettingsStatusCodes;
            }) => void;
        }): void;
    }
    export interface ILocationIOSProps {
        /**
         * Callback to capture authorization status changes.
         * This callback starts to working after call 'Location.start' function until call 'Location.stop' function.
         *
         * @event onChangeAuthorizationStatus
         * @param {Boolean} status
         * @ios
         * @since 2.0.11
         */
        onChangeAuthorizationStatus?(status: boolean): void;
        /**
         * Gets authorization status.
         *
         * @method getAuthorizationStatus
         * @return {Device.Location.iOS.AuthorizationStatus} status
         * @ios
         * @static
         * @since 2.0.11
         */
        getAuthorizationStatus(): LocationBase.iOS.AuthorizationStatus;
        /**
         * Returns a Boolean value indicating whether location services are enabled on the device.
         *
         * @method locationServicesEnabled
         * @return {Boolean} status
         * @ios
         * @static
         * @since 2.0.11
         */
        locationServicesEnabled(): boolean;
    }
    /**
     * @class Device.Location
     * @since 0.1
     *
     * Device.Location allows capturing location change events on the device. In Android, ACCESS_FINE_LOCATION permission must be taken on run time for 23 api level and above.
     *
     *     @example
     *     const Timer    = require("@smartface/native/timer");
     *     const Location = require('@smartface/native/device/location');
     *
     *     Location.start(Location.Android.Priority.HIGH_ACCURACY);
     *     Location.onLocationChanged = function(event) {
     *         console.log("Location latitude: " + event.latitude + "  Longitude: " + event.longitude);
     *     };
     *
     *     Timer.setTimeout({
     *         delay: 30000,
     *         task: function() { Location.stop() }
     *     });
     *
     */
    export interface ILocation<TEvent extends string = LocationEvents, TMobile extends MobileOSProps<ILocationIOSProps, ILocationAndroidProps> = MobileOSProps<ILocationIOSProps, ILocationAndroidProps>> extends NativeEventEmitterComponent<TEvent | LocationEvents, TMobile> {
        /**
         * Starts capturing.For Android, need to define interval & priority which need to be decided wisely;
         * HIGH_ACCURACY, LOW_POWER , NO_POWER or BALANCED. iOS will ignore this priority.
         *
         * @method start
         * @param {Location.Android.Priority} [priority = Location.Android.Priority.HIGH_ACCURACY]
         * @param {Number} [interval = 1000]
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        start(priority?: LocationBase.Android.Priority, interval?: number): void;
        /**
         * Stops capturing.
         *
         * @method stop
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        stop(): void;
        /**
         * Callback to capture location events.
         *
         * @event onLocationChanged
         * @deprecated
         * @param {Object} event
         * @param {Number} event.latitude
         * @param {Number} event.longitude
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import Location from '@smartface/native/device/location';
         *
         * Location.on(Location.Events.LocationChanged, (params) => {
         * 	console.info('onLocationChanged', params);
         * });
         * ````
         */
        onLocationChanged: (e: {
            latitude: number;
            longitude: number;
        }) => void;
        /**
         * Gets last known location. The onFailure function will be triggered if no location data has ever been retrieved or unexpected error occurred.
         *
         * @method getLastKnownLocation
         * @param {Function} onSuccess
         * @param {Number}   onSuccess.latitude
         * @param {Number}   onSuccess.longitude
         * @param {Function} onFailure
         * @android
         * @ios
         * @static
         * @since 4.0.2
         */
        getLastKnownLocation(onSuccess: (e: {
            latitude: number;
            longitude: number;
        }) => void, onFailure: () => void): void;
        __onActivityResult: (resultCode: number) => void;
    }
    export namespace LocationBase {
        /**
         * iOS Specific Properties.
         * @class Device.Location.iOS
         * @since 3.1.1
         */
        namespace iOS {
            /**
             * @enum {Number} Device.Location.iOS.AuthorizationStatus
             * @since 3.1.1
             * @ios
             */
            enum AuthorizationStatus {
                /**
                 * The user has not yet made a choice regarding whether this app can use location services.
                 *
                 * @property {Number} NOTDETERMINED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                NOTDETERMINED = 0,
                /**
                 * This app is not authorized to use location services.
                 *
                 * @property {Number} RESTRICTED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                RESTRICTED = 1,
                /**
                 * The user explicitly denied the use of location services for this app or location services are currently disabled in Settings.
                 *
                 * @property {Number} DENIED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                DENIED = 2,
                /**
                 * This app is authorized to use location services.
                 *
                 * @property {Number} AUTHORIZED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                AUTHORIZED = 3
            }
        }
        /**
         * Android Specific Properties.
         * @class Device.Location.Android
         * @since 1.1.16
         */
        namespace Android {
            /**
             * @enum Device.Location.Android.Provider
             * @android
             * @since 1.1.16
             *
             * Location providers for Android. For lower power consumption use Network
             * but for better accuracy use GPS; for let the device decide to provider use Auto
             * or don't pass parameter.
             * Location.android.Provider deprecated since 1.1.16. Use Device.Location.Android.Provider instead.
             *
             * @deprecated Use {@link Device.Location.Android.Priority} instead
             */
            enum Provider {
                /**
                 * Let the device decide provider to use.
                 *
                 * @property AUTO
                 * @static
                 * @readonly
                 * @since 1.1.16
                 */
                AUTO,
                /**
                 * Use GPS as location provider. GPS has better accuracy and also has higher power
                 * consumption than {@link Location.Android.Provider#NETWORK NETWORK}.
                 *
                 * @property GPS
                 * @static
                 * @readonly
                 * @since 1.1.16
                 */
                GPS,
                /**
                 * Use network as location provider. Network has lower power consumption and accuracy
                 * than {@link Location.Android.Provider#GPS GPS}.
                 *
                 * @property NETWORK
                 * @static
                 * @readonly
                 * @since 1.1.16
                 */
                NETWORK
            }
            /**
             * @enum Device.Location.Android.Priority
             * @android
             * @since 3.1.1
             *
             * Location Priority enums indicates the quality of service for location updates.
             * For example, if your application wants high accuracy location it should start a location  with  Location.Android.Priority.HIGH_ACCURACY.
             *
             */
            enum Priority {
                /**
                 * High accuracy. Least battery efficient. Uses GPS only.
                 *
                 * @property HIGH_ACCURACY
                 * @static
                 * @readonly
                 * @since 3.1.1
                 */
                HIGH_ACCURACY,
                /**
                 * Block level accuracy is considered to be about 100 meter accuracy.
                 * Using a coarse accuracy such as this often consumes less power.
                 *
                 * @property BALANCED
                 * @static
                 * @readonly
                 * @since 3.1.1
                 */
                BALANCED,
                /**
                 * City level accuracy is considered to be about 10km accuracy.
                 * Using a coarse accuracy such as this often consumes less power
                 *
                 * @property LOW_POWER
                 * @static
                 * @readonly
                 * @since 3.1.1
                 */
                LOW_POWER,
                /**
                 * No locations will be returned unless a different client has requested location updates in which case this request will act as a passive listener to those locations.
                 *
                 * @property NO_POWER
                 * @static
                 * @readonly
                 * @since 3.1.1
                 */
                NO_POWER
            }
            /**
             * @enum Device.Location.Android.SettingsStatusCodes
             * @android
             * @since 4.0.2
             *
             * Location settings specific status codes.
             */
            enum SettingsStatusCodes {
                /**
                 * @property {NUMBER} OTHER
                 * @android
                 * @since 4.0.2
                 *
                 * Location settings can't be changed to meet the requirements, no dialog pops up.
                 */
                OTHER = 0,
                /**
                 * @property {NUMBER} DENIED
                 * @android
                 * @since 4.0.2
                 *
                 * The user explicitly denied the use of location services for this app.
                 */
                DENIED = 1
            }
        }
    }
    const Location: ILocation;
    type Location = ILocation;
    export default Location;
}
declare module "global/blob/index" {
    import { BlobBase } from "global/blob/blob";
    const Blob: typeof BlobBase;
    type Blob = BlobBase;
    export default Blob;
}
declare module "io/filestream/filestream" {
    import { INativeComponent } from "core/inative-component";
    import NativeComponent from "core/native-component";
    import Blob from "global/blob/index";
    import { BlobBase } from "global/blob/blob";
    import { IFile } from "io/file/file";
    export enum FileStreamType {
        APPEND = 0,
        READ = 1,
        WRITE = 2
    }
    export enum FileContentMode {
        TEXT = 0,
        BINARY = 1
    }
    export interface IFileStream extends INativeComponent {
        /**
         * Gets the mode of FileStream operation.
         * @android
         * @ios
         * @since 0.1
         */
        mode: FileStreamType;
        /**
         * Gets the content mode of FileStream operation.
         * @android
         * @ios
         * @since 0.1
         */
        contentMode: FileContentMode;
        /**
         * Checks whether the stream is readable.
         * @android
         * @ios
         * @since 0.1
         */
        isReadable: boolean;
        /**
         * Checks whether the stream is writable.
         * @android
         * @ios
         * @since 0.1
         */
        isWritable: boolean;
        /**
         * Gets the name of the file it belongs to.
         * @android
         * @ios
         * @since 0.1
         */
        name: string;
        /**
         * Gets the path of the file it belongs to.
         * @android
         * @ios
         * @since 0.1
         */
        path: string;
        offset: number;
        /**
         * Closes the FileStream instance. FileStream have to be closed when its job is done.
         * @android
         * @ios
         * @since 0.1
         */
        close: () => void;
        /**
         * Gets the {@link Blob} object from FileStream.
         * @android
         * @ios
         * @deprecated since 1.1.10, you may use FileStream.readToEnd() function after you change contentMode of FileStream to FileStream.ContentMode.BINARY.
         */
        readBlob: () => Blob;
        /**
         * Gets all characters or blob content from the file stream depending of {@link IO.FileStream#ContentMode contentMode} content mode.
         * If FileStream not opened with {@link IO.FileStream.StreamType#READ} mode, returns null.
         * @android
         * @ios
         * @since 0.1
         */
        readToEnd: () => string | Blob;
        /**
         * Writes all characters or blob content into the file stream depending of {@link IO.FileStream#ContentMode contentMode} content mode.
         * If the file stream opened with {@link IO.FileStream.StreamType#READ}, returns false.
         * @android
         * @ios
         * @since 0.1
         */
        write: (content: string | Blob) => boolean;
        /**
         * iOS only metthod
         * @iOS
         */
        seekToEnd?: () => void;
    }
    export interface FileStreamParams extends IFileStream {
        source: IFile;
        streamType: FileStreamType;
        contentMode: FileContentMode;
    }
    export abstract class FileStreamBase extends NativeComponent implements IFileStream {
        constructor(params?: Partial<FileStreamParams>);
        mode: FileStreamType;
        contentMode: FileContentMode;
        isReadable: boolean;
        isWritable: boolean;
        name: string;
        path: string;
        offset: number;
        close: () => void;
        readBlob: () => BlobBase;
        readToEnd: () => string | BlobBase;
        write: (content: string | BlobBase) => boolean;
        seekToEnd?: (() => void) | undefined;
        static StreamType: typeof FileStreamType;
        static ContentMode: typeof FileContentMode;
        static create(path: any, streamMode: any, contentMode: number): FileStreamBase | undefined;
    }
}
declare module "io/filestream/index" {
    import { FileStreamBase } from "io/filestream/filestream";
    /**
     * @class IO.FileStream
     * @since 0.1
     *
     * FileStream is a class which allows you to making IO operations.
     *
     *     @example
     *     import File from '@smartface/native/io/file';
     *     import Path from '@smartface/native/io/path';
     *     import FileStream from '@smartface/native/io/filestream';
     *     const myFile = new File({
     *         path: Path.DataDirectory + '/myFile.txt'
     *     });
     *     const myFileStream = myFile.openStream(FileStream.StreamType.WRITE, FileStream.ContentMode.TEXT);
     *     myFileStream.write('Smartface');
     *     myFileStream.close();
     *
     */
    class FileStreamImpl extends FileStreamBase {
    }
    const FileStream: typeof FileStreamImpl;
    type FileStream = FileStreamImpl;
    export default FileStream;
}
declare module "io/path/path" {
    import { INativeComponent } from "core/inative-component";
    import NativeComponent from "core/native-component";
    export enum PATH_FILE_TYPE {
        FILE = 0,
        ASSET = 1,
        DRAWABLE = 2,
        EMULATOR_ASSETS = 3,
        EMULATOR_DRAWABLE = 4,
        RAU_ASSETS = 5,
        RAU_DRAWABLE = 6
    }
    export type AndroidProps = Partial<{
        storages: {
            external: string | null;
            internal: string | null;
            usb: string | null;
            isResolved: boolean | null;
        };
    }>;
    export interface IPath extends INativeComponent {
    }
    export class PathBase extends NativeComponent implements IPath {
        constructor(params?: Partial<IPath>);
        static FILE_TYPE: typeof PATH_FILE_TYPE;
        /**
         * Gets data directory path of the application.
         * @android
         * @ios
         * @since 0.1
         */
        static get DataDirectory(): string;
        /**
         * Gets URI scheme for files under assets folder.
         * @android
         * @ios
         * @since 0.1
         */
        static get AssetsUriScheme(): string;
        /**
         * Gets path separator for the running environment.
         * @android
         * @ios
         * @since 0.1
         */
        static get Separator(): string;
        static get ImagesUriScheme(): string;
        get android(): AndroidProps;
    }
}
declare module "io/file/file" {
    import { INativeComponent } from "core/inative-component";
    import { MobileOSProps, NativeMobileComponent } from "core/native-mobile-component";
    import FileStream from "io/filestream/index";
    import { FileContentMode, FileStreamType } from "io/filestream/filestream";
    import { PATH_FILE_TYPE } from "io/path/path";
    export interface FileiOSProps {
        getNSURL: () => __SF_NSURL;
    }
    export interface IFile extends INativeComponent, MobileOSProps<FileiOSProps, {}> {
        /**
         * Gets creation date of the File instance. If the file doesn't exist returns -1.
         * @android
         * @ios
         * @since 0.1
         */
        creationDate: number;
        /**
         * Check whether file or directory exists in given path.
         * @android
         * @ios
         * @since 0.1
         */
        exists: boolean;
        /**
         * Gets the extension of the file.
         * @android
         * @ios
         * @since 0.1
         */
        extension: string;
        /**
         * Check whether the File instance is a directory.
         * @android
         * @ios
         * @since 0.1
         */
        isDirectory: boolean;
        /**
         * Check whether the File instance is a file.
         * @android
         * @ios
         * @since 0.1
         */
        isFile: boolean;
        /**
         * Gets last modified time of the File. It measured in milliseconds. If file doesn't exists returns -1.
         * @android
         * @ios
         * @since 0.1
         */
        modifiedDate: number;
        /**
         * Gets the name of the file or directory.
         * @android
         * @ios
         * @since 0.1
         */
        name: string;
        /**
         * Gets the parent directory of the file or directory. If the file or parent of the file doesn't exist returns null.
         * @android
         * @ios
         * @since 0.1
         */
        parent: IFile | null;
        /**
         * Gets the path given on constructor. This property required for creating the File instance.
         * @android
         * @ios
         * @since 0.1
         */
        path: string;
        /**
         * Gets the size of the file or directory. If file or directory doesn't exists returns -1.
         * @android
         * @ios
         * @since 0.1
         */
        size: number;
        /**
         * @ios
         * @android
         */
        getAbsolutePath(): string;
        /**
         * Copy file or directory to given path.
         * @android
         * @ios
         * @since 0.1
         */
        copy(destination: string): boolean;
        /**
         * Creates the file named by this pathname.
         *
         * @param {Boolean} [createParents = false] If true, file will created with any necessary parent directories.
         * @return {Boolean}
         * @method createFile
         * @android
         * @ios
         * @since 0.1
         */
        createFile(createParents: boolean): boolean;
        /**
         * Creates the directory named by this pathname.
         *
         * @param {Boolean} [withParents = false] If true, directory will created with any necessary parent directories.
         * @return {Boolean}
         * @method createDirectory
         * @android
         * @ios
         * @since 0.1
         */
        createDirectory(createParents: any): boolean;
        /**
         * Deletes the file or directory.
         *
         * @param {Boolean} [withChilds = false] If true and the File object is a directory, all child files and directories will be removed.
         * @return {Boolean}
         * @method remove
         * @android
         * @ios
         * @since 0.1
         */
        remove(withChilds: boolean): boolean;
        /**
         * Returns the list of file and directories that exist in this director. If directory not exists or path is not refer a directory returns null.
         *
         * @return {IO.File[]}
         * @method getFiles
         * @android
         * @ios
         * @since 0.1
         */
        getFiles(): IFile[] | null;
        /**
         * Move the current file or directory to destination path.
         *
         * @param {String} destination
         * @return {Boolean}
         * @method move
         * @android
         * @ios
         * @since 0.1
         */
        move(destination: string): boolean;
        /**
         * Open a IO.FileStream object from this object. If path is refer a directory returns null.
         *
         * @param {IO.FileStream.StreamType} type
         * @param {IO.FileStream.ContentMode} contentMode. Optional, default value is IO.FileStream.ContentMode.TEXT
         * @return {IO.FileStream}
         * @method openStream
         * @android
         * @ios
         * @since 0.1
         */
        openStream(streamType: FileStreamType, contentMode: FileContentMode): FileStream | undefined;
        /**
         * Rename the current file or directory to given name.
         *
         * @param {String} newName
         * @return {Boolean}
         * @method rename
         * @android
         * @ios
         * @since 0.1
         */
        readonly writable: boolean;
        rename(newName: string): boolean;
        type: PATH_FILE_TYPE;
        fullPath: string;
    }
    export interface FileParams {
        path?: string;
    }
    export abstract class AbstractFile extends NativeMobileComponent<any, IFile> implements IFile {
        constructor(params?: Partial<IFile> & FileParams);
        fullPath: string;
        type: PATH_FILE_TYPE;
        creationDate: number;
        exists: boolean;
        extension: string;
        isDirectory: boolean;
        isFile: boolean;
        modifiedDate: number;
        name: string;
        parent: IFile | null;
        path: string;
        size: number;
        getAbsolutePath(): string;
        copy(destination: string): boolean;
        createFile(createParents: boolean): boolean;
        createDirectory(createParents: any): boolean;
        remove(withChilds: boolean): boolean;
        getFiles(): IFile[] | null;
        move(destination: string): boolean;
        openStream(streamType: FileStreamType, contentMode: FileContentMode): FileStream | undefined;
        readonly writable: boolean;
        rename(newName: string): boolean;
        static getDocumentsDirectory(): any;
        static getMainBundleDirectory(): any;
    }
}
declare module "io/file/index" {
    import { AbstractFile, IFile } from "io/file/file";
    class FileImpl extends AbstractFile {
        constructor(params: Partial<IFile>);
    }
    const File: typeof FileImpl;
    type File = FileImpl;
    export default File;
}
declare module "net/http/http" {
    import { INativeComponent } from "core/inative-component";
    import NativeComponent from "core/native-component";
    import { NativeMobileComponent, WithMobileOSProps } from "core/native-mobile-component";
    import Blob from "global/blob/index";
    import File from "io/file/index";
    import Image from "ui/image/index";
    /**
     * Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.
     * By validating both the certificate chain and host, certificate pinning provides a very secure form of server trust validation mitigating most, if not all, MITM attacks.
     * Applications are encouraged to always validate the host and require a valid certificate chain in production environments.
     *
     * @property {Array}    sslPinning
     * @property {String}   sslPinning.host
     * @property {Array}    sslPinning.certificates Only DER format accepted.
     * @property {Boolean}  [sslPinning.validateCertificateChain=true]
     * @property {Boolean}  [sslPinning.validateHost=true]
     * @ios
     * @since 4.3.4
     */
    export interface iOSProps {
        sslPinning?: {
            host: string;
            certificates: string[];
            validateCertificateChain?: boolean;
            validateHost?: boolean;
        }[];
    }
    type RequestOnload<T = {}> = (e: {
        statusCode: number;
        headers?: Record<string, string>;
        body?: Record<string, any>;
    } & T) => void;
    type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    type RequestParamsType<B = {}, L = {}> = {
        url: string;
        method: RequestMethod;
    } & B & {
        onLoad: RequestOnload<L>;
        onError: (e: {
            message?: string;
            body?: any;
            statusCode?: number;
            headers?: Record<string, string>;
        }) => void;
    };
    type ImageRequestParams = RequestParamsType<{}, {
        image: Image | null;
    }>;
    type StringRequestParams = RequestParamsType<{}, {
        string: string;
    }>;
    type JSONType = {
        [key: string]: string | number | null | boolean;
    };
    type FileRequestParams = RequestParamsType<{
        fileName?: string;
    }, {
        file?: File;
    }>;
    type JSONRequestParams = RequestParamsType<{}, {
        JSON: JSONType;
        string: string;
    }>;
    type RequestParams = RequestParamsType<{
        method: RequestMethod;
        headers?: Record<string, string>;
        user?: string;
        password?: string;
    }, {
        [key: string]: any;
    }>;
    /**
     *
     */
    type UploadParams = RequestParamsType<{
        body: {
            name: string;
            fileName: string;
            contentType: string;
            value: Blob;
            user: string;
            password: string;
            nativeObject?: any;
        };
    }, {
        body: Blob;
        statusCode: number;
        headers?: Record<string, string>;
    }> & {
        params: {
            url: string;
            headers?: Record<string, string>;
            method: string;
            body: any[] | Blob;
        };
    };
    export interface IHttp extends INativeComponent {
        cookiePersistenceEnabled: boolean;
        timeout: number;
        headers: Record<string, string>;
        ios: Partial<iOSProps>;
        /**
         * Cancels all requests.
         *
         * @method cancelAll
         * @android
         * @ios
         */
        cancelAll(): void;
        /**
         * @method requestFile
         *
         * Sends an http request to given url and saves response file
         * to temp directory of application. If request ends successfully
         * onLoad callback will be called with received File object.
         * @since 0.1
         */
        requestFile(params: FileRequestParams): HttpRequest;
        /**
         * @method requestImage
         *
         * Sends an http request to given url. If request ends successfully
         * onLoad callback will be called with received UI.Image object.
         *
         * @since 0.1
         */
        requestImage(params: ImageRequestParams): HttpRequest;
        /**
         * @method requestString
         *
         * Sends an http request to given url. If request ends successfully
         * onLoad callback will be called with received string.
         *
         * @since 0.1
         */
        requestString(params: StringRequestParams): HttpRequest;
        /**
         * @method requestJSON
         *
         * Sends an http request to given url. If request ends successfully
         * onLoad callback will be called with received JSON object.
         *
         * @since 0.1
         */
        requestJSON(params: JSONRequestParams): HttpRequest;
        /**
         * @method request
         *
         * Sends an http request defined with parameters.
         *
         * @since 0.1
         */
        request(params: RequestParams, isMultipart?: boolean): HttpRequest;
        upload(params: UploadParams): HttpRequest;
    }
    export abstract class HttpBase extends NativeMobileComponent<any, WithMobileOSProps<IHttp, iOSProps, {}>> implements IHttp {
        constructor(params?: Partial<IHttp>);
        abstract cookiePersistenceEnabled: boolean;
        abstract get timeout(): number;
        abstract set timeout(value: number);
        abstract get headers(): Record<string, string>;
        abstract requestFile(params: FileRequestParams): HttpRequest;
        abstract requestImage(params: ImageRequestParams): HttpRequest;
        abstract requestString(params: StringRequestParams): HttpRequest;
        abstract requestJSON(params: JSONRequestParams): HttpRequest;
        abstract request(params: RequestParams): HttpRequest;
        abstract upload(params: UploadParams): HttpRequest;
        abstract cancelAll(): void;
        static cancelAll(): void;
    }
    /**
     * @class Net.HttpRequest
     *
     * Http Request CANNOT be initialized. Use http's request methods instead.
     *
     *     @example
     *     const Http = require("@smartface/native/net/http");
     *
     *     var http = new Http();
     *     var myImageUrl = your-image-url;
     *     var request = HttpRequestImage({url: myImageUrl, onLoad: onLoad, onError: onError});
     *     request.cancel();
     *
     */
    export class HttpRequest extends NativeComponent {
        constructor(params: {
            nativeObject?: any;
        });
        suspend(): void;
        resume(): void;
        cancel(): void;
    }
}
declare module "net/http/index" {
    import { HttpBase } from "net/http/http";
    const Http: typeof HttpBase;
    type Http = HttpBase;
    export default Http;
}
declare module "device/network/index" {
    import NativeComponent from "core/native-component";
    /**
     * @enum {Number} Device.Network.ConnectionType
     * @since 0.1
     */
    export enum ConnectionType {
        /**
         * @deprecated Use {@link Device.Network.ConnectionType#NONE} instead
         * @property {Number} None
         * @readonly
         * @static
         * @since 0.1
         */
        None = 0,
        /**
         * @deprecated Use {@link Device.Network.ConnectionType#MOBILE} instead
         * @property {Number} Mobile
         * @readonly
         * @static
         * @since 0.1
         */
        Mobile = 1,
        /**
         *
         * @property {Number} WIFI
         * @readonly
         * @static
         * @since 0.1
         */
        WIFI = 2,
        /**
         *
         * @property {Number} NONE
         * @readonly
         * @static
         * @since 2.0.4
         */
        NONE = 0,
        /**
         *
         * @property {Number} MOBILE
         * @readonly
         * @static
         * @since 2.0.4
         */
        MOBILE = 1
    }
    export class NetworkNotifier extends NativeComponent {
        constructor(params?: {
            connectionTypeChanged: (type: ConnectionType) => void;
        });
        subscribe: (callback: (type: ConnectionType) => void) => void;
        android: Partial<{
            /** Returns true if the notifier is currently processing the initial value which is currently held in the sticky cache,
             * so this is not directly the result of a notifier right now.
             *
             * @method isInitialStickyNotification
             * @return {Boolean}
             * @android
             * @deprecated Use {@link Device.Network.createNotifier#initialCacheEnabled} instead
             * @since 4.0.8
             */
            isInitialStickyNotification(): boolean;
            /**
             * Assigning false to this property means that ignore the held value in the sticky cache. Thus, subscribed function won't fire at the initial time.
             *
             * @android
             * @property {Boolean} initialCacheEnabled
             * @since 4.0.8
             */
            initialCacheEnabled: boolean;
        }>;
        /**
         * This method stops receiving subcribed callback.
         *
         * @method unsubscribe
         * @ios
         * @android
         * @since 3.0.1
         */
        unsubscribe(): void;
        get connectionTypeChanged(): ((type: ConnectionType) => void) | null;
        set connectionTypeChanged(callback: ((type: ConnectionType) => void) | null);
    }
    /**
     * @class Device.Network
     * @since 0.1
     *
     * Device.Network provides several information about the network connections and adaptors on the device.
     *
     *     @example
     *     const Network = require('@smartface/native/device/network');
     *     console.log("Device.Network.IMSI: "                + Network.IMSI);
     *     console.log("Device.Network.SMSEnabled: "          + Network.SMSEnabled);
     *     console.log("Device.Network.bluetoothMacAddress: " + Network.bluetoothMacAddress);
     *     console.log("Device.Network.carrier: "             + Network.carrier);
     *     console.log("Device.Network.connectionType: "      + Network.connectionType);
     *     console.log("Device.Network.roamingEnabled: "      + Network.roamingEnabled);
     *     console.log("Device.Network.connectionIP: "        + Network.connectionIP);
     *     console.log("Device.Network.wirelessMacAddress: "  + Network.wirelessMacAddress);
     *
     *
     */
    export class NetworkBase extends NativeComponent {
        /**
         * @class Device.Network.Notifier
         * @since 3.0.1
         *
         * Provides an event to notify in case of connection is changed. In Android, notifier fires the subscribed event with cached value at the first launch. That enables to not miss any changes. Such as, changed
         * value could be missed when application is frozen. However it can be checked by {@link Device.Network.createNotifier#isInitialStickyNotification isInitialStickyNotification} .
         *
         *     @example
         *     const Network = require("@smartface/native/device/network");
         *     var notifier = new Network.Notifier();
         *
         *     notifier.subscribe(function(connectionType) {
         *      console.log("ConnectionType is " + connectionType);
         *     });
         *
         */
        readonly notifier: NetworkNotifier;
        /**
         *
         * Returns the carrier name of the GSM connection.
         * @property {String} carrier
         * @readonly
         * @static
         * @since 0.1
         */
        get carrier(): string;
        /**
         *
         * Returns the current connection type.
         * @property {Device.Network.ConnectionType} connectionType
         * @readonly
         * @static
         * @since 0.1
         */
        get connectionType(): ConnectionType;
        /**
         *
         * Returns the IP address of the current connection.
         * @property {String} connectionIP
         * @readonly
         * @static
         * @since 0.1
         */
        get connectionIP(): string;
        /**
         *
         * Returns if the device is capable of SMS operations.
         * @property {String} SMSEnabled
         * @readonly
         * @static
         * @since 0.1
         */
        get SMSEnabled(): boolean;
        /**
         *
         * Returns the 'International Mobile Subscriber Identity' of the device. If your app runs on Android 10 (API level 29) , the method returns null or placeholder data if the app has the READ_PHONE_STATE permission. Otherwise, a SecurityException occurs.
         * @property {String} IMSI
         * @readonly
         * @static
         * @since 0.1
         */
        get IMSI(): string;
        /**
         *
         * Returns the MAC address of the bluetooth adaptor on the device.
         * @property {String} bluetoothMacAddress
         * @readonly
         * @static
         * @since 0.1
         */
        get bluetoothMacAddress(): string;
        /**
         *
         * Returns the MAC address of the wireless adaptor on the device.
         * @property {String} wirelessMacAddress
         * @readonly
         * @static
         * @since 0.1
         */
        get wirelessMacAddress(): string;
        /**
         *
         * Returns whether roaming is enabled on the device
         * @property {Boolean} roamingEnabled
         * @readonly
         * @static
         * @since 0.1
         */
        roamingEnabled: boolean;
        cancelAll: () => void;
    }
    const Network: NetworkBase;
    type Network = NetworkBase;
    export default Network;
}
declare module "ui/sliderdrawer/sliderdrawer.android" {
    import { ISliderDrawer, SliderDrawerPosition, SliderDrawerState } from "ui/sliderdrawer/index";
    import { SliderDrawerEvents } from "ui/sliderdrawer/sliderdrawer-events";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import Color from "ui/color/index";
    export default class SliderDrawerAndroid<TEvent extends string = SliderDrawerEvents, TProps extends ISliderDrawer = ISliderDrawer> extends NativeEventEmitterComponent<TEvent | SliderDrawerEvents, any, ISliderDrawer> implements ISliderDrawer {
        private _layout;
        private _position;
        private _onShow;
        private _onHide;
        private _onLoad;
        __isAttached: boolean;
        private _enabled;
        private _state;
        private drawerLayoutParams;
        drawerListener: any;
        constructor(params?: Partial<ISliderDrawer>);
        backgroundColor: Color;
        show(): void;
        hide(): void;
        toString(): string;
        get state(): ISliderDrawer['state'];
        get drawerPosition(): ISliderDrawer['drawerPosition'];
        set drawerPosition(value: ISliderDrawer['drawerPosition']);
        get enabled(): ISliderDrawer['enabled'];
        set enabled(value: ISliderDrawer['enabled']);
        get layout(): ISliderDrawer['layout'];
        get onShow(): ISliderDrawer['onShow'];
        set onShow(value: ISliderDrawer['onShow']);
        get onLoad(): ISliderDrawer['onLoad'];
        set onLoad(value: ISliderDrawer['onLoad']);
        get onHide(): ISliderDrawer['onHide'];
        set onHide(value: ISliderDrawer['onHide']);
        get height(): ISliderDrawer['height'];
        set height(value: ISliderDrawer['height']);
        get width(): ISliderDrawer['width'];
        set width(value: ISliderDrawer['width']);
        private __hideSliderDrawer;
        private __showSliderDrawer;
        static State: typeof SliderDrawerState;
        static Position: typeof SliderDrawerPosition;
    }
}
declare module "application/application.android" {
    import { EventEmitter } from "core/eventemitter/index";
    import { ApplicationEvents } from "application/application-events";
    import SliderDrawerAndroid from "ui/sliderdrawer/sliderdrawer.android";
    import { StatusBar } from "application/statusbar/index";
    import { IBottomTabBar } from "ui/bottomtabbar/index";
    import { ApplicationBase } from "application/application";
    class ApplicationAndroid extends EventEmitter<ApplicationEvents> implements ApplicationBase {
        statusBar: StatusBar;
        private _sliderDrawer;
        private _keepScreenAwake;
        private _onExit;
        private _onMaximize;
        private _onMinimize;
        private _onReceivedNotification;
        private _onApplicationCallReceived;
        private _onAppShortcutReceived;
        private __isSetOnItemSelectedListener;
        currentPage: any;
        private _dispatchTouchEvent;
        private _onBackButtonPressed;
        private _onRequestPermissionsResult;
        private _keyboardMode;
        private _secureWindowContent;
        __mDrawerLayout: any;
        private activity;
        private spratAndroidActivityInstance;
        readonly LayoutDirection: {
            readonly LEFTTORIGHT: 0;
            readonly RIGHTTOLEFT: 1;
        };
        static Events: {
            readonly Exit: "exit";
            readonly Maximize: "maximize";
            readonly Minimize: "minimize";
            readonly ReceivedNotification: "receivedNotification";
            readonly UnhandledError: "unhandledError";
            readonly ApplicationCallReceived: "applicationCallReceived";
            readonly AppShortcutReceived: "appShortcutReceived";
            readonly BackButtonPressed: "backButtonPressed";
            readonly RequestPermissionResult: "requestPermissionResult";
        };
        constructor();
        setAppTheme: (theme: string) => void;
        Events: {
            readonly Exit: "exit";
            readonly Maximize: "maximize";
            readonly Minimize: "minimize";
            readonly ReceivedNotification: "receivedNotification";
            readonly UnhandledError: "unhandledError";
            readonly ApplicationCallReceived: "applicationCallReceived";
            readonly AppShortcutReceived: "appShortcutReceived";
            readonly BackButtonPressed: "backButtonPressed";
            readonly RequestPermissionResult: "requestPermissionResult";
        };
        tabBar?: IBottomTabBar;
        attachSliderDrawer(sliderDrawer: SliderDrawerAndroid): void;
        detachSliderDrawer(sliderDrawer: SliderDrawerAndroid): void;
        call(): void;
        canOpenUrl(url: string): boolean;
        exit(): void;
        restart(): void;
        hideKeyboard(): void;
        registOnItemSelectedListener(): void;
        setRootController(params: any): void;
        get drawerLayout(): any;
        set drawerLayout(value: any);
        get sliderDrawer(): any;
        set sliderDrawer(drawer: any);
        get keepScreenAwake(): boolean;
        set keepScreenAwake(value: boolean);
        get byteReceived(): number;
        get byteSent(): number;
        get currentReleaseChannel(): any;
        get smartfaceAppName(): any;
        get appName(): any;
        get version(): any;
        get onExit(): any;
        set onExit(onExit: any);
        get onMaximize(): any;
        set onMaximize(onMaximize: any);
        get onMinimize(): any;
        set onMinimize(onMinimize: any);
        get onReceivedNotification(): any;
        set onReceivedNotification(callback: any);
        get onUnhandledError(): any;
        set onUnhandledError(onUnhandledError: any);
        get onApplicationCallReceived(): any;
        set onApplicationCallReceived(callback: any);
        get onAppShortcutReceived(): any;
        set onAppShortcutReceived(callback: any);
        get isVoiceOverEnabled(): boolean;
        get android(): {
            Permissions: {
                readonly READ_CALENDAR: "android.permission.READ_CALENDAR";
                readonly WRITE_CALENDAR: "android.permission.WRITE_CALENDAR";
                readonly CAMERA: "android.permission.CAMERA";
                readonly READ_CONTACTS: "android.permission.READ_CONTACTS";
                readonly WRITE_CONTACTS: "android.permission.WRITE_CONTACTS";
                readonly GET_ACCOUNTS: "android.permission.GET_ACCOUNTS";
                readonly ACCESS_FINE_LOCATION: "android.permission.ACCESS_FINE_LOCATION";
                readonly ACCESS_COARSE_LOCATION: "android.permission.ACCESS_COARSE_LOCATION";
                readonly RECORD_AUDIO: "android.permission.RECORD_AUDIO";
                readonly READ_PHONE_STATE: "android.permission.READ_PHONE_STATE";
                readonly CALL_PHONE: "android.permission.CALL_PHONE";
                readonly READ_CALL_LOG: "android.permission.READ_CALL_LOG";
                readonly WRITE_CALL_LOG: "android.permission.WRITE_CALL_LOG";
                readonly ADD_VOICEMAIL: "com.android.voicemail.permission.ADD_VOICEMAIL";
                readonly USE_SIP: "android.permission.USE_SIP";
                readonly PROCESS_OUTGOING_CALLS: "android.permission.PROCESS_OUTGOING_CALLS";
                readonly BODY_SENSORS: "android.permission.BODY_SENSORS";
                readonly SEND_SMS: "android.permission.SEND_SMS";
                readonly RECEIVE_SMS: "android.permission.RECEIVE_SMS";
                readonly READ_SMS: "android.permission.READ_SMS";
                readonly RECEIVE_WAP_PUSH: "android.permission.RECEIVE_WAP_PUSH";
                readonly RECEIVE_MMS: "android.permission.RECEIVE_MMS";
                readonly READ_EXTERNAL_STORAGE: "android.permission.READ_EXTERNAL_STORAGE";
                readonly WRITE_EXTERNAL_STORAGE: "android.permission.WRITE_EXTERNAL_STORAGE";
                readonly USE_FINGERPRINT: "android.permission.USE_FINGERPRINT";
                readonly WRITE_APN_SETTINGS: "android.permission.WRITE_APN_SETTINGS";
            };
            packageName: any;
            dispatchTouchEvent: any;
            onBackButtonPressed: any;
            checkPermission(permission: any): boolean;
            requestPermissions(requestCode: any, permissions: any): void;
            shouldShowRequestPermissionRationale(permission: any): any;
            setAppTheme(currentTheme: any): void;
            onRequestPermissionsResult: any;
            readonly navigationBar: import("application/android/navigationbar/navigationbar").NavigationBarBase;
            keyboardMode: any;
            locale: any;
            readonly getLayoutDirection: any;
            secureWindowContent: boolean;
        };
        get Android(): {
            NavigationBar: import("application/android/navigationbar/navigationbar").NavigationBarBase;
            KeyboardMode: {
                readonly KeyboardAdjustNothing: 48;
                readonly KeyboardAdjustPan: 32;
                readonly KeyboardAdjustResize: 16;
                readonly KeyboardAdjustUnspecified: 0;
                readonly AlwaysVisible: 5;
                readonly AlwaysHidden: 3;
            };
            Permissions: {
                readonly READ_CALENDAR: "android.permission.READ_CALENDAR";
                readonly WRITE_CALENDAR: "android.permission.WRITE_CALENDAR";
                readonly CAMERA: "android.permission.CAMERA";
                readonly READ_CONTACTS: "android.permission.READ_CONTACTS";
                readonly WRITE_CONTACTS: "android.permission.WRITE_CONTACTS";
                readonly GET_ACCOUNTS: "android.permission.GET_ACCOUNTS";
                readonly ACCESS_FINE_LOCATION: "android.permission.ACCESS_FINE_LOCATION";
                readonly ACCESS_COARSE_LOCATION: "android.permission.ACCESS_COARSE_LOCATION";
                readonly RECORD_AUDIO: "android.permission.RECORD_AUDIO";
                readonly READ_PHONE_STATE: "android.permission.READ_PHONE_STATE";
                readonly CALL_PHONE: "android.permission.CALL_PHONE";
                readonly READ_CALL_LOG: "android.permission.READ_CALL_LOG";
                readonly WRITE_CALL_LOG: "android.permission.WRITE_CALL_LOG";
                readonly ADD_VOICEMAIL: "com.android.voicemail.permission.ADD_VOICEMAIL";
                readonly USE_SIP: "android.permission.USE_SIP";
                readonly PROCESS_OUTGOING_CALLS: "android.permission.PROCESS_OUTGOING_CALLS";
                readonly BODY_SENSORS: "android.permission.BODY_SENSORS";
                readonly SEND_SMS: "android.permission.SEND_SMS";
                readonly RECEIVE_SMS: "android.permission.RECEIVE_SMS";
                readonly READ_SMS: "android.permission.READ_SMS";
                readonly RECEIVE_WAP_PUSH: "android.permission.RECEIVE_WAP_PUSH";
                readonly RECEIVE_MMS: "android.permission.RECEIVE_MMS";
                readonly READ_EXTERNAL_STORAGE: "android.permission.READ_EXTERNAL_STORAGE";
                readonly WRITE_EXTERNAL_STORAGE: "android.permission.WRITE_EXTERNAL_STORAGE";
                readonly USE_FINGERPRINT: "android.permission.USE_FINGERPRINT";
                readonly WRITE_APN_SETTINGS: "android.permission.WRITE_APN_SETTINGS";
            };
        };
        get ios(): {
            onUserActivityWithBrowsingWeb: () => boolean;
        };
    }
    const Application: ApplicationAndroid;
    export default Application;
}
declare module "global/timer/timer" {
    import NativeComponent from 'core/native-component';
    /**
     * @class Timer
     * @since 0.1
     *
     * Timer allows you to create, start and clear timers.
     *
     *     @example
     *     const Button = require("@smartface/native/ui/button")
     *     const Timer = require("@smartface/native/timer");
     *     var myButton = new Button({
     *         onPress: setTimer
     *     });
     *
     *     function setTimer() {
     *         var myTimer = Timer.setTimeout({
     *             task: changeBackgroundColor,
     *             delay: 3000
     *         });
     *     }
     *
     *     const Color = require("@smartface/native/ui/color");
     *     function changeBackgroundColor() {
     *         myButton.backgroundColor = Color.RED;
     *     }
     *
     *
     */
    export class TimerBase extends NativeComponent {
        constructor(params?: Partial<{
            task: () => void;
            repeat: boolean;
            delay: number;
        }>);
        /**
         * @method setTimeout
         *
         * Calls a function after a spesified time elapses.
         *
         * @param {Object} params Parameters
         * @param {Function} params.task Function to be called
         * @param {Number} params.delay Time elapsed in millisecond
         * @return {Timer}
         * @static
         * @since 0.1
         */
        static setTimeout(params: {
            task: () => void;
            delay: number;
        }): Timer;
        /**
         * @method setInterval
         *
         * Calls a function repeatedly after a spesified time elapses.
         *
         * @param {Object} params Parameters
         * @param {Function} params.task Function to be called
         * @param {Number} params.delay Time elapsed in millisecond
         * @return {Timer}
         * @static
         * @since 0.1
         */
        static setInterval(params: {
            task: () => void;
            delay: number;
        }): Timer;
        /**
         * @method clearTimer
         *
         * Clears a spesified Timer instance.
         *
         * @param {Timer} timer
         * @static
         * @since 0.1
         */
        static clearTimer(timer: Timer): void;
        /**
         * @method clearAllTimer
         *
         * Clears all Timer instance.
         *
         * @static
         * @since 0.1
         */
        static clearAllTimer(): void;
    }
}
declare module "global/timer/index" {
    import { TimerBase } from "global/timer/timer";
    const Timer: typeof TimerBase;
    type Timer = TimerBase;
    export default Timer;
}
declare module "application/application.ios" {
    import { ApplicationEvents } from "application/application-events";
    import { StatusBar } from "application/statusbar/index";
    import { ApplicationBase } from "application/application";
    import Page from "ui/page/index";
    import NavigationController from "ui/navigationcontroller/index";
    import { IBottomTabBar } from "ui/bottomtabbar/index";
    import { EventEmitter } from "core/eventemitter/index";
    class ApplicationIOS extends EventEmitter<ApplicationEvents> implements ApplicationBase {
        private _onUnhandledError;
        private _onExit;
        private _onReceivedNotification;
        private _onApplicationCallReceived;
        private _onAppShortcutReceived;
        private _onMaximize;
        private _onMinimize;
        readonly emulator: {
            readonly globalObjectWillReset: (state: EmulatorResetState) => void;
        };
        constructor();
        setAppTheme: (theme: string) => void;
        Events: {
            readonly Exit: 'exit';
            readonly Maximize: 'maximize';
            readonly Minimize: 'minimize';
            readonly ReceivedNotification: 'receivedNotification';
            readonly UnhandledError: 'unhandledError';
            readonly ApplicationCallReceived: 'applicationCallReceived';
            readonly AppShortcutReceived: 'appShortcutReceived';
            readonly BackButtonPressed: 'backButtonPressed';
            readonly RequestPermissionResult: 'requestPermissionResult';
        };
        currentPage: Page;
        registOnItemSelectedListener(): void;
        tabBar?: IBottomTabBar;
        __mDrawerLayout: any;
        private _sliderDrawer;
        private _rootPage;
        private _onUserActivityWithBrowsingWeb;
        statusBar: StatusBar;
        readonly LayoutDirection: {
            readonly LEFTTORIGHT: 0;
            readonly RIGHTTOLEFT: 1;
        };
        canOpenUrl(url: any): any;
        exit(): void;
        restart(): void;
        setRootController(params: NavigationController): void;
        configureSliderDrawer(rootPage: any, sliderDrawer: any): void;
        call(uriScheme: {
            uriScheme: string;
            data?: {};
            onSuccess?: (value?: any) => void;
            onFailure?: (value?: any) => void;
        }, data?: {}, onSuccess?: (value?: any) => void, onFailure?: (value?: any) => void): void;
        hideKeyboard(): void;
        get byteReceived(): any;
        get byteSent(): any;
        get keepScreenAwake(): boolean;
        set keepScreenAwake(value: boolean);
        get sliderDrawer(): any;
        set sliderDrawer(value: any);
        get rootPage(): any;
        set rootPage(value: any);
        get onUnhandledError(): any;
        set onUnhandledError(value: any);
        set onExit(value: () => void);
        get onExit(): () => void;
        set onReceivedNotification(value: (e: any) => void);
        get onReceivedNotification(): (e: any) => void;
        set onUserActivityWithBrowsingWeb(value: any);
        get onApplicationCallReceived(): any;
        set onApplicationCallReceived(value: any);
        set onAppShortcutReceived(value: any);
        get onUserActivityWithBrowsingWeb(): any;
        set onMaximize(value: () => void);
        get onMaximize(): () => void;
        set onMinimize(value: () => void);
        get onMinimize(): () => void;
        get currentReleaseChannel(): any;
        get smartfaceAppName(): any;
        get appName(): any;
        get version(): any;
        get isVoiceOverEnabled(): boolean;
        get ios(): {
            readonly bundleIdentifier: string;
            readonly userInterfaceLayoutDirection: number;
        };
        get android(): {};
        get Android(): {};
    }
    enum EmulatorResetState {
        scan = 0,
        update = 1,
        clear = 2
    }
    const Application: ApplicationIOS;
    export default Application;
}
declare module "application/android/navigationbar/navigationbar.android" {
    import Color from "ui/color/index";
    import { NavigationBarBase, NavigationBarStyle } from "application/android/navigationbar/navigationbar";
    class NavigationBarAndroid implements NavigationBarBase {
        readonly Styles: typeof NavigationBarStyle;
        private _style;
        private _color;
        get style(): NavigationBarStyle;
        set style(value: NavigationBarStyle);
        get color(): Color;
        set color(value: Color);
    }
    const NavigationBar: NavigationBarAndroid;
    export default NavigationBar;
}
declare module "application/android/navigationbar/navigationbar.ios" {
    import { AbstractColor } from "ui/color/index";
    import { NavigationBarBase, NavigationBarStyle } from "application/android/navigationbar/navigationbar";
    export default class NavigationBarIOS implements NavigationBarBase {
        color: AbstractColor;
        style: NavigationBarStyle;
    }
}
declare module "application/statusbar/statusbar.android" {
    import { AbstractStatusBar } from "application/statusbar/index";
    import Color from "ui/color/index";
    export enum StatusBarStyle {
        DEFAULT = 0,
        LIGHTCONTENT = 1
    }
    class StatusBarAndroid implements AbstractStatusBar {
        private _visible;
        private _statusBarStyle;
        private _color;
        private _transparent;
        readonly Styles: typeof StatusBarStyle;
        get style(): StatusBarStyle;
        set style(value: StatusBarStyle);
        get visible(): boolean;
        set visible(value: boolean);
        get backgroundColor(): Color;
        set backgroundColor(color: Color);
        get height(): number;
        get ios(): {
            style: null;
        };
        get android(): AbstractStatusBar['android'];
    }
    const StatusBar: StatusBarAndroid;
    export default StatusBar;
}
declare module "application/statusbar/statusbar.ios" {
    import Color from "ui/color/index";
    export enum StatusBarStyle {
        DEFAULT = 0,
        LIGHTCONTENT = 1
    }
    class StatusBarIOS {
        readonly Styles: typeof StatusBarStyle;
        get ios(): {};
        get android(): {};
        get height(): number | undefined;
        get backgroundColor(): Color | undefined;
        set backgroundColor(value: Color | undefined);
        get visible(): boolean;
        set visible(value: boolean);
        get style(): StatusBarStyle;
        set style(value: StatusBarStyle);
    }
    const StatusBar: StatusBarIOS;
    export default StatusBar;
}
declare module "core/eventemitter/eventCallbacksAssign" {
    import { INativeComponent } from "core/inative-component";
    import { IEventEmitter } from "core/eventemitter/event-emitter";
    export function eventCallbacksAssign(targetInstance: INativeComponent & IEventEmitter, eventFunctions: {
        [key: string]: (...params: any[]) => void;
    }, emit?: boolean): void;
}
declare module "device/hardware/index" {
    /**
     * @class Device.Hardware
     * @since 0.1
     *
     * Hardware is used to retrieve hardware specific information of the device.
     *
     *     @example
     *     const Hardware = require('@smartface/native/device/hardware');
     *     console.log("Device.Hardware.IMEI: "       + Hardware.android.IMEI);
     *     console.log("Device.Hardware.UID: "        + Hardware.UID);
     *     console.log("Device.Hardware.brandName: "  + Hardware.brandName);
     *     console.log("Device.Hardware.brandModel: " + Hardware.brandModel);
     *     console.log("Device.Hardware.vendorID: "   + Hardware.android.vendorID);
     *
     */
    export class HardwareBase {
        /**
         *
         * Returns the unique id of the device. The value may change if the device is formatted.
         * @property {String} UID
         * @android
         * @ios
         * @readonly
         * @static
         * @since 0.1
         */
        static readonly UID: string;
        /**
         *
         * Returns 'International Mobile Equipment Identity' of the device. If your app runs on Android 10 (API level 29) , the method returns null or placeholder data if the app has the READ_PHONE_STATE permission. Otherwise, a SecurityException occurs.
         * @property {String} IMEI
         * @android
         * @readonly
         * @static
         * @since 0.1
         */
        static readonly IMEI?: string;
        static readonly android: {
            readonly IMEI?: string;
            /**
             *
             * Returns the vendor id of the device. If your app runs on Android 10 (API level 29) , the method returns null or placeholder data if the app has the READ_PHONE_STATE permission. Otherwise, a SecurityException occurs.
             * @property {Number} vendorID
             * @android
             * @readonly
             * @static
             * @since 0.1
             */
            readonly vendorID?: number;
        };
        static ios: {
            microphone?: {
                /**
                 *
                 * Checks to see if calling process has permission to record audio. The callback will be called
                 * immediately if permission has already been granted or denied.  Otherwise, it presents a dialog to notify
                 * the user and allow them to choose, and calls the block once the UI has been dismissed.  'true'
                 * indicates whether permission has been granted.
                 *
                 * @param {Function} callback for permission situation.
                 * @method requestRecordPermission
                 * @ios
                 * @readonly
                 * @static
                 * @since 1.1.12
                 */
                requestRecordPermission?: (callback: (...args: any[]) => void) => void;
            };
            modelName?: string;
        };
        /**
         *
         * Returns the model name of the device.
         * @property {String} brandModel
         * @android
         * @ios
         * @readonly
         * @static
         * @since 0.1
         */
        static readonly brandModel: string;
        /**
         *
         * Returns the brand name of the device.
         * @property {String} brandName
         * @android
         * @ios
         * @readonly
         * @static
         * @since 0.1
         */
        static readonly brandName: string;
        /**
         *
         * Returns the device model name.
         * @android
         * @ios
         * @readonly
         * @static
         * @since 0.1
         */
        static getDeviceModelName(): string;
    }
    const Hardware: typeof HardwareBase;
    type Hardware = HardwareBase;
    export default Hardware;
}
declare module "device/contacts/index" {
    import Page from "ui/page/index";
    import Blob from "global/blob/index";
    import NativeComponent from "core/native-component";
    export type ManagedContact = {
        nickname?: string;
        photo?: Blob | null;
        displayName?: string | undefined;
        phoneNumbers?: string[] | undefined;
        emailAddresses?: string[] | undefined;
        urlAddresses?: string[] | undefined;
        phoneNumber?: string[];
        address?: string;
        addresses?: string[] | undefined;
    };
    export class Contact extends NativeComponent {
        constructor(params?: Partial<Contact>);
        phoneNumbers?: string[];
        emailAddresses?: any;
        givenName?: string;
        familyName?: string;
        addresses?: any;
        urlAddresses?: any;
        firstName?: string;
        lastName?: string;
        middleName?: string;
        namePrefix?: string;
        nameSuffix?: string;
        title?: string;
        organization?: string;
        department?: string;
        nickname?: string;
        displayName?: string;
        photo?: Blob | null;
        postalAddresses: any;
    }
    /**
     * @class Device.Contacts
     * @since 0.1
     * This class allows user to add a contact to contact list or to select a contact from list.
     *
     *     @example
     *	   const Contacts = require("@smartface/native/device/contacts");
     *     const Application = require("@smartface/native/application");
     *
     *     const READ_CONTACTS_CODE = 1002;
     *     Application.android.requestPermissions(READ_CONTACTS_CODE, Application.Android.Permissions.READ_CONTACTS);
     *
     *     Application.android.onRequestPermissionsResult = function(e){
     *         if(e.requestCode === READ_CONTACTS_CODE && e.result) {
     *              Contacts.pickContact({
     *                  onSuccess: function(e) {
     *                  console.log(JSON.stringify(e));
     *              }
     *         }
     *     }
     *
     *
     */
    export class ContactsBase extends NativeComponent {
        static readonly Contact: typeof Contact;
        /**
         * This function adds a contact to contact list with specified properties. You need check
         * {@link Application.Android.Permissions#WRITE_CONTACTS} before adding contact.
         *
         *
         *     @example
         *     const Contacts = require("@smartface/native/device/contacts");
         *
         *     let myContact = new Contacts.Contact({
         *         firstName: 'Smartface',
         *         namePrefix: 'Mr.',
         *         lastName: 'Team',
         *         urlAddresses: ["https://smartface.io"],
         *         phoneNumbers: ["+16506173265"],
         *         emailAddresses: ["info@smartface.io"],
         *         addresses: ["3790 El Camino Real # 1022 Palo Alto CA, 94306,United States"]
         *      });
         *      Contacts.add({
         *          contact: myContact,
         *          onSuccess : function(){
         *              console.log("Success");
         *          },
         *          onFailure : function(){
         *              console.log("Failure");
         *          }
         *      });
         *
         *
         * @param {Object} params Object describing properties
         * @param {Contact} params.contact Object describing contact properties
         * @param {Function} params.onSuccess This event is called after adding contact successfully.
         * @param {Function} [params.onFailure] This event is called after adding contact fails.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message
         * @param {UI.Page} [params.page] The page parameter is optional. If this property is set,
         *                                the contacts will be editable before saving.
         * @method add
         * @android
         * @ios
         * @since 0.1
         */
        add(params: {
            contact: Contact;
            onSuccess?: () => void;
            onFailure?: () => void;
        }): void;
        /**
         * This function shows contact list. It allows user to pick a data from the list.You need check
         * {@link Application.android.Permissions#READ_CONTACTS} before picking contact.
         *
         *
         *     @example
         *     const Contacts = require("@smartface/native/device/contacts");
         *     Contacts.pick({
         *         page : myPage,
         *         onSuccess : function(contact){
         *             console.log("Successfully picked");
         *         },
         *         onFailure : function(e){
         *             console.log("Something went wrong");
         *         }
         *     });
         *
         * @param {Object} params Object describing callbacks
         * @param {UI.Page} params.page
         * @param {Function} params.onSuccess This event is called after getting contact successfully.
         * @param {Object} params.onSuccess.params
         * @param {Contact} params.onSuccess.params.contact
         * @param {Function} [params.onFailure] This event is called after getting contact fails.
         * @method pick
         * @android
         * @ios
         * @since 0.1
         */
        pickContact(page: Page, handlers: {
            onSuccess: (contact: Contact) => void;
            onFailure?: () => void;
        }): void;
        /**
         * This function returns a contact array.You need check
         * {@link Application.Android.Permissions#READ_CONTACTS} before using this function.
         *
         *
         *     @example
         *     const Contacts = require("@smartface/native/device/contacts");
         *     Contacts.fetchAll({
         *         onSuccess : function(contacts){
         *             var count = contacts.length;
         *         },
         *         onFailure : function(error){
         *             console.log("Message : " + error);
         *         }
         *     });
         *
         * @param {Object} params Object describing callbacks
         * @param {Function} params.onSuccess This event is called after getting contacts successfully.
         * @param {Array} params.onSuccess.params
         * @param {Contact} params.onSuccess.params.contact
         * @param {Function} [params.onFailure] This event is called after getting contacts fails.
         * @method getAll
         * @android
         * @ios
         * @since 0.1
         */
        fetchAll(handlers: {
            onSuccess: (contacts: Contact[]) => void;
            onFailure?: (error: string) => void;
        }): void;
        /**
         * This function searches contacts by given phone number.You need check
         * {@link Application.android.Permissions#READ_CONTACTS} permission.
         *
         *
         *     @example
         *     const Contacts = require("@smartface/native/device/contacts");
         *     Contacts.getContactsByPhoneNumber("5555555555",{
         *         onSuccess : function(contacts){
         *             console.log("Successfully found ", contacts);
         *         },
         *         onFailure : function(error){
         *             console.log("Something went wrong");
         *         }
         *     });
         *
         * @param {String} phoneNumber Phone number to search in contacts
         * @param {Object} callbacks Object describing callbacks
         * @param {Function} callbacks.onSuccess This event is called after getting contact successfully.
         * @param {Device.Contacts.Contact[]} callbacks.onSuccess.contact passes {@link Device.Contacts.Contact Contact} array.
         * @param {Function} [callbacks.onFailure] This event is called after getting contact fails.
         * @method getContactsByPhoneNumber
         * @android
         * @ios
         * @since 4.3.0
         */
        getContactsByPhoneNumber(phoneNumber: string, handlers: {
            onSuccess: (contacts: Contact[]) => void;
            onFailure?: (error: string) => void;
        }): void;
    }
    const Contacts: typeof ContactsBase;
    type Contacts = ContactsBase;
    export default Contacts;
}
declare module "device/sound/sound-events" {
    export const SoundEvents: {
        /**
         * Triggered when the sound is ready for playing.
         *
         * @since 0.1
         * @android
         * @ios
         * @event Ready
         */
        readonly Ready: "ready";
        /**
         *
         * Triggered when the sound complited playing.
         *
         * @event Finish
         * @android
         * @ios
         * @since 0.1
         */
        readonly Finish: "finish";
    };
    export type SoundEvents = ExtractValues<typeof SoundEvents>;
}
declare module "device/sound/index" {
    import Page from "ui/page/index";
    import File from "io/file/index";
    import { SoundEvents } from "device/sound/sound-events";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    /**
     * @class Device.Sound
     * @since 0.1
     * @android
     * @ios
     *
     * Controls sound files.
     *
     *     @example
     *     const Sound = require("@smartface/native/device/sound");
     *     var mySound = new Sound();
     *     mySound.onReady = function() {
     *         mySound.play();
     *     };
     *     mySound.isLooping = true;
     *     mySound.loadURL(your-url);
     *
     */
    export abstract class AbstractSound extends NativeEventEmitterComponent<SoundEvents> {
        constructor(params?: Partial<Sound>);
        static Events: typeof SoundEvents;
        /**
         * Checks whether the sound is playing.
         *
         * @property {Boolean} isPlaying
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        abstract get isPlaying(): boolean;
        /**
         * Gets/sets whether the sound is looping or non-looping.
         *
         * @property {Boolean} isLooping
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        abstract get isLooping(): boolean;
        /**
         * Gets/sets whether the sound is looping or non-looping.
         *
         * @property {Boolean} isLooping
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        abstract set isLooping(isLooping: boolean);
        /**
         * Gets/sets the volume of the sound. The range is between {0.0, 1.0}
         *
         * @property {Number} volume
         * @android
         * @ios
         * @since 0.1
         */
        abstract volume: number;
        /**
         * Gets the duration in milliseconds.
         *
         * @property {Number} totalDuration
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        abstract get totalDuration(): number;
        /**
         * Gets the current duration in milliseconds.
         *
         * @property {Number} currentDuration
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        abstract get currentDuration(): number;
        /**
         * Triggered when the sound is ready for playing.
         *
         * @since 0.1
         * @android
         * @ios
         * @deprecated
         * @event onReady
         * @example
         * ````
         * import Sound from '@smartface/native/device/sound';
         *
         * const sound1 = new Sound();
         * sound.on(Sound.Events.Ready, (params) => {
         *  console.info('onReady', params);
         * });
         * ````
         */
        abstract onReady: () => void;
        /**
         *
         * Triggered when the sound complited playing.
         *
         * @event onFinish
         * @android
         * @ios
         * @deprecated
         * @since 0.1
         * @example
         * ````
         * import Sound from '@smartface/native/device/sound';
         *
         * const sound1 = new Sound();
         * sound1.on(Sound.Events.Finish, (params) => {
         *  console.info('onFinish', params);
         * });
         * ````
         */
        abstract onFinish: () => void;
        /**
         * Pauses the sound.
         *
         * @method pause
         * @android
         * @ios
         * @since 0.1
         */
        abstract pause(): void;
        /**
         * Seeks to specified time position.
         *
         * @method seekTo
         * @param {Number} milliseconds
         * @android
         * @ios
         * @since 0.1
         */
        abstract seekTo(milliseconds: number): void;
        /**
         * Stops the sound.
         *
         * @method stop
         * @android
         * @ios
         * @since 0.1
         */
        abstract stop(): void;
        /**
         * plays the sound.
         *
         * @method play
         * @android
         * @ios
         * @since 0.1
         */
        abstract play(): void;
        /**
         * Loads the source. {@link Application.Android.Permissions#READ_EXTERNAL_STORAGE} permission is required to load local files.
         *
         * @method loadFile
         * @param {IO.File} file
         * @android
         * @ios
         * @since 0.1
         */
        abstract loadFile(file: File): void;
        /**
         * Loads the source.
         *
         * @method loadURL
         * @param {String} url
         * @android
         * @ios
         * @since 0.1
         */
        abstract loadURL(url: string): void;
        static android: {
            /**
             * Picks a sound on the device.
             *
             *     @example
             *     const Sound = require("@smartface/native/device/sound");
             *     Sound.android.pick({onSuccess: soundPicked});
             *
             *     function soundPicked(e) {
             *         if(!e.sound.isPlaying)
             *             e.sound.play();
             *     }
             *
             * @method pick
             * @param {Object} params Object describing function parameters.
             * @param {UI.Page} params.page (required since 1.1.8)
             * @param {Function} params.onSuccess Callback for success situation.
             * @param {Object} params.onSuccess.param
             * @param {Device.Sound} params.onSuccess.param.sound
             * @param {Function} [params.onFailure] Callback for failure situation.
             * @static
             * @android
             * @since 1.1.8
             */
            pick: (params: {
                page: Page;
                onSuccess: (e: {
                    sound: Sound;
                }) => void;
                onFailure: () => void;
            }) => void | undefined;
        };
    }
    class AbstractSoundImpl extends AbstractSound {
        get isPlaying(): boolean;
        get isLooping(): boolean;
        set isLooping(isLooping: boolean);
        volume: number;
        get totalDuration(): number;
        get currentDuration(): number;
        onReady: () => void;
        onFinish: () => void;
        pause(): void;
        seekTo(milliseconds: number): void;
        stop(): void;
        play(): void;
        loadFile(file: File): void;
        loadURL(url: string): void;
    }
    const Sound: typeof AbstractSoundImpl;
    type Sound = AbstractSoundImpl;
    export default Sound;
}
declare module "device/multimedia/index" {
    import Page from "ui/page/index";
    import Image from "ui/image/index";
    import File from "io/file/index";
    import Color from "ui/color/index";
    export enum ActionType {
        /**
         * @property {Number} IMAGE_CAPTURE
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        IMAGE_CAPTURE = 0,
        /**
         * @property {Number} VIDEO_CAPTURE
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        VIDEO_CAPTURE = 1
    }
    export enum Type {
        /**
         * @property {Number} IMAGE
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        IMAGE = 0,
        /**
         * @property {Number} VIDEO
         * @static
         * @readonly
         * @since 0.1
         * @android
         * @ios
         */
        VIDEO = 1
    }
    export enum CropShape {
        /**
         * Specifies that crop window shape is oval.
         *
         * @property {Number} OVAL
         * @static
         * @android
         * @ios
         * @readonly
         * @since 4.3.6
         */
        OVAL = 2,
        /**
         * Specifies that crop window shape is rectangle.
         *
         * @property {Number} RECTANGLE
         * @static
         * @android
         * @ios
         * @readonly
         * @since 4.3.6
         */
        RECTANGLE = 1
    }
    export enum CameraDevice {
        /**
         * Specifies the camera on the rear of the device.
         *
         * @property {Number} REAR
         * @static
         * @ios
         * @readonly
         * @since 4.3.0
         */
        REAR = 0,
        /**
         * Specifies the camera on the front of the device.
         *
         * @property {Number} FRONT
         * @static
         * @ios
         * @readonly
         * @since 4.3.0
         */
        FRONT = 1
    }
    export enum CameraAuthorizationStatus {
        /**
         * User has not yet made a choice with regards to this application.
         *
         * @property {Number} NotDetermined
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        NOTDETERMINED = 0,
        /**
         * This application is not authorized to access camera.
         * The user cannot change this applications status, possibly due to active restrictions such as parental controls being in place.
         *
         * @property {Number} Restricted
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        RESTRICTED = 1,
        /**
         * User has explicitly denied this application access to camera.
         *
         * @property {Number} Denied
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        DENIED = 2,
        /**
         * User has authorized this application to access camera.
         *
         * @property {Number} Authorized
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        AUTHORIZED = 3
    }
    export enum CameraFlashMode {
        /**
         * Specifies that flash illumination is always off, no matter what the ambient light conditions are.
         *
         * @property {Number} OFF
         * @static
         * @ios
         * @readonly
         * @since 3.1.1
         */
        OFF = 0,
        /**
         * Specifies that the device should consider ambient light conditions to automatically determine whether or not to use flash illumination.
         *
         * @property {Number} AUTO
         * @static
         * @ios
         * @readonly
         * @since 3.1.1
         */
        AUTO = 1,
        /**
         * Specifies that flash illumination is always on, no matter what the ambient light conditions are.
         *
         * @property {Number} ON
         * @static
         * @ios
         * @readonly
         * @since 3.1.1
         */
        ON = 2
    }
    export enum GalleryAuthorizationStatus {
        /**
         * User has not yet made a choice with regards to this application.
         *
         * @property {Number} NotDetermined
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        NOTDETERMINED = 0,
        /**
         * This application is not authorized to access photo data.
         * The user cannot change this applications status, possibly due to active restrictions such as parental controls being in place.
         *
         * @property {Number} Restricted
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        RESTRICTED = 1,
        /**
         * User has explicitly denied this application access to photos data.
         *
         * @property {Number} Denied
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        DENIED = 2,
        /**
         * User has authorized this application to access photos data.
         *
         * @property {Number} Authorized
         * @static
         * @ios
         * @readonly
         * @since 2.0.11
         */
        AUTHORIZED = 3
    }
    export type ConvertToMp4Params = {
        videoFile: File;
        outputFileName: string;
        onCompleted: (params: {
            video: File;
        }) => void;
        onFailure?: () => void;
    };
    export type PickMultipleFromGalleryParams = {
        type?: Type;
        page: Page;
        android?: {
            fixOrientation?: boolean;
            maxImageSize?: number;
        };
        onSuccess: (params: {
            assets: [{
                image?: Image;
                file?: File | null;
            }];
        }) => void;
        onCancel?: () => void;
        onFailure?: (e: [{
            message: string;
            fileName: string | null;
            uri: string;
        }]) => void;
    };
    export type LaunchCropperParams = {
        page: Page;
        asset: File | Image;
        aspectRatio?: {
            x: number;
            y: number;
        };
        cropShape?: CropShape;
        headerBarTitle?: string;
        enableFreeStyleCrop?: boolean;
        android?: {
            rotateText?: string;
            scaleText?: string;
            cropText?: string;
            hideBottomControls?: boolean;
            maxResultSize?: {
                height: number;
                width: number;
            };
            fixOrientation?: boolean;
            maxImageSize?: number;
        };
        ios?: {
            aspectRatioPickerButtonHidden: boolean;
            resetButtonHidden?: boolean;
            resetAspectRatioEnabled?: boolean;
            aspectRatioLockDimensionSwapEnabled?: boolean;
            rotateButtonsHidden?: boolean;
            showOnlyIcons?: boolean;
            doneButtonTitle?: string;
            cancelButtonTitle?: string;
            doneButtonColor?: Color;
            cancelButtonColor?: Color;
        };
        onSuccess: (params: {
            image?: Image;
        }) => void;
        onCancel?: () => void;
        onFailure?: (e: {
            message: string;
        }) => void;
    };
    export type RecordVideoParams = {
        page: Page;
        maximumDuration?: Number;
        videoQuality?: Number;
        ios?: {
            cameraFlashMode?: CameraFlashMode;
            cameraDevice?: CameraDevice;
        };
        onSuccess?: (params: {
            video: File;
        }) => void;
        onCancel?: () => void;
        onFailure?: (e: {
            message: string;
        }) => void;
    };
    export type MultimediaParams = {
        type?: Type;
        page: Page;
        action?: ActionType;
        allowsEditing?: boolean;
        aspectRatio?: {
            x: number;
            y: number;
        };
        ios?: {
            cameraFlashMode?: CameraFlashMode;
            cameraDevice?: CameraDevice;
        };
        android?: {
            cropShape?: CropShape;
            rotateText?: string;
            scaleText?: string;
            cropText?: string;
            headerBarTitle?: string;
            hideBottomControls?: boolean;
            enableFreeStyleCrop?: boolean;
            maxResultSize?: {
                height: number;
                width: number;
            };
            fixOrientation?: boolean;
            maxImageSize?: number;
        };
        onSuccess: (params: {
            image?: Image;
            video?: File;
        }) => void;
        onCancel?: () => void;
        onFailure?: (e: {
            message: string;
        }) => void;
    };
    export class MultimediaBase {
        /**
         * @enum {Number} Device.Multimedia.ActionType
         * @since 0.1
         * @android
         * @ios
         *
         * ActionType is used to indicate type of the camera action.
         */
        static readonly ActionType: ActionType;
        /**
         * @enum {Number} Device.Multimedia.Type
         * @since 0.1
         * @android
         * @ios
         *
         * Type is used to indicate type of the media.
         */
        static readonly Type: Type;
        /**
         * These enums used to specify shape of crop window.
         *
         * @enum {Number} Device.Multimedia.CropShape
         * @since 4.3.6
         * @android
         * @ios
         */
        static readonly CropShape: CropShape;
        /**
         * @enum {Number} Device.Multimedia.CameraDevice
         * @since 4.3.0
         * @ios
         */
        static readonly CameraDevice: CameraDevice;
        /**
         * These enums used to specify quality of video
         *
         * @property {Object} VideoQuality
         * @since 4.3.0
         * @android
         * @ios
         *
         */
        static readonly VideoQuality: {
            /**
             * Specifies that quality of video is low.
             *
             * @property {Number} LOW
             * @static
             * @ios
             * @android
             * @readonly
             * @since 4.3.0
             */
            LOW: 0;
            /**
             * Specifies that quality of video is high.
             *
             * @property {Number} HIGH
             * @static
             * @ios
             * @android
             * @readonly
             * @since 4.3.0
             */
            HIGH: 1;
            /**
             * Specifies ios specific quality of video.
             *
             * @property {Object} iOS
             * @static
             * @ios
             * @readonly
             * @since 4.3.0
             */
            iOS: {
                /**
                 * If recording, specifies that you want to use medium-quality video recording.
                 *
                 * @property {Number} MEDIUM
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.3.0
                 */
                MEDIUM: 100;
                /**
                 * If recording, specifies that you want to use VGA-quality video recording (pixel dimensions of 640x480).
                 *
                 * @property {Number} TYPE640x480
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.3.0
                 */
                TYPE640x480: 101;
                /**
                 * If recording, specifies that you want to use 1280x720 iFrame format.
                 *
                 * @property {Number} TYPEIFRAME1280x720
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.3.0
                 */
                TYPEIFRAME1280x720: 102;
                /**
                 * If recording, specifies that you want to use 960x540 iFrame format.
                 *
                 * @property {Number} TYPEIFRAME960x540
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.3.0
                 */
                TYPEIFRAME960x540: 102;
            };
        };
        /**
         * @method startCamera
         *
         * Calls the camera intent.
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {Device.Multimedia.ActionType} params.action Camera action.
         * @param {Boolean} params.allowsEditing opens editing screen of selected content.
         * @param {Object} params.aspectRatio This property affects only on android.
         * @param {Number} params.aspectRatio.x The X value of aspect ratio of cropping window
         * @param {Number} params.aspectRatio.y The Y value of aspect ratio of cropping window
         * @param {Device.Multimedia.iOS.CameraFlashMode} params.cameraFlashMode The flash mode used by the active camera.The default value is Multimedia.iOS.CameraFlashMode.AUTO.
         * @param {Object} params.android Android specific argument
         * @param {Device.Multimedia.CropShape} params.android.cropShape specifies the crop window shape
         * @param {String} params.android.rotateText specifies the text of rotate button in the crop window
         * @param {String} params.android.scaleText specifies the text of scale button in the crop window
         * @param {String} params.android.cropText specifies the text of crop button in the crop window
         * @param {String} params.android.headerBarTitle specifies the title of header bar in the crop window
         * @param {Boolean} params.android.hideBottomControls set to true to hide the bottom controls  in the crop window (shown by default)
         * @param {Boolean} params.android.enableFreeStyleCrop set to true to let user resize crop bounds (disabled by default)
         * @param {Object} params.android.maxResultSize set maximum size for result cropped image.
         * @param {Number} params.android.maxResultSize.height max cropped image height
         * @param {Number} params.android.maxResultSize.width max cropped image width
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {UI.Image} params.onSuccess.params.image Captured image
         * @param {IO.File} params.onSuccess.params.video Captured video
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @android
         * @ios
         * @since 0.1
         * @deprecated 4.3.0 use {@link Device.Multimedia#capturePhoto capturePhoto} OR {@link Device.Multimedia#recordVideo recordVideo}
         */
        static startCamera(params: MultimediaParams): void;
        /**
         * @method capturePhoto
         *
         * Calls the camera intent for photo.
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {Boolean} params.allowsEditing opens editing screen of selected content.
         * @param {Object} params.aspectRatio This property affects only on android.
         * @param {Number} params.aspectRatio.x The X value of aspect ratio of cropping window
         * @param {Number} params.aspectRatio.y The Y value of aspect ratio of cropping window
         * @param {Object} params.ios iOS specific argument
         * @param {Device.Multimedia.iOS.CameraFlashMode} params.ios.cameraFlashMode The flash mode used by the active camera.The default value is Multimedia.iOS.CameraFlashMode.AUTO.
         * @param {Device.Multimedia.iOS.CameraDevice} params.ios.cameraDevice Constants that specify the camera to use for image or movie capture.The default value is Multimedia.iOS.CameraDevice.REAR.
         * @param {Object} params.android Android specific argument
         * @param {Device.Multimedia.CropShape} params.android.cropShape specifies the crop window shape
         * @param {String} params.android.rotateText specifies the text of rotate button in the crop window
         * @param {String} params.android.scaleText specifies the text of scale button in the crop window
         * @param {String} params.android.cropText specifies the text of crop button in the crop window
         * @param {String} params.android.headerBarTitle specifies the title of header bar in the crop window
         * @param {Boolean} params.android.hideBottomControls set to true to hide the bottom controls  in the crop window (shown by default)
         * @param {Boolean} params.android.enableFreeStyleCrop set to true to let user resize crop bounds (disabled by default)
         * @param {Object} params.android.maxResultSize set maximum size for result cropped image.
         * @param {Number} params.android.maxResultSize.height max cropped image height
         * @param {Number} params.android.maxResultSize.width max cropped image width
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {UI.Image} params.onSuccess.params.image Captured image
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @android
         * @ios
         * @since 4.3.0
         */
        static capturePhoto(params: MultimediaParams): void;
        /**
         * @method recordVideo
         *
         * Calls the camera intent for video. In Android, read/write external storage permission should be obtained before using recorded video.
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {Number} params.maximumDuration maximum allowed record duration in seconds
         * @param {Device.Multimedia.VideoQuality} params.videoQuality used to control the quality of a recorded video
         * @param {Object} params.ios iOS specific argument
         * @param {Device.Multimedia.iOS.CameraFlashMode} params.ios.cameraFlashMode The flash mode used by the active camera.The default value is Multimedia.iOS.CameraFlashMode.AUTO.
         * @param {Device.Multimedia.iOS.CameraDevice} params.ios.cameraDevice Constants that specify the camera to use for image or movie capture.The default value is Multimedia.iOS.CameraDevice.REAR.
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {IO.File} params.onSuccess.params.video Captured video
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @android
         * @ios
         * @since 4.3.0
         */
        static recordVideo(params: RecordVideoParams): void;
        /**
         * @method pickFromGallery
         *
         * Allows pick item from gallery.
         *
         *     @example
         *     const Image = require("@smartface/native/ui/image");
         *     const Multimedia = require("@smartface/native/device/multimedia");
         *     const Page = require("@smartface/native/ui/page");
         *     const extend = require("js-base/core/extend");
         *     const Button = require('@smartface/native/ui/button');
         *
         *     var Page1 = extend(Page)(
         *        function(_super) {
         *            _super(this, {
         *                onShow: function(params) {
         *                },
         *                onLoad: function(){
         *                    var self = this;
         *                    var button = new Button();
         *                    button.flexGrow = 1;
         *                    button.text = "Button"
         *
         *                    button.onPress = function(){
         *                        Multimedia.pickFromGallery({
         *                            type: Multimedia.Type.IMAGE,
         *                            onSuccess: onSuccess,
         *                            page : self
         *                         });
         *
         *                        function onSuccess(picked) {
         *                            var image = picked.image;
         *                        }
         *                    }
         *                    this.layout.addChild(button);
         *                }
         *            });
         *        }
         *     );
         *
         *     module.exports = Page1;
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {Device.Multimedia.Type} params.type Data type.
         * @param {Boolean} params.allowsEditing opens editing screen of selected content.
         * @param {Object} params.aspectRatio This property affects only on android.
         * @param {Number} params.aspectRatio.x The X value of aspect ratio of cropping window
         * @param {Number} params.aspectRatio.y The Y value of aspect ratio of cropping window
         * @param {Object} params.android Android specific argument
         * @param {Device.Multimedia.CropShape} params.android.cropShape specifies the crop window shape
         * @param {String} params.android.rotateText specifies the text of rotate button in the crop window
         * @param {String} params.android.scaleText specifies the text of scale button in the crop window
         * @param {String} params.android.cropText specifies the text of crop button in the crop window
         * @param {String} params.android.headerBarTitle specifies the title of header bar in the crop window
         * @param {Boolean} params.android.hideBottomControls set to true to hide the bottom controls  in the crop window (shown by default)
         * @param {Boolean} params.android.enableFreeStyleCrop set to true to let user resize crop bounds (disabled by default)
         * @param {Object} params.android.maxResultSize set maximum size for result cropped image.
         * @param {Number} params.android.maxResultSize.height max cropped image height
         * @param {Number} params.android.maxResultSize.width max cropped image width
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {UI.Image} params.onSuccess.params.image Captured image
         * @param {IO.File} params.onSuccess.params.video Captured video
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @android
         * @ios
         * @since 0.1
         */
        static pickFromGallery(params: MultimediaParams): void;
        /**
         * @method pickMultipleFromGallery
         *
         * Allows multiple pick item from gallery.
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {Device.Multimedia.Type} [params.type=Device.Multimedia.Type.IMAGE] Data type.
         * @param {Object} params.android Android specific argument
         * @param {Boolean} params.android.fixOrientation fixes incorrect image orientation. The fixing takes time if image resolution is high. So it's strictly recommended to use with maxImageSize in order to reduce performance issues.
         * @param {Number} params.android.maxImageSize specifies the max size for both width and height of image
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {Object[]} params.onSuccess.params.assets
         * @param {IO.File} params.onSuccess.params.assets.file Selected image or video file depends on the given type. In iOS, if the given type is image then it returns undefined.
         * @param {UI.Image} params.onSuccess.params.assets.image Selected images
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object[]} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @param {String|null} params.onFailure.params.fileName File name of the selected file or null if the selected file has unkown issue or pointed to a remote resource.
         * @param {String} params.onFailure.params.uri Uri of the selected file
         * @android
         * @ios
         * @since 4.3.6
         */
        static pickMultipleFromGallery(params: PickMultipleFromGalleryParams): void;
        /**
         * @method launchCropper
         *
         * Launches cropper.
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {UI.Page} params.page
         * @param {IO.File|UI.Image} params.asset Image or image file which suppose to cropped. Note that providing Image caueses to launch the Cropper with the delay which depends on size of the Image in Android.
         * Thus, providing File is always a better option. At least to decrease the delay, provide smaller images.
         * @param {Device.Multimedia.CropShape} [params.cropShape=Device.Multimedia.CropShape.RECTANGLE] specifies the crop window shape
         * @param {Boolean} [params.enableFreeStyleCrop=false] set to true to let user resize crop bounds (disabled by default)
         * @param {String} params.headerBarTitle specifies the title of header bar in the crop window
         * @param {Object} params.aspectRatio This property affects only on android.
         * @param {Number} params.aspectRatio.x The X value of aspect ratio of cropping window
         * @param {Number} params.aspectRatio.y The Y value of aspect ratio of cropping window
         * @param {Object} params.android Android specific argument
         * @param {String} params.android.rotateText specifies the text of rotate button in the crop window
         * @param {String} params.android.scaleText specifies the text of scale button in the crop window
         * @param {String} params.android.cropText specifies the text of crop button in the crop window
         * @param {Boolean} params.android.hideBottomControls set to true to hide the bottom controls  in the crop window (shown by default)
         * @param {Boolean} params.android.fixOrientation fixes incorrect image orientation. The fixing takes time if image resolution is high. So it's strictly recommended to use with maxImageSize in order to reduce performance issues.
         * @param {Number} params.android.maxImageSize specifies the max size for both width and height of image
         * @param {Object} params.android.maxResultSize set maximum size for result cropped image.
         * @param {Number} params.android.maxResultSize.height max cropped image height
         * @param {Number} params.android.maxResultSize.width max cropped image width
         * @param {Object} params.ios iOS specific argument
         * @param {Boolean} [params.ios.aspectRatioPickerButtonHidden=true] When enabled, hides the 'Aspect Ratio Picker' button on the toolbar.
         * @param {Boolean} [params.ios.resetButtonHidden=false] When enabled, hides the 'Reset' button on the toolbar.
         * @param {Boolean} [params.ios.resetAspectRatioEnabled=false] If true, tapping the reset button will also reset the aspect ratio back to the image
         * default ratio. Otherwise, the reset will just zoom out to the current aspect ratio.
         * @param {Boolean} [params.ios.aspectRatioLockDimensionSwapEnabled=true] If true, a custom aspect ratio is set, and the aspectRatioLockEnabled is set to YES, the crop box
         * will swap it's dimensions depending on portrait or landscape sized images. This value also controls whether the dimensions can swap when the image is rotated.
         * @param {Boolean} [params.ios.rotateButtonsHidden=false] When enabled, hides the rotation button.
         * @param {Boolean} [params.ios.showOnlyIcons=false] If true, button icons are visible in portairt instead button text.
         * @param {String}  params.ios.doneButtonTitle Title for the 'Done' button. Setting this will override the Default which is a localized string for "Done".
         * @param {String}  params.ios.cancelButtonTitle Title for the 'Cancel' button. Setting this will override the Default which is a localized string for "Cancel".
         * @param {UI.Color}  params.ios.doneButtonColor
         * @param {UI.Color}  params.ios.cancelButtonColor
         * @param {Function} params.onSuccess Callback for success situation.
         * @param {Object} params.onSuccess.params
         * @param {UI.Image} params.onSuccess.params.image Cropped image
         * @param {Function} [params.onCancel] Callback for cancellation situation.
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @param {Object} params.onFailure.params
         * @param {String} params.onFailure.params.message Failure message
         * @android
         * @ios
         * @since 4.3.6
         */
        static launchCropper(params: LaunchCropperParams): void;
        /**
         * @method convertToMp4
         *
         * Converts video file to mp4 format.
         *
         *     @example
         *     Multimedia.convertToMp4({
         *        videoFile: video,
         *        outputFileName: "myMp4Video",
         *        onCompleted: ({video}) => {
         *             console.log(" Multimedia onCompleted ")
         *        },
         *        onFailure: () => {
         *            console.log(" Multimedia onFailure ")
         *         }
         *      });
         *
         * @param {Object} params Object describing parameters for the function.
         * @param {IO.File} params.videoFile Input Video file to convert
         * @param {string} params.outputFileName Converted video file name
         * @param {Function} params.onCompleted Callback for success situation.
         * @param {Object} params.onCompleted.params
         * @param {IO.File} params.onCompleted.params.video Converted video file
         * @param {Function} [params.onFailure] Callback for failure situation.
         * @android
         * @ios
         * @since 4.2.2
         */
        static convertToMp4(params: ConvertToMp4Params): void;
        /**
         * Indicates whether the device has camera feature.
         *
         * @property hasCameraFeature
         * @readonly
         * @android
         * @ios
         * @static
         * @return {Boolean}
         * @since 4.3.6
         */
        static hasCameraFeature: Boolean;
        static ios: Partial<{
            /**
             * @method requestGalleryAuthorization
             *
             * @param {Function} callback
             * @param {Boolean} callback.status
             * @ios
             * @since 2.0.10
             */
            requestGalleryAuthorization(callback: (status: boolean) => void): void;
            /**
             * @method requestCameraAuthorization
             *
             * @param {Function} callback
             * @param {Boolean} callback.status
             * @ios
             * @since 2.0.10
             */
            requestCameraAuthorization(callback: (status: boolean) => void): void;
            /**
             * @method getGalleryAuthorizationStatus
             *
             * @return {Device.Multimedia.iOS.GalleryAuthorizationStatus} status
             * @ios
             * @since 2.0.11
             */
            getGalleryAuthorizationStatus(): GalleryAuthorizationStatus;
            /**
             * @method getCameraAuthorizationStatus
             *
             * @return {Device.Multimedia.iOS.CameraAuthorizationStatus} status
             * @ios
             * @since 2.0.11
             */
            getCameraAuthorizationStatus(): CameraAuthorizationStatus;
        }>;
    }
    const Multimedia: typeof MultimediaBase;
    type Multimedia = MultimediaBase;
    export default Multimedia;
}
declare module "device/index" {
    export { default as Screen } from "device/screen/index";
    export { default as System } from "device/system/index";
    export { default as Network } from "device/network/index";
    export { default as Hardware } from "device/hardware/index";
    export { default as Location } from "device/location/index";
    export { default as Contacts } from "device/contacts/index";
    export { default as Sound } from "device/sound/index";
    export { default as Multimedia } from "device/multimedia/index";
}
declare module "device/accelerometer/accelerometer.android" {
    import { IAccelerometer } from "device/accelerometer/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { AccelerometerEvents } from "device/accelerometer/accelerometer-events";
    class AccelerometerAndroid extends NativeEventEmitterComponent<AccelerometerEvents> implements IAccelerometer {
        private _nativeSFAccelerometerListener;
        private _isSetCallback;
        private _isStarted;
        constructor();
        onAccelerate: (e: {
            x: number;
            y: number;
            z: number;
        }) => void;
        start(): void;
        stop(): void;
    }
    const Accelerometer: AccelerometerAndroid;
    export default Accelerometer;
}
declare module "device/accelerometer/accelerometer.ios" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { IAccelerometer } from "device/accelerometer/index";
    import { AccelerometerEvents } from "device/accelerometer/accelerometer-events";
    class AccelerometerIOS extends NativeEventEmitterComponent<AccelerometerEvents, any, IAccelerometer> implements IAccelerometer {
        private monitonManager;
        constructor(params?: Partial<IAccelerometer>);
        onAccelerate: (e: {
            x: number;
            y: number;
            z: number;
        }) => void;
        start(): void;
        stop(): void;
    }
    const Accelerometer: AccelerometerIOS;
    export default Accelerometer;
}
declare module "device/calldetection/calldetection-events" {
    export const CallDetectionEvents: {
        /**
         * Triggers when device call state changes.
         *
         * @since 4.3.1
         * @event CallStateChanged
         * @param {Object} params
         * @param {Device.CallDetection.State} state
         * @param {String} incomingNumber Android only parameter
         * @android
         * @ios
         */
        readonly CallStateChanged: "callStateChanged";
    };
    export type CallDetectionEvents = ExtractValues<typeof CallDetectionEvents>;
}
declare module "device/calldetection/index" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { CallDetectionEvents } from "device/calldetection/calldetection-events";
    export enum State {
        /**
         *
         * @property {String} DISCONNECTED
         * @static
         * @ios
         * @android
         * @readonly
         * @since 4.1.3
         */
        DISCONNECTED = "Disconnected",
        /**
         * Android-only
         *
         * @property {String} MISSED
         * @static
         * @android
         * @readonly
         * @since 4.1.3
         */
        MISSED = "Missed",
        /**
         * Android-only
         *
         * @property {String} OFFHOOK
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        OFFHOOK = "Offhook",
        /**
         *
         * @property {String} INCOMING
         * @static
         * @ios
         * @android
         * @readonly
         * @since 4.1.3
         */
        INCOMING = "Incoming",
        /**
         * iOS-only state
         *
         * @property {String} INCOMING
         * @static
         * @ios
         * @readonly
         * @since 4.1.3
         */
        DIALING = "Dialing",
        /**
         * iOS-only state
         *
         * @property {String} CONNECTED
         * @static
         * @ios
         * @readonly
         * @since 4.1.3
         */
        CONNECTED = "Connected"
    }
    /**
     * @class Device.CallDetection
     * @since 4.3.1
     *
     * Helps to detect call states.
     * Required {@link Application.Android.Permissions-static-property-READ_PHONE_STATE READ_PHONE_STATE} permission for Android.
     *
     *     @example
     *     const CallDetection = require("@smartface/native/device/calldetection");
     *
     *     const callDetection = new CallDetection();
     *     callDetection.onCallStateChanged = (params) => {
     *         console.log(params);
     *     };
     *
     */
    export class ICallDetection extends NativeEventEmitterComponent<CallDetectionEvents> {
        /**
         * Triggers when device call state changes.
         *
         * @since 4.3.1
         * @event onCallStateChanged
         * @param {Object} params
         * @param {Device.CallDetection.State} state
         * @param {String} incomingNumber Android only parameter
         * @android
         * @ios
         * @deprecated
         * @example
         * ````
         * import CallDetection from '@smartface/native/device/calldetection';
         *
         * const callDetection1 = new CallDetection();
         * callDetection1.on(CallDetection.Events.CallStateChanged, (params) => {
         *  console.info('onCallStateChanged', params);
         * });
         * ````
         */
        onCallStateChanged: (e: {
            state: State;
            incomingNumber?: string;
            observer?: any;
        }) => void;
    }
    const CallDetection: ICallDetection;
    type CallDetection = ICallDetection;
    export default CallDetection;
}
declare module "device/calldetection/calldetection.android" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { ICallDetection, State } from "device/calldetection/index";
    import { CallDetectionEvents } from "device/calldetection/calldetection-events";
    class CallDetectionAndroid extends NativeEventEmitterComponent<CallDetectionEvents> implements ICallDetection {
        onCallStateChanged: (params: {
            state: State;
            incomingNumber?: string;
            observer?: any;
        }) => void;
        constructor();
    }
    const CallDetection: CallDetectionAndroid;
    export default CallDetection;
}
declare module "device/calldetection/calldetection.ios" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { ICallDetection, State } from "device/calldetection/index";
    import { CallDetectionEvents } from "device/calldetection/calldetection-events";
    class CallDetectionIOS extends NativeEventEmitterComponent<CallDetectionEvents> implements ICallDetection {
        onCallStateChanged: (params: {
            state: State;
            incomingNumber?: string;
            observer?: any;
        }) => void;
        private callObserverDelegate;
        constructor();
    }
    const CallDetection: CallDetectionIOS;
    export default CallDetection;
}
declare module "device/contacts/contacts.android" {
    import Page from "ui/page/index";
    import { RequestCodes } from "util/index";
    import { Contact, ContactsBase } from "device/contacts/index";
    export class ContactAndroid extends Contact {
        constructor(params?: Partial<Contact>);
    }
    class ContactsAndroid extends ContactsBase {
        private contentProviderOperation;
        private _onSuccess;
        private _onFailure;
        static readonly Contact: typeof ContactAndroid;
        constructor();
        add(params: {
            contact: ContactAndroid;
            onSuccess?: () => void;
            onFailure?: (error: any) => void;
        }): void;
        pick(params: {
            page: Page;
            onSuccess: (contacts: any[]) => void;
            onFailure: (error: any) => void;
        }): void;
        onActivityResult(requestCode: RequestCodes.Contacts, resultCode: any, data: any): void;
        getAll(params: {
            onSuccess: (contacts: any[]) => void;
            onFailure: (error: any) => void;
        }): void;
        fetchAll(params: {
            onSuccess: (contacts: any[]) => void;
            onFailure: (error: any) => void;
        }): void;
        pickContact(page: Page, params: {
            onSuccess?: (contact: any) => void;
            onFailure?: (error: any) => void;
        }): void;
        getContactsByPhoneNumber(phoneNumber: string | undefined, callbacks: {
            onSuccess: (contacts: any[]) => void;
            onFailure: (error: any) => void;
        }): void;
    }
    const _default: ContactsAndroid;
    export default _default;
}
declare module "device/contacts/contacts.ios" {
    import Page from "ui/page/index";
    import { ContactsBase, Contact, ManagedContact } from "device/contacts/index";
    export class ContactIOS extends Contact {
        constructor(params?: Partial<ContactIOS>);
    }
    class ContactsIOS extends ContactsBase {
        static ios: {
            __pickerDelegate: __SF_CNContactPickerDelegate<ContactNative>;
        };
        static android: {};
        static readonly Contact: typeof ContactIOS;
        constructor(params?: Partial<ContactsBase>);
        pickContact(page: Page, handlers: {
            onSuccess: (contact: ContactIOS) => void;
            onFailure?: () => void;
        }): void;
        getContactsByPhoneNumber(phoneNumber: string, handlers: {
            onSuccess: (contacts: ContactIOS[]) => void;
            onFailure?: (error: string) => void;
        }): void;
        fetchAll(params: {
            onSuccess: (...args: any[]) => void;
            onFailure: (...args: any[]) => void;
        }): void;
        add(params: {
            contact: ContactIOS;
            onSuccess?: () => void;
            onFailure?: (...args: any[]) => void;
            page?: Page;
        }): void;
        getAll(params: {
            onFailure: (error: any) => void;
            onSuccess: (contacts: ManagedContact[]) => void;
        }): void;
    }
    export default ContactsIOS;
}
declare module "device/documentpicker/index" {
    import File from "io/file/index";
    import Page from "ui/page/index";
    export enum Types {
        /**
         * @property {String} ALLFILES All document types, on Android this is &#42;&#47;&#42;, on iOS is is public.data.
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.1.5
         */
        ALLFILES = "*/*",
        /**
         * @property {String} IMAGES All image types (image/* or public.image).
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.1.5
         */
        IMAGES = "image/*",
        /**
         * @property {String} PLAINTEXT Plain text files ie: .txt (text/plain or public.plain-text).
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.1.5
         */
        PLAINTEXT = "text/plain",
        /**
         * @property {String} AUDIO All audio types (audio/* or public.audio).
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.1.5
         */
        AUDIO = "audio/*",
        /**
         * @property {String} PDF PDF documents (application/pdf or com.adobe.pdf).
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.1.5
         */
        PDF = "application/pdf"
    }
    /**
     * @class Device.DocumentPicker
     * @since 4.1.5
     *
     * This class provides access to documents.
     *
     * @example
     *     const DocumentPicker = require("@smartface/native/device/documentpicker");
     *
     *     DocumentPicker.pick({
     *      page,
     *      type: [DocumentPicker.Types.PDF],
     *      onSuccess: function (file) {
     *          console.log("onSuccess : ",file.path);
     *       },
     *      onCancel: function () {
     *          console.log("onCancel");
     *       }
     *     });
     *
     */
    export class DocumentPickerBase {
        /**
         * @enum {String} Device.DocumentPicker.Types
         * @since 4.1.5
         * @android
         * @ios
         *
         * Provides a few common types for use as type values.
         */
        static readonly Types: typeof Types;
        /**
         * Use pick to open a document picker for the user to select file.
         *
         * @param {Object} params
         * @param {UI.Page} params.page
         * @param {[DocumentPicker.Types]} params.type On Android these are MIME types such as text/plain or partial MIME types such as image/*. On iOS these must be Apple "Uniform Type Identifiers". Also can use {@link Device.DocumentPicker.Types}.
         * @param {Function} params.onSuccess This event is called after picking document successfully.
         * @param {IO.File} params.onSuccess.file
         * @param {Function} params.onCancel If the user cancels the document picker without choosing a file (by pressing the system back button on Android or the Cancel button on iOS) the Promise will be rejected with a cancellation error.
         * @param {Function} params.onFailure
         * @method pick
         * @android
         * @ios
         * @since 4.1.5
         */
        static pick(params: {
            page: Page;
            /** On Android these are MIME types such as text/plain or partial MIME types such as image/*. On iOS these must be Apple "Uniform Type Identifiers". Also can use {@link Device.DocumentPicker.Types}. */
            type: Types[];
            /** This event is called after picking document successfully. */
            onSuccess: (file: File) => void;
            /** If the user cancels the document picker without choosing a file (by pressing the system back button on Android or the Cancel button on iOS) the Promise will be rejected with a cancellation error. */
            onCancel: () => void;
            /** Android only, if any runtime error occures, this method will be called. This method will be ignored on iOS */
            onFailure: (e?: Error) => void;
        }): void;
    }
    const DocumentPicker: typeof DocumentPickerBase;
    type DocumentPicker = DocumentPickerBase;
    export default DocumentPicker;
}
declare module "device/documentpicker/documentpicker.android" {
    import File from "io/file/index";
    import Page from "ui/page/index";
    import { DocumentPickerBase, Types } from "device/documentpicker/index";
    class DocumentPickerAndroid implements DocumentPickerBase {
        static readonly Types: typeof Types;
        static _onSuccess: (file: File) => void;
        static _onCancel: () => void;
        static _onFailure: (e?: Error) => void;
        static pick(params: {
            page: Page;
            /** On Android these are MIME types such as text/plain or partial MIME types such as image/*. On iOS these must be Apple "Uniform Type Identifiers". Also can use {@link Device.DocumentPicker.Types}. */
            type: Types[];
            /** This event is called after picking document successfully. */
            onSuccess: (file: File) => void;
            /** If the user cancels the document picker without choosing a file (by pressing the system back button on Android or the Cancel button on iOS) the Promise will be rejected with a cancellation error. */
            onCancel: () => void;
            /** Android only, if any runtime error occures, this method will be called. This method will be ignored on iOS */
            onFailure: (e?: Error) => void;
        }): void;
        static onActivityResult(requestCode: any, resultCode: any, data: any): void;
    }
    export default DocumentPickerAndroid;
}
declare module "device/documentpicker/documentpicker.ios" {
    import File from "io/file/index";
    import Page from "ui/page/index";
    import { DocumentPickerBase, Types } from "device/documentpicker/index";
    class DocumentPickerIOS implements DocumentPickerBase {
        static readonly Types: typeof Types;
        static pick(params: {
            page: Page;
            /** On Android these are MIME types such as text/plain or partial MIME types such as image/*. On iOS these must be Apple "Uniform Type Identifiers". Also can use {@link Device.DocumentPicker.Types}. */
            type: Types[];
            /** This event is called after picking document successfully. */
            onSuccess: (file: File) => void;
            /** If the user cancels the document picker without choosing a file (by pressing the system back button on Android or the Cancel button on iOS) the Promise will be rejected with a cancellation error. */
            onCancel: () => void;
            /** Android only, if any runtime error occures, this method will be called. This method will be ignored on iOS */
            onFailure: (e?: Error) => void;
        }): void;
    }
    export default DocumentPickerIOS;
}
declare module "device/hardware/hardware.android" { }
declare module "device/hardware/hardware.ios" { }
declare module "device/location/location.android" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { RequestCodes } from "util/index";
    import { ILocation } from "device/location/index";
    import { LocationEvents } from "device/location/location-events";
    class LocationAndroid extends NativeEventEmitterComponent<LocationEvents> implements ILocation {
        readonly Android: {
            Provider: {
                AUTO: string;
                GPS: string;
                NETWORK: string;
            };
            Priority: {
                HIGH_ACCURACY: number;
                BALANCED: number;
                LOW_POWER: number;
                NO_POWER: number;
            };
            SettingsStatusCodes: {
                DENIED: string;
                OTHER: string;
            };
        };
        iOS: {};
        private _instance;
        CHECK_SETTINGS_CODE: RequestCodes.Location;
        Events: {
            readonly LocationChanged: "locationChanged";
        };
        _onFailureCallback: (e: {
            statusCode: any;
        }) => void;
        _onSuccessCallback: () => void;
        constructor();
        onLocationChanged: (e: {
            latitude: number;
            longitude: number;
        }) => void;
        private getAndroidProps;
        __onActivityResult(resultCode: any): void;
        __getInstance(): any;
        start(priority?: number, interval?: number): void;
        stop(): void;
        getLastKnownLocation(onSuccess: (e: {
            latitude: number;
            longitude: number;
        }) => void, onFailure: () => void): void;
    }
    const SFLocationAndroid: LocationAndroid;
    export default SFLocationAndroid;
}
declare module "device/location/location.ios" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { ILocation } from "device/location/index";
    import { LocationEvents } from "device/location/location-events";
    class LocationIOS extends NativeEventEmitterComponent<LocationEvents> implements ILocation {
        delegate?: __SF_CLLocationManagerDelegate;
        Android: {
            Provider: {};
            Priority: {};
            SettingsStatusCodes: {};
        };
        iOS: {
            AuthorizationStatus: {
                NOTDETERMINED: number;
                RESTRICTED: number;
                DENIED: number;
                AUTHORIZED: number;
            };
        };
        _nativeObject: __SF_CLLocationManager;
        _authorizationStatus: any;
        onLocationChanged: (...args: any[]) => {};
        constructor();
        private getIOSProps;
        __onActivityResult: (resultCode: number) => void;
        changeLocationListener(e: any): void;
        start(): void;
        stop(): void;
        getLastKnownLocation(onSuccess: (e: {
            latitude: number;
            longitude: number;
        }) => void, onFailure: () => void): void;
    }
    const SFLocationIOS: LocationIOS;
    export default SFLocationIOS;
}
declare module "device/multimedia/multimedia.android" {
    import { ConvertToMp4Params, LaunchCropperParams, MultimediaBase, MultimediaParams, PickMultipleFromGalleryParams, RecordVideoParams } from "device/multimedia/index";
    class MultimediaAndroid extends MultimediaBase {
        ios: {
            requestGalleryAuthorization(): void;
            requestCameraAuthorization(): void;
            getGalleryAuthorizationStatus(): void;
            getCameraAuthorizationStatus(): void;
            cameraAuthorizationStatus: {};
            galleryAuthorizationStatus: {};
        };
        iOS: {
            CameraFlashMode: {};
            CameraDevice: {};
        };
        ActionType: {
            IMAGE_CAPTURE: number;
            VIDEO_CAPTURE: number;
        };
        Type: {
            IMAGE: any;
            VIDEO: any;
        };
        CropShape: {
            RECTANGLE: number;
            OVAL: number;
        };
        CameraDevice: {};
        VideoQuality: {
            HIGH: number;
            LOW: number;
        };
        CAMERA_REQUEST: number;
        PICK_FROM_GALLERY: number;
        PICK_MULTIPLE_FROM_GALLERY: number;
        CropImage: {
            CROP_CAMERA_DATA_REQUEST_CODE: number;
            CROP_GALLERY_DATA_REQUEST_CODE: number;
        };
        private _captureParams;
        private _pickParams;
        private _action;
        private _fileURI;
        private _imageFileUri;
        constructor();
        get hasCameraFeature(): boolean;
        startCamera(params: MultimediaParams): void;
        recordVideo(params: RecordVideoParams): void;
        capturePhoto(params: MultimediaParams): void;
        pickFromGallery(params: MultimediaParams): void;
        convertToMp4(params: ConvertToMp4Params): void;
        launchCropper(params: LaunchCropperParams): void;
        pickMultipleFromGallery(params: PickMultipleFromGalleryParams): void;
        onActivityResult(requestCode: any, resultCode: any, data: any): void;
        startRecordVideoWithExtraField(params: {
            _captureParams: any;
        }): void;
        cropCameraDataHelper(_captureParams: any, resultCode: any, data: any): void;
        cropGalleryDataHelper(_pickParams: any, resultCode: any, data: any): void;
        startCropActivityHelper(params: any): void;
        pickMultipleFromGalleryHelper(_pickParams: any, resultCode: any, data: any): void;
        pickFromGalleryHelper(_pickParams: any, resultCode: any, data: any): void;
        getCameraDataHelper(_captureParams: any, resultCode: any, data: any): void;
    }
    const Multimedia: MultimediaAndroid;
    export default Multimedia;
}
declare module "device/multimedia/multimedia.ios" {
    import { MultimediaBase } from "device/multimedia/index";
    class MultimediaIOS extends MultimediaBase {
        CropShape: {
            RECTANGLE: number;
            OVAL: number;
        };
        android: {};
        Android: {
            CropShape: {};
        };
        ios: {
            native: {
                AVCaptureDeviceRequestAccessForMediaType(callback: any): void;
                AVCaptureDeviceaAuthorizationStatusForMediaType(): __SF_NSOBject | undefined;
                PHPhotoLibraryRequestAuthorization(callback: any): void;
                PHPhotoLibraryAuthorizationStatus(): __SF_NSOBject | undefined;
            };
            cameraAuthorizationStatus: {
                NotDetermined: number;
                Restricted: number;
                Denied: number;
                Authorized: number;
            };
            galleryAuthorizationStatus: {
                NotDetermined: number;
                Restricted: number;
                Denied: number;
                Authorized: number;
            };
        };
        iOS: {
            CameraFlashMode: {
                OFF: number[];
                AUTO: number[];
                ON: number[];
            };
            CameraDevice: {
                REAR: number;
                FRONT: number;
            };
            CameraAuthorizationStatus: {
                NOTDETERMINED: number;
                RESTRICTED: number;
                DENIED: number;
                AUTHORIZED: number;
            };
            GalleryAuthorizationStatus: {
                NOTDETERMINED: number;
                RESTRICTED: number;
                DENIED: number;
                AUTHORIZED: number;
            };
        };
        VideoQuality: {
            LOW: number;
            HIGH: number;
            iOS: {
                MEDIUM: number;
                TYPE640x480: number;
                TYPEIFRAME1280x720: number;
                TYPEIFRAME960x540: number;
            };
        };
        ActionType: {
            IMAGE_CAPTURE: string[];
            VIDEO_CAPTURE: string[];
        };
        Type: {
            IMAGE: string[];
            VIDEO: string[];
            ALL: string[];
        };
        private picker;
        private pickerDelegate;
        hasCameraFeature: __SF_NSOBject | undefined;
        constructor();
        createImagePickerController(e: any): __SF_UIImagePickerController;
        startCamera(e: any): void;
        convertToMp4(e: any): void;
        capturePhoto(e: any): void;
        recordVideo(e: any): void;
        pickFromGallery(e: any): void;
        pickMultipleFromGallery(e: any): void;
        launchCropper(e: any): void;
    }
    const Multimedia: MultimediaIOS;
    export default Multimedia;
}
declare module "device/network/network.android" {
    import { ConnectionType, NetworkBase, NetworkNotifier } from "device/network/index";
    import NativeComponent from "core/native-component";
    class Notifier extends NativeComponent implements NetworkNotifier {
        private isReceiverCreated;
        private _connectionTypeChanged;
        private _initialCacheEnabled;
        subscribe: (callback: (type: ConnectionType) => void) => void;
        unsubscribe: () => void;
        android: {
            isInitialStickyNotification(): boolean;
            initialCacheEnabled: boolean;
        };
        constructor(params?: {
            connectionTypeChanged: (type: ConnectionType) => void;
        });
        get connectionTypeChanged(): any;
        set connectionTypeChanged(value: any);
    }
    class NetworkAndroid extends NativeComponent implements NetworkBase {
        ConnectionType: typeof ConnectionType;
        readonly roamingEnabled = false;
        constructor();
        readonly notifier: Notifier;
        get IMSI(): any;
        get SMSEnabled(): boolean;
        get bluetoothMacAddress(): any;
        get carrier(): any;
        get connectionType(): ConnectionType;
        get connectionIP(): string;
        get wirelessMacAddress(): any;
        cancelAll(): void;
    }
    const Network: NetworkAndroid;
    export default Network;
}
declare module "device/network/network.ios" {
    import { ConnectionType, NetworkBase, NetworkNotifier } from "device/network/index";
    import NativeComponent from "core/native-component";
    class NetworkIOS extends NativeComponent implements NetworkBase {
        ConnectionType: typeof ConnectionType;
        readonly notifier: NetworkNotifier;
        constructor();
        roamingEnabled: boolean;
        get SMSEnabled(): boolean;
        get IMSI(): string;
        get bluetoothMacAddress(): string;
        get wirelessMacAddress(): string;
        get carrier(): string;
        get connectionType(): number;
        get connectionIP(): string;
        cancelAll(): void;
    }
    const Network: NetworkIOS;
    export default Network;
}
declare module "util/base64" {
    const Base64Util: {
        UTf8ArrayToStr: (data: string[]) => string | null;
        StrToUtf8Array: (str: string) => string[];
    };
    export default Base64Util;
}
declare module "global/blob/blob.android" {
    import { BlobBase } from "global/blob/blob";
    class BlobAndroid extends BlobBase {
        private _parts;
        private _type;
        constructor(parts?: string[], properties?: {
            type: string;
        });
        get type(): string;
        get size(): number;
        slice(start: number, end: number): BlobBase;
        toBase64(): any;
        toBase64Async(callbacks: {
            onComplete: (base64: String) => void;
            onFailure?: () => void;
        }): void;
        toString(): any;
        /** @todo
         * Error: Attempt to invoke virtual method 'int io.smartface.ExposingEngine.FastArray.size()' on a null object reference
         */
        static createFromBase64(base64String: string): BlobAndroid;
        static createFromUTF8String(str: string): BlobAndroid;
        get parts(): string[];
    }
    export default BlobAndroid;
}
declare module "ui/image/image.android" {
    import IBlob from "global/blob/blob";
    import BlobAndroid from "global/blob/blob.android";
    import { IImage, Format, AbstractImage } from "ui/image/index";
    export default class ImageAndroid extends AbstractImage {
        static createFromFile(path: string, width?: number, height?: number): ImageAndroid | null;
        static createSystemIcon(systemIcon: number | string): ImageAndroid;
        static createFromBlob(blob: any): ImageAndroid | null;
        static android: {
            createRoundedImage(params: any): ImageAndroid | null;
        };
        static createImageFromPath: (path: any) => any;
        static systemDrawableId: (systemIcon: any) => any;
        private _systemIcon;
        constructor(params: {
            bitmap?: any;
            roundedBitmapDrawable?: any;
            android?: {
                systemIcon?: any;
            };
        });
        get height(): number;
        get width(): number;
        toBlob(): IBlob;
        resize(width: number, height: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): ImageAndroid | null | undefined;
        crop(x: number, y: number, width: number, height: number, onSuccess: (e: {
            image: IImage;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): ImageAndroid | null;
        rotate(angle: number, onSuccess: (e: {
            image: IImage;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): ImageAndroid | null | undefined;
        compress(format: Format, quality: number, onSuccess: (e: {
            blob: IBlob;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): BlobAndroid | null | undefined;
        set autoMirrored(isAutoMirrored: boolean);
        get autoMirrored(): any;
        set bitmap(value: any);
        set path(value: any);
        set roundedBitmapDrawable(value: any);
        set drawable(value: any);
        get android(): {
            round(radius: number): ImageAndroid;
            systemIcon: IImage;
        };
    }
}
declare module "device/screen/screen.android" {
    import { IScreen, OrientationType } from "device/screen/index";
    import ImageAndroid from "ui/image/image.android";
    class ScreenAndroid implements IScreen {
        OrientationType: typeof OrientationType;
        get dpi(): any;
        get height(): number;
        get width(): number;
        get touchSupported(): any;
        get orientation(): OrientationType.PORTRAIT | OrientationType.UPSIDEDOWN | OrientationType.LANDSCAPELEFT | OrientationType.LANDSCAPERIGHT;
        capture(): ImageAndroid;
    }
    const Screen: ScreenAndroid;
    export default Screen;
}
declare module "device/screen/screen.ios" {
    import { OrientationType, IScreen } from "device/screen/index";
    class ScreenIOS implements IScreen {
        OrientationType: typeof OrientationType;
        ios: {
            forceTouchAvaliable: boolean;
        };
        constructor();
        get dpi(): 326 | 401 | 163;
        get height(): number;
        get width(): number;
        get touchSupported(): number;
        get orientation(): OrientationType;
        capture: () => import("ui/image").IImage;
    }
    const Screen: ScreenIOS;
    export default Screen;
}
declare module "device/sound/sound.android" {
    import { AbstractSound } from "device/sound/index";
    import File from "io/file/index";
    import { RequestCodes } from "util/index";
    export default class SoundAndroid extends AbstractSound {
        static Events: {
            readonly Ready: "ready";
            readonly Finish: "finish";
        };
        static PICK_SOUND: RequestCodes.Sound;
        private _onReadyCallback;
        private _onFinishCallback;
        private _volume;
        constructor(params?: Partial<SoundAndroid>);
        private getAndroidProps;
        get volume(): number;
        set volume(volume: number);
        get isLooping(): boolean;
        set isLooping(isLooping: boolean);
        get isPlaying(): boolean;
        get currentDuration(): number;
        get totalDuration(): number;
        get onReady(): () => void;
        set onReady(onReady: () => void);
        get onFinish(): () => void;
        set onFinish(onFinish: () => void);
        pause(): void;
        seekTo(milliseconds: any): void;
        stop(): void;
        play(): void;
        loadFile(file: File): void;
        loadURL(url: string): void;
        static onActivityResult(requestCode: number, resultCode: number, data: any): void;
        static _pickParams: {
            onCancel?: () => void;
            onFailure?: (e?: {
                message: string;
            }) => void;
            onSuccess?: (e?: {
                sound: SoundAndroid;
            }) => void;
        };
    }
}
declare module "device/sound/sound.ios" {
    import { AbstractSound } from "device/sound/index";
    import File from "io/file/index";
    export default class SoundIOS extends AbstractSound {
        static Events: {
            readonly Ready: "ready";
            readonly Finish: "finish";
        };
        private avPlayerItem;
        private _isLooping;
        private _onReadyCallback;
        private _onFinishCallback;
        constructor(params?: Partial<SoundIOS>);
        get onReady(): () => void;
        set onReady(onReady: () => void);
        get onFinish(): () => void;
        set onFinish(onFinish: () => void);
        get isPlaying(): boolean;
        get totalDuration(): number;
        get currentDuration(): number;
        get volume(): number;
        set volume(volume: number);
        get isLooping(): boolean;
        set isLooping(isLooping: boolean);
        loadURL(value: string): void;
        loadFile(value: File): void;
        play(): void;
        pause(): void;
        stop(): void;
        seekTo(milliseconds: number): void;
        setVolume(value: number): void;
    }
}
declare module "device/system/system.android" {
    import { AbstractSystem, OSType } from "device/system/index";
    class SystemAndroid implements AbstractSystem {
        OSVersion: any;
        OS: OSType;
        OSType: typeof OSType;
        BiometryType: {
            BIOMETRICS: any;
            NONE: any;
        };
        ios: {
            validateFingerPrint(): void;
            LAContextBiometricType(): void;
            LABiometryType: {};
        };
        private _android;
        constructor();
        get region(): any;
        get language(): any;
        get isBatteryCharged(): boolean;
        get batteryLevel(): number;
        get clipboard(): string | null;
        set clipboard(text: string | null);
        vibrate(options?: {
            millisecond: number;
        }): void;
        get fingerPrintAvailable(): any;
        get biometricsAvailable(): boolean;
        validateBiometric(params: {
            android: {
                title: string;
                cancelButtonText?: string;
                subTitle?: string;
                confirmationRequired?: boolean;
            };
            message: string;
            onSuccess: () => void;
            onError: (cancelled?: boolean, error?: string) => void;
        }): void;
        get biometricType(): any;
        validateFingerPrint(params: {
            android: Partial<{
                title: string;
            }>;
            message: string;
            onSuccess: () => void;
            onError: () => void;
        }): void;
        get isEmulator(): boolean;
    }
    const System: SystemAndroid;
    export default System;
}
declare module "device/system/system.ios" {
    import { AbstractSystem, BiometryType, OSType } from "device/system/index";
    class SystemIOS implements AbstractSystem {
        OSVersion: string;
        OS: OSType;
        OSType: typeof OSType;
        BiometryType: typeof BiometryType;
        android: {
            isApplicationInstalled(): void;
        };
        private _ios;
        constructor();
        get region(): string;
        get language(): string;
        get batteryLevel(): number;
        get isBatteryCharged(): boolean;
        get clipboard(): string;
        set clipboard(value: string);
        get isEmulator(): any;
        get fingerPrintAvaliable(): boolean;
        get biometricType(): number;
        get ios(): any;
        get biometricsAvailable(): boolean;
        vibrate(): void;
        validateBiometric(params: {
            message: string;
            onSuccess: () => void;
            onError: (cancelled?: boolean, error?: string) => void;
        }): void;
        validateFingerPrint(params: {
            message: string;
            onSuccess: () => void;
            onError: (cancelled?: boolean, error?: string) => void;
        }): void;
        isApplicationInstalled(packageName: any): boolean;
    }
    const System: SystemIOS;
    export default System;
}
declare module "global/notifications/notifications-events" {
    export const NotificationEvents: {
        /**
         * Handles a notification messages that arrived while the app was running in the foreground for iOS  but Android handles while in the foreground or background.
         * In iOS, the return value  specifies how you want the system to alert the user, if at all. So return values does not effect in Android.
         *
         *     @example
         *     Notifications.onNotificationReceive = function(e){
         *      console.log("willPresentNotification", e);
         *      return [Notifications.iOS.NotificationPresentationOptions.SOUND,Notifications.iOS.NotificationPresentationOptions.ALERT]; // or []
         *     };
         *
         * @event onNotificationReceive
         * @param {Object} data
         * @return {Array|Notifications.iOS.NotificationPresentationOptions} Specify [] to silence the notification completely.
         * @ios
         * @android
         * @static
         * @since 4.0.3
         */
        readonly NotificationReceive: "notificationReceive";
        /**
         * This event triggered when clicked on notification alert
         *
         * @event onNotificationClick
         * @param {Object} data
         * @ios
         * @android
         * @static
         * @since 4.0.3
         */
        readonly NotificationClick: "notificationClick";
    };
    export type NotificationEvents = ExtractValues<typeof NotificationEvents>;
}
declare module "global/notifications/notifications" {
    import Color from "ui/color/index";
    import { NotificationEvents } from "global/notifications/notifications-events";
    import { UnauthorizationStatus } from "global/notifications/unauthorization-status";
    /**
     * @class Notifications
     *
     * Notification is a message belongs to an application.
     *
     *     @example
     *     const Notifications = require("@smartface/native/notifications");
     *     Notifications.registerForPushNotifications(function(e){
     *         console.log("Successfully registered. The token is: " + e.token);
     *     },function(){
     *         console.log("Register failed.");
     *     });
     *
     */
    export class NotificationsBase {
        static on(eventName: NotificationEvents, callback: (...args: any) => void): () => void;
        static once(eventName: NotificationEvents, callback: (...args: any) => void): () => void;
        static off(eventName: NotificationEvents, callback?: (...args: any) => void): void;
        static emit(event: NotificationEvents, ...args: any[]): void;
        static Events: NotificationEvents;
        /**
         * Cancel all presented or scheduled local notifications.
         *
         * @method cancelAllLocalNotifications
         * @android
         * @ios
         * @static
         * @since 0.1
         * @deprecated 4.0.8 Use {@link Notifications#removeAllDeliveredNotifications}
         */
        static cancelAllLocalNotifications(): void;
        /**
         * Register for remote push notifications. For emulator this will not work and always calls onFailure callback.
         * This function uses senderID inside of project.json file for registering push notification services. You can obtain
         * registration token from onSuccess callback's argument's 'token' property.
         *
         * You can receive push notification data from Application.onReceivedNotification when push notification arrives.
         *
         * @method registerForPushNotifications
         * @param {Function} onSuccess
         * @param {Function} onFailure
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static registerForPushNotifications(onSuccess: ({ token: string }: {
            token: any;
        }) => void, onFailure: () => void): void;
        static ongoing: boolean;
        /**
         * Unregister for remote push notifications. For emulator this will not work and does nothing.
         *
         * @method unregisterForPushNotifications
         * @android
         * @ios
         * @static
         * @since 0.1
         */
        static unregisterForPushNotifications(): void;
        /**
         * Gets authorization status.
         *
         * @method getAuthorizationStatus
         * @param {Function} callback
         * @param {Notifications.iOS.AuthorizationStatus} callback.status
         * @ios
         * @static
         * @since 2.0.11
         */
        static getAuthorizationStatus(callback: (status: Notifications.iOS.AuthorizationStatus) => void): void;
        /**
         * Handles a notification messages that arrived while the app was running in the foreground for iOS  but Android handles while in the foreground or background.
         * In iOS, the return value  specifies how you want the system to alert the user, if at all. So return values does not effect in Android.
         *
         *     @example
         *     Notifications.onNotificationReceive = function(e){
         *      console.log("willPresentNotification", e);
         *      return [Notifications.iOS.NotificationPresentationOptions.SOUND,Notifications.iOS.NotificationPresentationOptions.ALERT]; // or []
         *     };
         *
         * @event onNotificationReceive
         * @deprecated
         * @param {Object} data
         * @return {Array|Notifications.iOS.NotificationPresentationOptions} Specify [] to silence the notification completely.
         * @ios
         * @android
         * @static
         * @since 4.0.3
         * @example
         * ````
         * import Notifications from '@smartface/native/global/natifications';
         *
         * Notifications.on(Notifications.Events.NotificationReceive, (params) => {
         * 	console.info('onNotificationReceive', params);
         * });
         * ````
         */
        static onNotificationReceive(data: any): Notifications.iOS.NotificationPresentationOptions[];
        /**
         * This event triggered when clicked on notification alert
         *
         * @event onNotificationClick
         * @deprecated
         * @param {Object} data
         * @ios
         * @android
         * @static
         * @since 4.0.3
         * @example
         * ````
         * import Notifications from '@smartface/native/global/natifications';
         *
         * Notifications.on(Notifications.Events.NoficationClick, (params) => {
         * 	console.info('onNotificationClick', params);
         * });
         * ````
         */
        static onNotificationClick: (data: any) => void;
        /**
         * Use this method to remove all of your apps delivered notifications.
         *
         * @method removeAllDeliveredNotifications
         * @ios
         * @android
         * @static
         * @since 4.0.8
         */
        static removeAllDeliveredNotifications(): void;
        static readonly ios: Partial<{
            authorizationStatus: typeof UnauthorizationStatus;
            /**
             * Gets/sets badge number of the application. This number will be displayed as the application's icon badge.
             *
             * @property {Number} applicationIconBadgeNumber
             * @ios
             * @static
             * @since 0.1
             */
            applicationIconBadgeNumber: number;
            /**
             * Gets scheduled local notifications.
             *
             * @property {Notifications.LocalNotification} [scheduledLocalNotifications = null]
             * @ios
             * @readonly
             * @static
             * @since 0.1
             */
            readonly scheduledLocalNotifications: null | Notifications.LocalNotification;
        }>;
        readonly android: {};
    }
    export namespace Notifications {
        /**
         * @enum {Number} Notifications.Priority
         * @since 0.1
         *
         * Priority for the notification.
         *
         * @deprecated 1.1.18 Use {@link Notifications.Android.Priority} instead.
         */
        enum Priority {
            /**
             * @property {Number} DEFAULT
             * @static
             * @readonly
             * @since 0.1
             * @deprecated 1.1.18 Use {@link Notifications.Android.Priority#DEFAULT} instead.
             */
            DEFAULT = 0,
            /**
             * @property {Number} MIN
             * @static
             * @readonly
             * @since 0.1
             * @deprecated 1.1.18 Use {@link Notifications.Android.Priority#MIN} instead.
             */
            MIN = -2,
            /**
             * @property {Number} LOW
             * @static
             * @readonly
             * @since 0.1
             * @deprecated 1.1.18 Use {@link Notifications.Android.Priority#LOW} instead.
             */
            LOW = -1,
            /**
             * @property {Number} HIGH
             * @static
             * @readonly
             * @since 0.1
             * @deprecated 1.1.18 Use {@link Notifications.Android.Priority#HIGH} instead.
             */
            HIGH = 1,
            /**
             * @property {Number} MAX
             * @static
             * @readonly
             * @since 0.1
             * @deprecated 1.1.18 Use {@link Notifications.Android.Priority#MAX} instead.
             */
            MAX = 2
        }
        /**
         * @class Notifications.LocalNotification
         *
         * LocalNotification is an interface between user and application that enables an application to
         * inform its users that it has something for them. You can schedule local notification at a time.
         * After scheduling a notification, either application running or in background, scheduled
         * notification will delivered on its time.
         *
         * For Android, application icon must be placed inside apk. For this reason, you can see your icon as a
         * notification icon only in publish builds.
         *
         *
         *     @example
         *     const Notifications = require("@smartface/native/notifications");
         *     var notification = new Notifications.LocalNotification();
         *     notification.alertAction = "Notification alertAction";
         *     notification.alertBody = "Notification alertBody";
         *     notification.android.vibrate = true;
         *     notification.ios.hasAction = true;
         *     notification.present();
         *
         */
        class LocalNotification {
            /**
             * Gets/sets the message displayed in the notification alert.
             *
             * @property {String} [alertBody = '']
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            alertBody: string;
            /**
             * Gets/sets the title displayed in the notification alert.
             *
             * @property {String} [alertAction = '']
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            alertAction: string;
            /**
             * Gets/sets the path of the file that will be played when a notification is displayed.
             * For iOS, sounds that last longer than 30 seconds are not supported. If you specify a
             * file with a sound that plays over 30 seconds, the default sound is played instead.
             *
             * @property {String} [sound = '']
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            sound: string;
            /**
             * Gets/sets the path of the image that will be displayed as large icon for Android,
             * as the launch image when the user taps for iOS.
             *
             * @property {String} [launchImage = '']
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            launchImage: string;
            /**
             * Gets/sets the fire date of the LocalNotification. FireDate is the date and time when
             * the system should deliver the notification in the default timezone. If the specified
             * value is null or is a date in the past, the notification is delivered immediately.
             *
             * @property {Number} [fireDate = Date.now()]
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            fireDate: number;
            /**
             * Gets/sets the repeat interval of the LocalNotification. When you schedule local
             * notification, it will repeats by repeatInterval as miliseconds.
             *
             * @property {Number} [repeatInterval = 0]
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            repeatInterval: number;
            android: {
                /**
                 * Gets/sets the color to be applied by the standard Style templates when presenting
                 * this notification for Android. This property works only for Android version
                 * LOLLIPOP (API 21) or above.
                 *
                 * @property {Number} color
                 * @android
                 * @static
                 * @since 0.1
                 */
                color?: Color;
                /**
                 * Gets/sets the indeterminate status of the LocalNotification. If indeterminate,
                 * set the progress this notification represents.
                 * You shouldn't use both indeterminate and {@link Notifications.LocalNotification#subText} at the same time.
                 *
                 * @property {Boolean} [indeterminate = false]
                 * @android
                 * @static
                 * @since 0.1
                 */
                indeterminate?: boolean;
                /**
                 * Gets/sets the text that that is displayed in the status bar when the notification
                 * first arrives to the Notification Center of the Android.
                 *
                 * @property {String} [ticker = '']
                 * @android
                 * @static
                 * @since 0.1
                 */
                ticker: string;
                /**
                 * Gets/sets the vibration status when the notification first arrives to the
                 * Notification Center of the Android.
                 *
                 * @property {Boolean} [vibrate = false]
                 * @android
                 * @static
                 * @since 0.1
                 */
                vibrate: boolean;
                /**
                 * Gets/sets the priority of the LocalNotification. Priority determines how much attention
                 * should be consumed by this notification. LOW_PRIORTY notifications may be hidden from the
                 * user in certain situations while the user might be interrupted for a higher-priority notification.
                 *
                 * @property {Notifications.Priority} [priority = Notifications.Priority.DEFAULT]
                 * @android
                 * @static
                 * @since 0.1
                 */
                priority: Priority;
                /**
                 * Gets/sets the subtext of the LocalNotification. Android will shown subtext as the third line of the notification.
                 * You shouldn't use both {@link Notifications.LocalNotification#indeterminate} and subText at the same time.
                 *
                 * @property {String} [subText = '']
                 * @android
                 * @static
                 * @since 0.1
                 */
                subText: string;
            };
            ios: Partial<{
                /**
                 * Gets/sets badge number of the application. This number will be displayed as the application's icon badge.
                 *
                 * @property {Number} [applicationIconBadgeNumber = 0]
                 * @ios
                 * @static
                 * @since 0.1
                 */
                applicationIconBadgeNumber: number;
                /**
                 * Gets/sets the boolean value that controls whether the notification shows or hides the alert action.
                 *
                 * @property {Boolean} [hasAction = true]
                 * @ios
                 * @static
                 * @since 0.1
                 */
                hasAction: boolean;
                /**
                 * Gets/sets the user information of the LocalNotification.
                 *
                 * @property {Object} [userInfo = {}]
                 * @ios
                 * @static
                 * @since 0.1
                 */
                userInfo: any;
            }>;
            /**
             * Schedules this notification by {@link Notifications.LocalNotification#fireDate} and {@link Notifications.LocalNotification#repeatInterval}.
             *
             * @method schedule
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            schedule(): void;
            /**
             * Presents notification to the user immediately.
             *
             * @method present
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            present(): void;
            /**
             * Cancels this notification even if this is scheduled or presented notification.
             *
             * @method cancel
             * @android
             * @ios
             * @static
             * @since 0.1
             */
            cancel(): void;
        }
        /**
         * Android Specific Properties.
         * @class Notifications.Android
         * @since 1.1.18
         */
        namespace Android {
            /**
             * @enum {Number} Notifications.Android.Priority
             * @since 1.1.18
             *
             * Priority for the notification.
             */
            enum Priority {
                /**
                 * @property {Number} DEFAULT
                 * @static
                 * @readonly
                 * @since 1.1.18
                 */
                DEFAULT = 0,
                /**
                 * @property {Number} MIN
                 * @static
                 * @readonly
                 * @since 1.1.18
                 */
                MIN = -2,
                /**
                 * @property {Number} LOW
                 * @static
                 * @readonly
                 * @since 1.1.18
                 */
                LOW = -1,
                /**
                 * @property {Number} HIGH
                 * @static
                 * @readonly
                 * @since 1.1.18
                 */
                HIGH = 1,
                /**
                 * @property {Number} MAX
                 * @static
                 * @readonly
                 * @since 1.1.18
                 */
                MAX = 2
            }
        }
        /**
         * iOS Specific Properties.
         * @class Notifications.iOS
         * @since 3.1.1
         */
        namespace iOS {
            /**
             * Display the alert using the content provided by the notification.
             *
             * @property {Number} ALERT
             * @static
             * @ios
             * @readonly
             * @since 4.0.3
             */
            enum AuthorizationStatus {
                /**
                 * The user has not yet made a choice regarding whether the application may post user notifications.
                 *
                 * @property {Number} NOTDETERMINED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                NOTDETERMINED = 0,
                /**
                 * The application is not authorized to post user notifications.
                 *
                 * @property {Number} DENIED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                DENIED = 1,
                /**
                 * The application is authorized to post user notifications.
                 *
                 * @property {Number} AUTHORIZED
                 * @static
                 * @ios
                 * @readonly
                 * @since 3.1.1
                 */
                AUTHORIZED = 2
            }
            /**
             * Constants indicating how to present a notification in a foreground app.
             *
             * @enum {Number} Notifications.iOS.NotificationPresentationOptions
             * @since 4.0.3
             * @ios
             */
            enum NotificationPresentationOptions {
                /**
                 * Apply the notification's badge value to the apps icon.
                 *
                 * @property {Number} BADGE
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.0.3
                 */
                BADGE = 1,
                /**
                 * Play the sound associated with the notification.
                 *
                 * @property {Number} SOUND
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.0.3
                 */
                SOUND = 2,
                /**
                 * Display the alert using the content provided by the notification.
                 *
                 * @property {Number} ALERT
                 * @static
                 * @ios
                 * @readonly
                 * @since 4.0.3
                 */
                ALERT = 4
            }
        }
    }
}
declare module "global/notifications/index" {
    import { NotificationsBase } from "global/notifications/notifications";
    const Notifications: typeof NotificationsBase;
    type Notifications = NotificationsBase;
    export default Notifications;
}
declare module "global/share/share" {
    import Page from "ui/page/index";
    import Image from "ui/image/index";
    import File from "io/file/index";
    import { Contact } from "device/contacts/index";
    /**
     * @class Share
     * @static
     * @since 0.1
     *
     * Share allows sending a text, an image or a file over
     * other apps on the device. Blacklist works for iOS only.
     *
     */
    export class ShareBase {
        /**
         * Shares a text.
         *
         *     @example
         *     const Share = require('@smartface/native/share');
         *     Share.shareText("Hello from @smartface/native", myPage, [Share.ios.Twitter, Share.ios.Facebook]);
         *
         * @method shareText
         * @param {String} text
         * @param {UI.Page} page
         * @param {Array} [blacklist]
         * @ios
         * @android
         * @since 0.1
         */
        static shareText(text: string, page: Page, blacklist: string[]): void;
        /**
         * Shares an image.
         *
         *     @example
         *     const Share = require('@smartface/native/share');
         *     const Image = require('@smartface/native/ui/image');
         *
         *     var image = Image.createFromFile('path to the image');
         *     Share.shareImage(image, myPage, []);
         *
         * @method shareImage
         * @param {UI.Image} image
         * @param {UI.Page} page
         * @param {Array} [blacklist]
         * @android
         * @ios
         * @since 0.1
         */
        static shareImage(image: Image, page: Page, blacklist: string[]): void;
        /**
         * Shares a file.
         *
         *     @example
         *     const Share = require('@smartface/native/share');
         *     const File = require('@smartface/native/io/file');
         *
         *     var file = new File({path: 'path to the file'});
         *     Share.shareFile(file, myPage, []);
         *
         * @method shareFile
         * @param {IO.File} file
         * @param {UI.Page} page
         * @param {Array} [blacklist]
         * @ios
         * @android
         * @since 0.1
         */
        static shareFile(file: File, page: Page, blacklist: string[]): void;
        /**
         * Shares contact.
         *
         * @method shareContacts
         * @param {Object} params
         * @param {Contacts.Contact[]} params.items
         * @param {String} params.fileName Specifies vCard file name. Defaults to Contacts
         * @param {UI.Page} params.page
         * @param {Array} [params.blacklist]
         * @ios
         * @android
         * @see https://developer.smartface.io/docs/native-share-in-ios-and-android#contacts-sharing
         * @since 4.2.1
         */
        static shareContacts(params: {
            items: Contact[];
            fileName?: string;
            page: Page;
            blacklist: string[];
        }): void;
        /**
         * Shares file, image & text.
         *
         *     @example
         *     const Share = require('@smartface/native/share');
         *     const File = require('@smartface/native/io/file');
         *
         *     var myPage = this; // in page scope
         *     var file = new File({
         *         path: 'assets://yourFile.pdf'
         *     });
         *     var image = Image.createFromFile("images://smartface.png");
         *     var text = "Hello from Smartface";
         *     Share.share({ items: [text, file, image] , page: myPage, blacklist: [Share.ios.Twitter, Share.ios.Facebook]});
         *
         * @method share
         * @param {Object} params
         * @param {Array} params.items
         * @param {UI.Page} params.page
         * @param {Array} [params.blacklist]
         * @ios
         * @android
         * @see https://developer.smartface.io/docs/native-share-in-ios-and-android#multiple-sharing
         * @since 4.0.2
         */
        static share(params: {
            items: any[];
            page: Page;
            blacklist: string[];
        }): void;
        static ios: Partial<{
            /**
             * @property {String} AirDrop
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly AirDrop: string;
            /**
             * @property {String} Facebook
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly Facebook: string;
            /**
             * @property {String} Twitter
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly Twitter: string;
            /**
             * @property {String} Message
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly Message: string;
            /**
             * @property {String} Mail
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly Mail: string;
            /**
             * @property {String} Vimeo
             * @static
             * @readonly
             * @ios
             * @since 0.1
             */
            readonly Vimeo: string;
        }>;
    }
}
declare module "global/share/index" {
    import { ShareBase } from "global/share/share";
    const Share: typeof ShareBase;
    type Share = ShareBase;
    export default Share;
}
declare module "global/data/data" {
    /**
     * @class Data
     * @since 0.1
     *
     * Data is an interface for storing key data on Device like user information, login data or token.
     *
     *     @example
     *     const Data = require('@smartface/native/data');
     *
     *     Data.setStringVariable('userName','Smartface');
     *     Data.setStringVariable('userEmail','info@smartface.io');
     *     Data.setIntVariable('userAge',5);
     *     Data.setBooleanVariable('userLogged',true);
     *
     *     // get values from Data
     *     let userName = Data.getStringVariable('userName');
     *     let userEmail = Data.getStringVariable('userEmail');
     *
     */
    export class BaseData {
        /**
         * Get stored string type variable. If variable is not exists, will return null.
         *
         * @method getStringVariable
         * @param {String} key
         * @return {String}
         * @android
         * @ios
         * @since 0.1
         */
        static getStringVariable: (key: string) => string;
        /**
         * Get stored boolean type variable. If variable is not exists, will return null.
         *
         * @method getBooleanVariable
         * @param {String} key
         * @return {Boolean}
         * @android
         * @ios
         * @since 0.1
         */
        static getBooleanVariable: (key: string) => boolean;
        /**
         * Get stored integer type variable. If variable is not exists, will return null
         *
         * @method getIntVariable
         * @param {String} key
         * @return {Number}
         * @android
         * @ios
         * @since 0.1
         */
        static getIntVariable: (key: string) => number;
        /**
         * Get stored float type variable. If variable is not exists, will return null
         *
         * @method getFloatVariable
         * @param {String} key
         * @return {Number}
         * @android
         * @ios
         * @since 0.1
         */
        static getFloatVariable: (key: string) => number;
        /**
         * Get stored long type variable. If variable is not exists, will return null
         *
         * @method getLongVariable
         * @param {String} key
         * @return {Number}
         * @android
         * @ios
         * @since 0.1
         */
        static getLongVariable: (key: string) => number;
        /**
         * Store string type variable
         *
         * @method setStringVariable
         * @param {String} key
         * @param {String} value
         * @android
         * @ios
         * @since 0.1
         */
        static setStringVariable: (key: string, value: string) => void;
        /**
         * Store boolean type variable
         *
         * @method setBooleanVariable
         * @param {String} key
         * @param {Boolean} value
         * @android
         * @ios
         * @since 0.1
         */
        static setBooleanVariable: (key: string, value: boolean) => void;
        /**
         * Store integer type variable
         *
         * @method setIntVariable
         * @param {String} key
         * @param {Number} value
         * @android
         * @ios
         * @since 0.1
         */
        static setIntVariable: (key: string, value: number) => void;
        /**
         * Store float type variable
         *
         * @method setFloatVariable
         * @param {String} key
         * @param {Number} value
         * @android
         * @ios
         * @since 0.1
         */
        static setFloatVariable: (key: string, value: number) => void;
        /**
         * Store long type variable
         *
         * @method setLongVariable
         * @param {String} key
         * @param {Number} value
         * @android
         * @ios
         * @since 0.1
         */
        static setLongVariable: (key: string, value: number) => void;
        /**
         * Check variable exist within storaged variables.
         *
         * @method containsVariable
         * @param {String} key
         * @return {Boolean}
         * @android
         * @ios
         * @since 0.1
         */
        static containsVariable: (key: string) => boolean;
        /**
         * Remove variable.
         *
         * @method removeVariable
         * @param {String} key
         * @android
         * @ios
         * @since 0.1
         */
        static removeVariable: (key: string) => void;
        /**
         * Removes all variables from storage regardless of their types
         *
         * @method removeAllVariables
         * @param {String} key
         * @android
         * @ios
         * @since 0.1
         */
        static removeAllVariables: (key: string) => void;
    }
}
declare module "global/data/index" {
    import { BaseData } from "global/data/data";
    const Data: typeof BaseData;
    type Data = BaseData;
    export default Data;
}
declare module "global/securedata/securedata" {
    import { INativeComponent } from "core/inative-component";
    import NativeComponent from "core/native-component";
    interface ISecureData extends INativeComponent {
        save(params: {
            value: string;
        }): Promise<void>;
        read(): Promise<any>;
        delete(): Promise<void>;
        readonly key: string;
        readonly service?: string | undefined;
    }
    export abstract class AbstractSecureData extends NativeComponent implements ISecureData {
        protected _key: string;
        protected _service?: string;
        abstract save(params: {
            value: string;
        }): Promise<void>;
        abstract read(): Promise<any>;
        abstract delete(): Promise<void>;
        abstract key: string;
        abstract service: string | undefined;
    }
    export default ISecureData;
}
declare module "global/securedata/index" {
    import { ConstructorOf } from "core/constructorof";
    import ISecureData from "global/securedata/securedata";
    const SecureData: ConstructorOf<ISecureData, {
        key: string;
        ios?: {
            service?: any;
        };
    }>;
    type SecureData = ISecureData;
    export default SecureData;
}
declare module "global/speechrecognizer/speechrecognizer" {
    export enum SpeechRecognizerError {
        INSUFFICIENT_PERMISSIONS = "INSUFFICIENT_PERMISSIONS",
        NETWORK = "NETWORK",
        NETWORK_TIMEOUT = "NETWORK_TIMEOUT",
        SPEECH_TIMEOUT = "SPEECH_TIMEOUT",
        CLIENT = "CLIENT",
        SERVER = "SERVER"
    }
    export enum SpeechRecognizerAndroidError {
        AUDIO = "AUDIO",
        NO_MATCH = "NO_MATCH",
        RECOGNIZER_BUSY = "RECOGNIZER_BUSY"
    }
    /**
     * @class SpeechRecognizer
     * @static
     * @since 1.1.13
     *
     * SpeechRecognizer class provides access to the speech recognition service.
     *
     *     @example
     *     const TextArea = require('@smartface/native/ui/textarea');
     *     const SpeechRecognizer = require("@smartface/native/speechrecognizer");
     *     const Application = require("@smartface/native/application");
     *     const Button = require('@smartface/native/ui/button');
     *     const System = require('@smartface/native/device/system');
     *     var myButton = new Button({
     *         height: 100,
     *         text: "Start Recording"
     *      })
     *     var myTextArea = new TextArea({
     *         height: 100
     *      })
     *     myButton.onPress = function() {
     *         if (!SpeechRecognizer.isRunning()) {
     *             myButton.text = "Stop Recording";
     *             if (System.OS === "iOS") {
     *                 startSpeechRecognizer();
     *             }
     *             else if (System.OS === "Android") {
     *                 const RECORD_AUDIO_CODE = 1002;
     *                 Application.android.requestPermissions(RECORD_AUDIO_CODE, Application.Android.Permissions.RECORD_AUDIO);
     *                 Application.android.onRequestPermissionsResult = function(e) {
     *                     if (e.requestCode === RECORD_AUDIO_CODE && e.result) {
     *                         startSpeechRecognizer();
     *                     }
     *                 }
     *             }
     *         }
     *         else {
     *             myButton.text = "Start Recording";
     *             SpeechRecognizer.stop();
     *         }
     *
     *     this.layout.addChild(myTextArea);
     *     this.layout.addChild(myButton)
     *     function startSpeechRecognizer() {
     *         SpeechRecognizer.start({
     *             locale : "en_US",
     *             onResult: function(result) {
     *                 myTextArea.text = result;
     *             },
     *             onFinish: function(result) {
     *                 myButton.text = "Start Recording";
     *                 alert("Finish : " + result);
     *             },
     *             onError: function(error) {
     *                 myButton.text = "Start Recording";
     *                 alert("Error : " + error);
     *             }
     *         });
     *     }
     *
     */
    export class SpeechRecognizerBase {
        /**
         * Starts speech recognition service. {@link Application.Android.Permissions#RECORD_AUDIO} is required for Android platform.
         *
         * @param {Object} params Object describing callbacks
         * @param {String} [params.locale] IETF language tag for example "en_US"
         * @param {Function} params.onResult Triggers when partial recognition results are available.
         * @param {String} params.onResult.result
         * @param {Function} params.onFinish Triggers when recognition result is ready.
         * @param {String} params.onFinish.result
         * @param {Function} params.onError This event is called after getting errors.
         * @param {SpeechRecognizer.Error} params.onError.error
         * @method start
         * @android
         * @ios
         * @since 1.1.13
         */
        static start(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): void;
        /**
         * Stop speech recognition service.
         *
         * @method stop
         * @android
         * @ios
         * @since 1.1.13
         */
        static stop(): void;
        /**
         * Returns whether speech recognition service runs or not.
         *
         * @method isRunning
         * @return {Boolean}
         * @android
         * @ios
         * @since 1.1.13
         */
        static isRunning(): boolean;
        static ios: Partial<{
            /**
             * Returns speech recognition supported locale or not supported. Locale parameter must be empty to check current locale.
             *
             * @param {String} IETF language tag for example "en_US"
             * @method isLocaleSupported
             * @return {Boolean}
             * @ios
             * @since 1.1.16
             */
            isLocaleSupported(locale: string): boolean;
        }>;
        static readonly Error: typeof SpeechRecognizerError & {
            android: typeof SpeechRecognizerAndroidError;
        };
    }
}
declare module "global/speechrecognizer/index" {
    import { SpeechRecognizerBase } from "global/speechrecognizer/speechrecognizer";
    const SpeechRecognizer: typeof SpeechRecognizerBase;
    type SpeechRecognizer = SpeechRecognizerBase;
    export default SpeechRecognizer;
}
declare module "global/asynctask/asynctask-events" {
    export const AsyncTaskEvents: {
        readonly Complete: "complete";
        readonly Cancelled: "cancelled";
        readonly PreExecute: "preExecute";
    };
    export type AsyncTaskEvents = ExtractValues<typeof AsyncTaskEvents>;
}
declare module "global/asynctask/asynctask" {
    import { IEventEmitter } from "core/eventemitter/index";
    import { INativeComponent } from "core/inative-component";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import { AsyncTaskEvents } from "global/asynctask/asynctask-events";
    export enum Status {
        /**
         * Indicates that onComplete has finished.
         *
         * @property FINISHED
         * @static
         * @readonly
         * @since 3.2.0
         */
        FINISHED = 0,
        /**
         * Indicates that the task has not been executed yet.
         *
         * @property PENDING
         * @static
         * @readonly
         * @since 3.2.0
         */
        PENDING = 1,
        /**
         * Indicates that the task is running.
         *
         * @property RUNNING
         * @static
         * @readonly
         * @since 3.2.0
         */
        RUNNING = 2
    }
    export interface IAsyncTaskAndroidProps {
        /**
         * Returns the current status of this task.
         *
         * @method getStatus
         * @android
         * @since 3.2.2
         * @return {AsyncTask.Android.Status} status
         */
        getStatus?: () => Status;
    }
    /**
     * @class AsyncTask
     * @since 3.1.0
     * AsyncTask enables proper and easy use of concurrency to improve speed and performance.
     *
     *     @example
     *     const AsyncTask = require("@smartface/native/asynctask");
     *     var asynctask = new AsyncTask();
     *     asynctask.task = function () {
     *         // do something
     *     };
     *     asynctask.onComplete = function () {
     *         console.log("AsyncTask is completed.");
     *     };
     *
     *     asynctask.run();
     */
    export interface IAsyncTask<TEvent extends string = AsyncTaskEvents, TMobile extends MobileOSProps<{}, IAsyncTaskAndroidProps> = MobileOSProps<{}, IAsyncTaskAndroidProps>> extends INativeComponent, IEventEmitter<TEvent | AsyncTaskEvents> {
        /**
         * This event describes task of AsyncTask instance.
         *
         * @event task
         * @android
         * @ios
         * @since 3.1.0
         */
        task: () => void;
        /**
         * This event invokes when task is completed.
         *
         * @event onComplete
         * @android
         * @ios
         * @deprecated
         * @since 3.1.0
         * @example
         * ````
         * import AsyncTask from '@smartface/native/global/asynctask';
         *
         * const task = new AsyncTask();
         * task.on(AsyncTask.Events.Complete, () => {
         * 	console.info('onComplete');
         * });
         * ````
         */
        onComplete: () => void;
        /**
         * Runs on the UI thread before onComplete.
         *
         * @method onPreExecute
         * @deprecated
         * @android
         * @since 3.2.2
         * @example
         * ````
         * import AsyncTask from '@smartface/native/global/asynctask';
         *
         * const task = new AsyncTask();
         * task.on(AsyncTask.Events.PreExecute, () => {
         * 	console.info('onPreExecute');
         * });
         * ````
         */
        onPreExecute: () => void;
        /**
         * Runs on the UI thread after cancel() is invoked
         *
         * @method onCancelled
         * @android
         * @deprecated
         * @ios
         * @since 3.2.2
         * @example
         * ````
         * import AsyncTask from '@smartface/native/global/asynctask';
         *
         * const task = new AsyncTask();
         * task.on(AsyncTask.Events.Cancelled, () => {
         * 	console.info('onCancelled');
         * });
         * ````
         */
        onCancelled: () => void;
        /**
         * Runs the task.
         *
         * @method run
         * @android
         * @ios
         * @since 3.1.0
         */
        run(): void;
        /**
         * Attempts to cancel execution of this task. For Android, This attempt will fail if the task has already completed,
         * already been cancelled, or could not be cancelled for some other reason. For Android, If successful,
         * and this task has not started when cancel is called, this task should never run. If the task has already started,
         * then the mayInterruptIfRunning parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task.
         *
         * @property cancel
         * @android
         * @ios
         * @since 3.2.2
         * @return {Boolean} false For Android, if the task could not be cancelled, typically because it has already completed normally; true otherwise.
         */
        cancel(): void;
        ios: TMobile['ios'];
        android: TMobile['android'];
    }
    export class AbstractAsyncTask<TEvent extends string = AsyncTaskEvents, TMobile extends MobileOSProps<{}, IAsyncTaskAndroidProps> = MobileOSProps<{}, IAsyncTaskAndroidProps>> extends NativeEventEmitterComponent<TEvent | AsyncTaskEvents, any, TMobile> implements IAsyncTask {
        task: () => void;
        onComplete: () => void;
        onPreExecute: () => void;
        onCancelled: () => void;
        getStatus?: () => Status;
        run(): void;
        cancel(): void;
        static readonly Android: {
            Status: Status;
        };
    }
}
declare module "global/asynctask/index" {
    import { AbstractAsyncTask } from "global/asynctask/asynctask";
    const AsyncTask: typeof AbstractAsyncTask;
    type AsyncTask = AbstractAsyncTask;
    export default AsyncTask;
}
declare module "global/crypto/rsa/rsa" {
    export class AbstractRSA {
        /**
         * Used to encrypt the provided content with given public key.
         *
         * @method encrypt
         * @param {Object} params
         * @param {string} params.plainText Text to encrypt
         * @param {string} params.key Public key in base64
         * @returns {string} Encrypted text which encoded with Base64
         * @ios
         * @android
         * @since 4.4
         */
        static encrypt: (params: {
            plainText: string;
            key: string;
            cipherType?: string;
        }) => string;
        /**
         * Used to decrypt the provided encrypted content with given private key.
         *
         * @method decrypt
         * @param {Object} params
         * @param {string} params.encryptedText Encrypted text to decrypt. Encoded with Base64.
         * @param {string} params.key Private key in base64
         * @returns {string} Decrypted text
         * @ios
         * @android
         * @since 4.4
         */
        static decrypt: (params: {
            encryptedText: string;
            key: string;
            cipherType?: string;
        }) => string;
        /**
         * Generates RSA private and public key.
         *
         * @method generateKeyPair
         * @param {Object} params
         * @param {number} [params.keySize=2048] Length of the key
         * @returns {Object} returns private/public key
         * @ios
         * @android
         * @since 4.4
         */
        static generateKeyPair: (params: {
            keySize: number;
        }) => string;
        static ios: {
            /**
             * On iOS, instead of using getBase64PublicString to retrieve generated public key, using this will yield better result.
             * @param {String} key RSA public key
             * @ios
             */
            getExportedPublicKey: (key: string) => string;
        };
    }
}
declare module "global/crypto/rsa/index" {
    import { AbstractRSA } from "global/crypto/rsa/rsa";
    const RSA: typeof AbstractRSA;
    type RSA = AbstractRSA;
    export default RSA;
}
declare module "global/crypto/aes/aes" {
    export class AbstractAES {
        /**
         * Used to encrypt the provided plain text with given parameters.
         *
         * @method encryptGCMAsync
         * @param {Object} params
         * @param {String} params.plainText Content to encrypt.
         * @param {String} params.key Secret AES key which is encoded with Bas64.
         * @param {Number} [params.ivSize = 16] The IV byte size to specify while encrypting the content with.
         * @param {Function} params.onComplete This event called when content encrypted successfully.
         * @param {String} params.onComplete.encryptedText Encrypted content in Base64.
         * @param {String} params.onComplete.iv IV which is generated during encryption procees. It is in Base64.
         * @param {Function} params.onFailure This event called when an exception occured while encrypting content.
         * @param {Function} params.onFailure.err Contains error message.
         * @ios
         * @android
         * @since 4.4
         */
        static encryptGCMAsync: (params: {
            plainText: string;
            key: string;
            ivSize: number;
            onComplete: (encryptedText: string, iv: string) => void;
            onFailure: (err: string) => void;
        }) => void;
        /**
         * Used to decrypt the provided encrypted text with given parameters.
         *
         * @method decryptGCMAsync
         * @param {Object} params
         * @param {String} params.encryptedText The content to decrypt which is in Base64.
         * @param {String} params.key Secret AES key which is encoded with Bas64.
         * @param {String} params.iv The IV in Base64.
         * @param {Function} params.onComplete This event called when content decrypted successfully.
         * @param {String} params.onComplete.plainText The decrypted plain content.
         * @param {Function} params.onFailure This event called when an exception occured while encrypting content.
         * @param {Function} params.onFailure.err Contains error message.
         * @ios
         * @android
         * @since 4.4
         */
        static decryptGCMAsync: (params: {
            encryptedText: string;
            key: string;
            iv: string;
            onComplete: (decryptedText: string) => void;
            onFailure: (err: string) => void;
        }) => void;
        /**
         * Used to generate secure random key with given size. Key could be one of 16, 24, or 32 bytes
         *
         * @method generateKey
         * @param {Number} [size = 32]
         * @ios
         * @android
         * @since 4.4
         */
        static generateKey: (length: number) => string;
    }
}
declare module "global/crypto/aes/index" {
    import { AbstractAES } from "global/crypto/aes/aes";
    const AES: typeof AbstractAES;
    type AES = AbstractAES;
    export default AES;
}
declare module "global/crypto/index" {
    const _default_1: {
        RSA: typeof import("global/crypto/rsa/rsa").AbstractRSA;
        AES: typeof import("global/crypto/aes/aes").AbstractAES;
    };
    export default _default_1;
}
declare module "global/index" {
    export { default as Blob } from "global/blob/index";
    export { default as Notifications } from "global/notifications/index";
    export { default as Timer } from "global/timer/index";
    export { default as Share } from "global/share/index";
    export { default as Data } from "global/data/index";
    export { default as SecureData } from "global/securedata/index";
    export { default as SpeechRecognizer } from "global/speechrecognizer/index";
    export { default as AsyncTask } from "global/asynctask/index";
    export { default as Crypto } from "global/crypto/index";
}
declare module "global/asynctask/asynctask.android" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import { IAsyncTask, IAsyncTaskAndroidProps, Status } from "global/asynctask/asynctask";
    import { AsyncTaskEvents } from "global/asynctask/asynctask-events";
    export class AsyncTaskAndroid<TEvent extends string = AsyncTaskEvents, TProps extends MobileOSProps<{}, IAsyncTaskAndroidProps> = MobileOSProps<{}, IAsyncTaskAndroidProps>> extends NativeEventEmitterComponent<TEvent | AsyncTaskEvents, any, TProps> implements IAsyncTask {
        static Events: {
            readonly Complete: "complete";
            readonly Cancelled: "cancelled";
            readonly PreExecute: "preExecute";
        };
        protected _android: any;
        private _task;
        constructor(params?: Partial<IAsyncTask>);
        private getAndroidProps;
        onComplete: () => void;
        onCancelled: () => void;
        onPreExecute: () => void;
        getStatus?: () => Status;
        get task(): () => void;
        set task(value: () => void);
        run(): void;
        cancel(mayInterruptIfRunning?: boolean): any;
        toString(): string;
    }
    export default AsyncTaskAndroid;
}
declare module "global/asynctask/asynctask.ios" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import { IAsyncTask, IAsyncTaskAndroidProps } from "global/asynctask/asynctask";
    import { AsyncTaskEvents } from "global/asynctask/asynctask-events";
    export class AsyncTaskIOS<TEvent extends string = AsyncTaskEvents, TProps extends MobileOSProps<{}, IAsyncTaskAndroidProps> = MobileOSProps<{}, IAsyncTaskAndroidProps>> extends NativeEventEmitterComponent<TEvent | AsyncTaskEvents, any, TProps> implements IAsyncTask {
        static Events: {
            readonly Complete: "complete";
            readonly Cancelled: "cancelled";
            readonly PreExecute: "preExecute";
        };
        constructor(params?: Partial<IAsyncTask>);
        task: () => void;
        onComplete: () => void;
        onCancelled: () => void;
        onPreExecute: () => void;
        run(): void;
        cancel(): void;
        toString(): string;
    }
    export default AsyncTaskIOS;
}
declare module "global/attributedstring/attributedstring.android" {
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { IAttributedString } from "global/attributedstring/attributedstring";
    class AttributedStringAndroid implements IAttributedString {
        private _string;
        private _foregroundColor;
        private _backgroundColor;
        private _font;
        private _underline;
        private _strikethrough;
        private _link?;
        private textView;
        ios: {};
        android: {};
        constructor(params?: Partial<IAttributedString>);
        nativeObject: {
            [key: string]: any;
        };
        get string(): string;
        set string(value: string);
        get font(): Font;
        set font(value: Font);
        get foregroundColor(): Color;
        set foregroundColor(value: Color);
        get underline(): boolean;
        set underline(value: boolean);
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        get backgroundColor(): Color;
        set backgroundColor(value: Color);
        get link(): string | undefined;
        set link(value: string | undefined);
        setSpan(stringBuilder: any): void;
    }
    export default AttributedStringAndroid;
}
declare module "global/attributedstring/attributedstring.ios" {
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { IAttributedString } from "global/attributedstring/attributedstring";
    class AttributedStringIOS implements IAttributedString {
        private _string;
        private _foregroundColor;
        private _underlineColor;
        private _strikethroughColor;
        private _backgroundColor;
        private _font;
        private _underline;
        private _strikethrough;
        private _link?;
        ios: {};
        android: {};
        constructor(params?: Partial<IAttributedString>);
        nativeObject: {
            [key: string]: any;
        };
        get string(): string;
        set string(value: string);
        get font(): Font;
        set font(value: Font);
        get foregroundColor(): Color;
        set foregroundColor(value: Color);
        get underline(): boolean;
        set underline(value: boolean);
        get strikethrough(): boolean;
        set strikethrough(value: boolean);
        get underlineColor(): Color;
        set underlineColor(value: Color);
        get strikethroughColor(): Color;
        set strikethroughColor(value: Color);
        get backgroundColor(): Color;
        set backgroundColor(value: Color);
        get link(): string | undefined;
        set link(value: string | undefined);
        setParams(params?: Partial<IAttributedString>): void;
        setOSSpecificParams(params: Partial<IAttributedString>, key: string): void;
    }
    export default AttributedStringIOS;
}
declare module "global/blob/blob.ios" {
    import { BlobBase } from "global/blob/blob";
    class BlobIOS extends BlobBase {
        constructor(parts: string[], properties?: {
            type: string;
        });
        get size(): any;
        toBase64(): any;
        toString(): any;
        toBase64Async(handlers: {
            onComplete: (base64: string) => void;
            onFailure?: (base64: string) => void;
        }): void;
        static __base64AddPadding(str: string): string;
        static createFromBase64(base64: string): BlobIOS;
        static createFromUTF8String(utf8String: string): BlobIOS;
    }
    export default BlobIOS;
}
declare module "global/crypto/aes/aes.android" {
    import { AbstractAES } from "global/crypto/aes/aes";
    class AESAndroid implements AbstractAES {
        static AESCrypto: any;
        static generateKey(length?: number): any;
        static encryptGCMAsync(params: {
            plainText: string;
            key: string;
            ivSize: number;
            onComplete: (encryptedText: string, iv: string) => void;
            onFailure: (err: string) => void;
        }): void;
        static decryptGCMAsync(params: {
            encryptedText: string;
            key: string;
            iv: string;
            onComplete: (decryptedText: string) => void;
            onFailure: (err: string) => void;
        }): void;
    }
    export default AESAndroid;
}
declare module "global/crypto/aes/aes.ios" {
    import { AbstractAES } from "global/crypto/aes/aes";
    class AESIOS implements AbstractAES {
        static SFCrypto: __SF_SMFCrypto;
        static generateKey(length?: number): any;
        static encryptGCMAsync(params: {
            plainText: string;
            key: string;
            ivSize: number;
            onComplete: (encryptedText: string, iv: string) => void;
            onFailure: (err: string) => void;
        }): void;
        static decryptGCMAsync(params: {
            encryptedText: string;
            key: string;
            iv: string;
            onComplete: (decryptedText: string) => void;
            onFailure: (err: string) => void;
        }): void;
    }
    export default AESIOS;
}
declare module "global/crypto/rsa/rsa.android" {
    import { AbstractRSA } from "global/crypto/rsa/rsa";
    class RSAAndroid implements AbstractRSA {
        static generateKeyPair(params: {
            keySize: number;
        }): {
            publicKey: any;
            privateKey: any;
        };
        static encrypt(params: {
            plainText: string;
            key: string;
            cipherType: string;
        }): any;
        static decrypt(params: {
            encryptedText: string;
            key: string;
            cipherType: string;
        }): any;
        static ios: {
            getExportedPublicKey(): void;
        };
    }
    export default RSAAndroid;
}
declare module "global/crypto/rsa/rsa.ios" {
    import { AbstractRSA } from "global/crypto/rsa/rsa";
    class RSAIOS implements AbstractRSA {
        static SFCrypto: __SF_SMFCrypto;
        static generateKeyPair(params: {
            keySize: number;
        }): any;
        static encrypt(params: {
            plainText: string;
            key: string;
        }): string;
        static decrypt(params: {
            encryptedText: string;
            key: string;
        }): string;
        static ios: {
            getExportedPublicKey(key: string): string;
        };
    }
    export default RSAIOS;
}
declare module "global/data/data.android" {
    import { BaseData } from "global/data/data";
    class DataAndroid implements BaseData {
        private static activity;
        private static jsSharedPreferences;
        static getStringVariable(key: string): any;
        getBooleanVariable(key: string): any;
        getIntVariable(key: string): any;
        getFloatVariable(key: string): any;
        getLongVariable(key: string): any;
        setStringVariable(key: string, value: string): void;
        setBooleanVariable(key: string, value: boolean): void;
        setIntVariable(key: string, value: number): void;
        setFloatVariable(key: string, value: number): void;
        setLongVariable(key: string, value: number): void;
        containsVariable(key: string): any;
        removeVariable(key: string): void;
        removeAllVariables(): void;
    }
    export default DataAndroid;
}
declare module "global/data/data.ios" {
    import { BaseData } from "global/data/data";
    class DataIOS implements BaseData {
        static ios: {
            getNativeObject(): __SF_NSUserDefaults;
        };
        static getStringVariable(key: string): any;
        static getBooleanVariable(key: string): null;
        static getIntVariable(key: string): null;
        static getFloatVariable(key: string): null;
        static getLongVariable(key: string): null;
        static setStringVariable(key: string, value: string): any;
        static setBooleanVariable(key: string, value: boolean): any;
        static setIntVariable(key: string, value: number): any;
        static setFloatVariable(key: string, value: number): any;
        static setLongVariable(key: string, value: number): any;
        static containsVariable(key: string): boolean | undefined;
        static removeVariable(key: string): any;
        static removeAllVariables(): any;
    }
    export default DataIOS;
}
declare module "io/path/index" {
    import { PathBase } from "io/path/path";
    const Path: typeof PathBase;
    type Path = PathBase;
    export default Path;
}
declare module "global/data/database/database" {
    import { INativeComponent } from "core/inative-component";
    import File from "io/file/index";
    /**
     * @class Data.Database
     * @since 1.0
     * @see https://hiddentao.com/squel/
     * @see https://sqlite.org/docs.html
     *
     * Database is query friendly persisted data interface for perfoming database operations using SQLite. You can open database
     * from assets or create/open database from file system. Also you can create in-memory database too.
     * We recommend to use Squel.js library for creating SQL Queries.
     *
     *
     *     @example
     *     const File = require("@smartface/native/io/file");
     *     const Database = require('@smartface/native/data').Database;
     *
     *     var database = new Database({
     *         file: new File({path: 'assets://database.sqlite'})
     *     });
     *
     *     // Creating person table
     *     database.execute("CREATE TABLE 'person' ( 'id' INTEGER, 'name' TEXT DEFAULT 'Smartface', 'age' INTEGER DEFAULT 5, 'isWorker' INTEGER DEFAULT 0, 'rate' REAL DEFAULT 2.5, PRIMARY KEY('id') )");
     *
     *     // Inserting values into person
     *     database.execute("INSERT INTO person (name, age, isWorker, rate) VALUES ('George', 47, 0, 1.2)");
     *     database.execute("INSERT INTO person (name, age, isWorker, rate) VALUES ('James', 40, 1, 3.4)");
     *     database.execute("INSERT INTO person (name, age, isWorker, rate) VALUES ('Alex', 25, 1, 1.7)");
     *
     *     // Getting workers count
     *     var queryResult = database.query("SELECT * FROM person WHERE(isWorker = 1)");
     *     console.log("Worker count is: " + queryResult.count());
     *
     */
    export interface IDatabase extends INativeComponent {
        /**
         * The file for creating/opening database from it. If the given file is Assets, the database will be open but if assets not exists the exception will thrown.
         * The parameter will setted if only given in constructor.
         *
         * @property {IO.File} file
         * @readonly
         * @android
         * @ios
         * @throws {Error}
         * @since 1.0
         */
        readonly file: File;
        /**
         * A boolean value that represents database object is in-memory or not. In-memory databases are a way faster than normal databases
         * but in-memory databases are temporary, you can not save them into a file. When database closes or application stopped, database
         * will be destroyed.
         * The parameter will setted if only given in constructor.
         *
         * @property {Boolean} inMemory
         * @readonly
         * @android
         * @ios
         * @throws {Error}
         * @see https://sqlite.org/inmemorydb.html
         * @see https://en.wikipedia.org/wiki/In-memory_database
         * @since 1.0
         */
        readonly inMemory: Boolean;
        /**
         * Close the database. You should close the database after you done your job.
         * If you don't, you will not open the database until close and will throw exception if you want to reopen it.
         *
         * @method close
         * @android
         * @ios
         * @throws {Error}
         * @since 1.0
         */
        close(): void;
        /**
         * Execute Non SELECT SQL Command on Database. Method will thrown exception when execution failed.
         *
         * @param {String} query
         * @method execute
         * @android
         * @ios
         * @throws {Error}
         * @see https://sqlite.org/lang.html
         * @since 1.0
         */
        execute(query: string): void;
        /**
         * Execute SELECT SQL Command on Database. Method will thrown exception when execution failed.
         *
         * @param {String} query
         * @return {Data.Database.QueryResult}
         * @method query
         * @android
         * @ios
         * @throws {Error}
         * @see https://sqlite.org/lang.html
         * @since 1.0
         */
        query(query: string): Database.QueryResult | undefined;
    }
    export class BaseDatabase implements IDatabase {
        constructor(params?: {
            file?: File;
            inMemory?: boolean;
        });
        file: File;
        inMemory: Boolean;
        close(): void;
        execute(query: string): void;
        query(query: string): Database.QueryResult | undefined;
        nativeObject: any;
    }
    export namespace Database {
        /**
         * @class Data.Database.QueryResult
         * @since 1.0
         *
         * An interface for collection of result of the Query.
         * You can not create instance from QueryResult, you should use {@link Data.Database#query Database.query}.
         *
         *     @example
         *     // Assuming Database and person table already created
         *     var rateGrater3Names = [];
         *     // Getting people who has rate grater than 3.
         *     var rateGrater3Result = database.query("SELECT * FROM person WHERE(rate > 3)");
         *     for(var i = 0; i < rateGrater3Result.count() ; i++){
         *         // Getting person name
         *         rateGrater3Names.push( rateGrater3Result.get(i).getString('name') );
         *     }
         */
        class QueryResult {
            constructor();
            /**
             * Returns the count of the query result.
             *
             * @method count
             * @return {Number}
             * @android
             * @ios
             * @since 1.0
             */
            count(): number;
            /**
             * Returns first match from Query. If no result match with Query, will return null.
             *
             * @method getFirst
             * @return {Data.Database.DatabaseObject}
             * @android
             * @ios
             * @since 1.0
             */
            getFirst(): DatabaseObject | null;
            /**
             * Returns last match from Query. If no result match with Query, will return null.
             *
             * @method getLast
             * @return {Data.Database.DatabaseObject}
             * @android
             * @ios
             * @since 1.0
             */
            getLast(): DatabaseObject | null;
            /**
             * Returns the element at the specified index in this query result. If index greater than count, it will throw exception
             *
             * @method get
             * @param {Number} index
             * @return {Data.Database.DatabaseObject}
             * @android
             * @ios
             * @throws {Error}
             * @since 1.0
             */
            get(index: number): DatabaseObject | null;
            android: Partial<{
                /**
                 * Closes the QueryResult, releasing all of its resources and making it completely invalid.
                 *
                 * @method close
                 * @android
                 * @since 4.0.2
                 */
                close(): void;
            }>;
        }
        /**
         * @class Data.Database.DatabaseObject
         * @since 1.0
         *
         * The one object from database. You can not create instance
         * from DatabaseObject, you should use {@link Data.Database.QueryResult#getFirst QueryResult.getFirst},
         * {@link Data.Database.QueryResult#getLast QueryResult.getLast} or {@link Data.Database.QueryResult#get QueryResult.get},
         *
         *     @example
         *     // Assuming Database and person table already created
         *     var selectedPeople = [];
         *     // Getting people who older than 15 years old and name begins with A.
         *     var selectedPeopleQueryResult = database.query("SELECT * FROM person WHERE(age > 25 AND name LIKE 'A%')");
         *     for(var i = 0; i < selectedPeopleQueryResult.count() ; i++){
         *         // Getting person
         *         var selectedPerson = selectedPeopleQueryResult.get(i);
         *         selectedPeople.push( {
         *             name: selectedPerson.getString('name'),
         *             age: selectedPerson.getInteger('age'),
         *             isWorker: selectedPerson.getInteger('isWorker'),
         *             rate: selectedPerson.getFloat('rate'),
         *         } );
         *     }
         */
        class DatabaseObject {
            constructor(params: {
                data: any;
                columnNames: string[];
            });
            /**
             * Returns given column name with String. If the given column is not String will thrown exception.
             *
             * @method getString
             * @param {String} columnName
             * @return {String}
             * @android
             * @ios
             * @throws {Error}
             * @since 1.0
             */
            getString(columnName: string): string;
            /**
             * Returns given column name with Integer. If the given column is not Integer will thrown exception.
             *
             * @method getInteger
             * @param {String} columnName
             * @return {Number}
             * @android
             * @ios
             * @throws {Error}
             * @since 1.0
             */
            getInteger(columnName: string): number;
            /**
             * Returns given column name with Boolean. If the given column is not Boolean will thrown exception.
             *
             * @method getBoolean
             * @param {String} columnName
             * @return {Boolean}
             * @android
             * @ios
             * @throws {Error}
             * @since 1.0
             */
            getBoolean(columnName: string): boolean;
            /**
             * Returns given column name with Float. If the given column is not Float will thrown exception.
             *
             * @method getFloat
             * @param {String} columnName
             * @return {Number}
             * @android
             * @ios
             * @throws {Error}
             * @since 1.0
             */
            getFloat(columnName: string): number;
        }
    }
}
declare module "global/data/database/database.android" {
    import NativeComponent from "core/native-component";
    import File from "io/file/index";
    import { Database, BaseDatabase } from "global/data/database/database";
    class DatabaseAndroid extends BaseDatabase {
        private _file;
        constructor(params?: {
            file?: File;
            inMemory?: boolean;
        });
        close(): void;
        execute(query: string): QueryResult | undefined;
        query(query: string): QueryResult | undefined;
        static QueryResult: typeof QueryResult;
        static DatabaseObject: typeof DatabaseObject;
    }
    export class QueryResult extends NativeComponent implements Database.QueryResult {
        constructor(params?: {
            isInternal: boolean;
            cursor: any;
        });
        count(): any;
        getFirst(): DatabaseObject;
        getLast(): DatabaseObject;
        get(location: number): DatabaseObject;
        android: {
            close(): void;
        };
    }
    export class DatabaseObject extends NativeComponent implements Database.DatabaseObject {
        constructor(params?: {
            isInternal: boolean;
            cursor: any;
        });
        getString(columnName: string): any;
        getInteger(columnName: string): any;
        getBoolean(columnName: string): any;
        getFloat(columnName: string): any;
    }
    export default DatabaseAndroid;
}
declare module "global/data/database/database.ios" {
    import { Database, BaseDatabase } from "global/data/database/database";
    import File from "io/file/index";
    class DatabaseIOS extends BaseDatabase {
        constructor(params?: {
            file?: File;
            inMemory?: boolean;
        });
        close(): void;
        execute(sqlCommand: string): void;
        query(query: string): QueryResult | undefined;
        static QueryResult: typeof QueryResult;
        static DatabaseObject: typeof DatabaseObject;
    }
    export class QueryResult implements Database.QueryResult {
        private _data;
        constructor(params?: {
            data: any;
        });
        android: {
            close(): void;
        };
        count(): any;
        getFirst(): DatabaseObject | null;
        getLast(): DatabaseObject | null;
        get(location: number): DatabaseObject | null;
    }
    export class DatabaseObject implements Database.DatabaseObject {
        private _data;
        private _columnNames;
        constructor(params?: {
            data: any;
            columnNames: string[];
        });
        getString(columnName: string): any;
        getInteger(columnName: string): any;
        getBoolean(columnName: string): any;
        getFloat(columnName: string): any;
        getData(columnName: string): any;
    }
    export default DatabaseIOS;
}
declare module "global/data/database/index" {
    import { BaseDatabase } from "global/data/database/database";
    const Database: typeof BaseDatabase;
    type Database = BaseDatabase;
    export default Database;
}
declare module "global/notifications/priority" {
    export enum Priority {
        MIN = -2,
        LOW = -1,
        DEFAULT = 0,
        HIGH = 1,
        MAX = 2
    }
}
declare module "global/notifications/notifications.android" {
    import { NotificationsBase } from "global/notifications/notifications";
    import { Priority } from "global/notifications/priority";
    class NotificationsAndroid implements NotificationsBase {
        readonly android: {};
        static ios: {
            authorizationStatus: {};
            getAuthorizationStatus(): void;
        };
        static iOS: {
            NotificationPresentationOptions: {};
        };
        static Android: {
            Priority: typeof Priority;
        };
        static Priority: typeof Priority;
        static Events: {
            readonly NotificationReceive: "notificationReceive";
            readonly NotificationClick: "notificationClick";
        };
        static _onNotificationClick: any;
        static _onNotificationReceive: any;
        EventFunctions: {
            notificationClick: () => void;
            notificationReceive: () => void;
        };
        static get onNotificationClick(): any;
        static set onNotificationClick(callback: any);
        static get onNotificationReceive(): any;
        static set onNotificationReceive(callback: any);
        cancelAllLocalNotifications(): void;
        removeAllDeliveredNotifications(): void;
        unregisterForPushNotifications(): void;
        registerForPushNotifications(onSuccess: any, onFailure: any): void;
    }
    export default NotificationsAndroid;
}
declare module "global/notifications/notifications.ios" {
    import NativeComponent from "core/native-component";
    import { NotificationsBase } from "global/notifications/notifications";
    class NotificationsIOS implements NotificationsBase {
        readonly android: {};
        static Events: {
            readonly NotificationReceive: "notificationReceive";
            readonly NotificationClick: "notificationClick";
        };
        static ios: typeof NotificationsBase.ios & {
            UNUserNotificationCenterDelegate: any;
            _didReceiveNotificationResponse: ((e: any) => void) | undefined;
            _willPresentNotification?: (e: any) => any;
        };
        static iOS: {
            AuthorizationStatus: {
                NOTDETERMINED: number;
                DENIED: number;
                AUTHORIZED: number;
            };
            NotificationPresentationOptions: {
                BADGE: number;
                SOUND: number;
                ALERT: number;
            };
        };
        EventFunctions: {
            notificationClick: () => void;
            notificationReceive: (value: any) => void;
        };
        get onNotificationReceive(): ((e: any) => any) | undefined;
        set onNotificationReceive(value: ((e: any) => any) | undefined);
        get onNotificationClick(): ((e: any) => void) | undefined;
        set onNotificationClick(value: ((e: any) => void) | undefined);
        get applicationIconBadgeNumber(): number;
        set applicationIconBadgeNumber(value: number);
        get scheduledLocalNotifications(): any[];
        unregisterForPushNotifications(): void;
        registerForPushNotifications(onSuccess: any, onFailure: any): void;
        static cancelAllLocalNotifications(): void;
        static Priority: {};
        static Android: {
            Priority: {};
        };
        static Notifications: {
            ios: {
                getAuthorizationStatus(callback: any): void;
            };
        };
        static removeAllDeliveredNotifications(): void;
        static LocalNotification: typeof LocalNotification;
    }
    class LocalNotification extends NativeComponent {
        private _ios;
        constructor(params?: any);
        get ios(): any;
        get alertBody(): string;
        set alertBody(value: string);
        get alertAction(): string;
        set alertAction(value: string);
        get sound(): string;
        set sound(value: string);
        get launchImage(): string;
        set launchImage(value: string);
        get fireDate(): any;
        set fireDate(value: any);
        get repeatInterval(): number;
        set repeatInterval(value: number);
        schedule(): void;
        present(): void;
        cancel(): void;
        android: {};
    }
    export default NotificationsIOS;
}
declare module "global/securedata/securedata.android" {
    import { AbstractSecureData } from "global/securedata/securedata";
    class SecureDataAndroid extends AbstractSecureData {
        service: string | undefined;
        constructor(params: {
            key: string;
        });
        get key(): string;
        read(): Promise<any>;
        save(params: any): Promise<void>;
        delete(): Promise<void>;
    }
    export default SecureDataAndroid;
}
declare module "global/securedata/securedata.ios" {
    import { AbstractSecureData } from "global/securedata/securedata";
    class SecureDataIOS extends AbstractSecureData {
        static _iOS: {
            _Message: {
                NOPASSWORD: string;
                UNEXPECTEDPASSWORDDATA: string;
                UNHANDLEDERROR: string;
            };
        };
        constructor(params?: {
            key: string;
            ios?: {
                service?: any;
            };
        });
        get service(): string | undefined;
        get key(): string;
        read(): Promise<any>;
        save(e: any): Promise<void>;
        delete(): Promise<void>;
    }
    export default SecureDataIOS;
}
declare module "global/share/share.android" {
    import Contacts from "device/contacts/index";
    import File from "io/file/index";
    import Image from "ui/image/index";
    import Page from "ui/page/index";
    import { ShareBase } from "global/share/share";
    export class ShareAndroid implements ShareBase {
        static shareText(text: string): void;
        static shareImage(image: Image): void;
        static shareFile(file: File): void;
        static share(params: {
            items: any[];
            page: Page;
            blacklist: string[];
        }): void;
        static shareContacts(params: {
            items: typeof Contacts.Contact[];
            fileName?: string;
            page: Page;
            blacklist: string[];
        }): void;
    }
    export default ShareAndroid;
}
declare module "global/share/share.ios" {
    import { INativeComponent } from "core/inative-component";
    import Contacts from "device/contacts/index";
    import File from "io/file/index";
    import Page from "ui/page/index";
    import { ShareBase } from "global/share/share";
    export class ShareIOS implements ShareBase {
        static ios__presentViewController(page: INativeComponent, activity: any): void;
        static createActivity(activityItems: any): __SF_NSOBject;
        static shareText(text: INativeComponent, page: Page, blacklist: string[]): void;
        static shareImage(): void;
        static shareContacts(object: {
            items: typeof Contacts.Contact[];
            fileName?: string;
            page: Page;
            blacklist: string[];
        }): void;
        static shareFile(file: File, page: Page, blacklist: string[]): void;
        static share(object: {
            items: INativeComponent[];
            page: Page;
            blacklist: string[];
        }): void;
        static ios: {
            Facebook: string;
            Twitter: string;
            Flickr: string;
            Message: string;
            Mail: string;
            Vimeo: string;
        };
    }
    export default ShareIOS;
}
declare module "global/speechrecognizer/speechrecognizer.android" {
    import { SpeechRecognizerAndroidError, SpeechRecognizerBase, SpeechRecognizerError } from "global/speechrecognizer/speechrecognizer";
    class SpeechRecognizerAndroid implements SpeechRecognizerBase {
        static speechRecognizer: any;
        static nativeObject: any;
        static _isRunning: boolean;
        static intent: any;
        static start(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): void;
        static create(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): void;
        static stop(): void;
        static isRunning(): boolean;
        static createRecognizerListener(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): any;
        static readonly Error: typeof SpeechRecognizerError & {
            android: typeof SpeechRecognizerAndroidError;
        };
        static ios: {
            isLocaleSupported(): void;
        };
    }
    export default SpeechRecognizerAndroid;
}
declare module "global/speechrecognizer/speechrecognizer.ios" {
    import { SpeechRecognizerAndroidError, SpeechRecognizerBase, SpeechRecognizerError } from "global/speechrecognizer/speechrecognizer";
    class SpeechRecognizerIOS implements SpeechRecognizerBase {
        static recognitionTask: any;
        static recognitionRequest: any;
        static avaudiosession: any;
        static avaudioengine: __SF_AVAudioEngine | undefined;
        static speechRecognizer: __SF_SFSpeechRecognizer | undefined;
        static speechDelegate: __SF_SFSpeechRecognizerDelegate;
        static start(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): void;
        static isRunning(): boolean;
        static stop(): void;
        static createRecognizer(params: {
            locale: string;
            onResult: (result: any) => void;
            onFinish: (result: any) => void;
            onError: (error: SpeechRecognizerError) => void;
        }): void;
        static onErrorHandler(error: any): void;
        static sendError(error: any): void;
        static ios: {
            isLocaleSupported(locale: string): boolean;
        };
        static readonly Error: typeof SpeechRecognizerError & {
            android: typeof SpeechRecognizerAndroidError;
        };
    }
    export default SpeechRecognizerIOS;
}
declare module "global/timer/timer.android" {
    import NativeComponent from "core/native-component";
    import { TimerBase } from "global/timer/timer";
    class TimerAndroid extends NativeComponent implements TimerBase {
        private repeat;
        private task;
        private delay;
        static handler: any;
        static setTimeout(params: {
            task: () => void;
            delay: number;
        }): TimerAndroid;
        static setInterval(params: {
            task: () => void;
            delay: number;
        }): TimerAndroid;
        static clearTimer(timer: TimerAndroid): void;
        static clearAllTimer(): void;
        constructor(params?: Partial<{
            task: () => void;
            repeat: boolean;
            delay: number;
        }>);
    }
    export default TimerAndroid;
}
declare module "global/timer/timer.ios" {
    import NativeComponent from "core/native-component";
    import { TimerBase } from "global/timer/timer";
    class TimerIOS extends NativeComponent implements TimerBase {
        static createTimer(params?: Partial<{
            task: () => void;
            repeat: boolean;
            delay: number;
        }>): __SF_Timer;
        static setTimeout(params: {
            task: () => void;
            delay: number;
        }): __SF_Timer;
        static setInterval(params: {
            task: () => void;
            delay: number;
        }): __SF_Timer;
        static clearTimer(timer: __SF_Timer): void;
        static clearAllTimer(): void;
        static timerArray: any[];
    }
    export default TimerIOS;
}
declare module "helper/getrippleeffect" {
    export function getRippleMask(borderRadius: any): any;
}
declare module "io/path/path.android" {
    import { AndroidProps, IPath, PathBase } from "io/path/path";
    export default class PathAndroid extends PathBase {
        constructor(params?: Partial<IPath>);
        static get ImagesUriScheme(): string;
        static get AssetsUriScheme(): string;
        static get Separator(): string;
        static get DataDirectory(): string;
        get android(): AndroidProps;
        resolve(path: string): any;
        getResolvedPath(path: any): any;
        private getExternalFilesDirPath;
        private getEmulatorAssetsPath;
        private getEmulatorDrawablePath;
        private getRauAssetsPath;
        private findDrawableAtDirectory;
        private checkDrawableVariations;
        private checkFileExistsInPath;
        private setScreenConfigs;
    }
}
declare module "io/file/file.android" {
    import FileStream from "io/filestream/index";
    import { IFile } from "io/file/file";
    import { FileContentMode, FileStreamType } from "io/filestream/filestream";
    import NativeComponent from "core/native-component";
    import { PATH_FILE_TYPE } from "io/path/path";
    export default class FileAndroid extends NativeComponent implements IFile {
        nativeAssetsList: any[];
        resolvedPath: any;
        type: PATH_FILE_TYPE;
        fullPath: string;
        drawableResourceId: number;
        ios: {
            getNSURL: () => __SF_NSURL;
        };
        private pathResolver;
        constructor(params?: Partial<IFile>);
        android: Partial<{}>;
        get creationDate(): number;
        get exists(): boolean;
        get extension(): string;
        get isDirectory(): boolean;
        get isFile(): boolean;
        get modifiedDate(): number;
        get name(): string;
        get parent(): FileAndroid | null;
        get path(): string;
        set path(value: string);
        get size(): number;
        get writable(): boolean;
        getAbsolutePath(): string;
        copy(destination: string): boolean;
        createFile(createParents: boolean): boolean;
        createDirectory(createParents: any): boolean;
        remove(withChilds?: boolean): boolean;
        getFiles(): IFile[] | null;
        move(destination: string): boolean;
        openStream(streamType: FileStreamType, contentMode: FileContentMode): FileStream | undefined;
        rename(newName: string): boolean;
        copyAssetFile(destinationFile: any, filename: any): void;
        copyDirectory(sourceDirectory: any, destinationDirectory: any): boolean;
        removeFile(fileToRemove: any, withChilds?: boolean): any;
        copyStream(sourceFileStream: any, destinationFileStream: any): void;
        copyFile(sourceFile: any, destinationFile: any): boolean;
    }
}
declare module "io/file/file.ios" {
    import { AbstractFile, FileParams, IFile } from "io/file/file";
    import FileStream from "io/filestream/index";
    import { FileContentMode, FileStreamType } from "io/filestream/filestream";
    export default class FileIOS extends AbstractFile implements IFile {
        fullPath: string;
        constructor(params?: Partial<IFile> & FileParams);
        static getDocumentsDirectory(): any;
        static getMainBundleDirectory(): any;
        getIOSParams(): {
            getNSURL: () => __SF_NSURL;
        };
        get creationDate(): any;
        get exists(): any;
        get extension(): any;
        get isDirectory(): any;
        get isFile(): any;
        get modifiedDate(): any;
        get name(): any;
        get parent(): FileIOS;
        get size(): any;
        get writable(): any;
        get path(): any;
        set path(value: any);
        copy(destination: string): boolean;
        createDirectory(createParents: boolean): boolean;
        createFile(createParents: boolean): boolean;
        remove(withChilds: boolean): boolean;
        getFiles(): IFile[];
        move(destination: string): boolean;
        rename(newName: string): boolean;
        openStream(streamType: FileStreamType, contentMode: FileContentMode): FileStream | undefined;
        getAbsolutePath(): string;
    }
}
declare module "io/filestream/filestream.android" {
    import Blob from "global/blob/index";
    import { IFileStream, FileStreamType, FileContentMode, FileStreamParams } from "io/filestream/filestream";
    import NativeComponent from "core/native-component";
    export class FileStreamAndroid extends NativeComponent implements IFileStream {
        private _fileObject;
        private _mode;
        private _contentMode;
        private _closed;
        constructor(params: FileStreamParams);
        offset: number;
        static StreamType: {
            hasValue: (valueToFind: number) => boolean;
            APPEND: FileStreamType.APPEND;
            READ: FileStreamType.READ;
            WRITE: FileStreamType.WRITE;
        };
        static ContentMode: {
            hasValue: (valueToFind: number) => boolean;
            TEXT: FileContentMode.TEXT;
            BINARY: FileContentMode.BINARY;
        };
        static create(path: any, streamMode: any, contentMode: number): FileStreamAndroid | undefined;
        get mode(): FileStreamType;
        get contentMode(): FileContentMode;
        get isReadable(): boolean;
        get isWritable(): boolean;
        get name(): string;
        get path(): string;
        close(): void;
        readBlob(): Blob;
        readToEnd(): string | Blob;
        write(data: string | Blob): boolean;
        seekToEnd(): void;
    }
}
declare module "io/filestream/filestream.ios" {
    import NativeComponent from "core/native-component";
    import Blob from "global/blob/index";
    import { FileContentMode, FileStreamType, IFileStream } from "io/filestream/filestream";
    export default class FileStreamIOS extends NativeComponent implements IFileStream {
        static create(path: any, streamMode: any, contentMode: number): FileStreamIOS;
        get mode(): FileStreamType;
        get contentMode(): FileContentMode;
        get isReadable(): boolean;
        get isWritable(): boolean;
        get name(): string;
        get path(): string;
        get offset(): number;
        set offset(value: number);
        close(): void;
        readBlob(): Blob;
        readToEnd(): string | Blob;
        write(content: string | Blob): boolean;
        seekToEnd(): void;
        static StreamType: typeof FileStreamType;
        static ContentMode: typeof FileContentMode;
    }
}
declare module "io/path/path.ios" {
    import { IPath, PathBase } from "io/path/path";
    export default class PathIOS extends PathBase {
        constructor(params?: Partial<IPath>);
        get ImagesUriScheme(): string;
        get AssetsUriScheme(): string;
        get Separator(): string;
        get DataDirectory(): string;
        get android(): any;
    }
}
declare module "net/websocket/websocket-events" {
    export const WebSocketEvents: {
        readonly Close: "close";
        readonly Failure: "failure";
        readonly Message: "message";
        readonly Open: "open";
    };
    export type WebSocketEvents = ExtractValues<typeof WebSocketEvents>;
}
declare module "net/websocket/websocket" {
    import Blob from "global/blob/index";
    import { INativeComponent } from "core/inative-component";
    import { IEventEmitter } from "core/eventemitter/event-emitter";
    import { WebSocketEvents } from "net/websocket/websocket-events";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import { BlobBase } from "global/blob/blob";
    export interface IWebSocket extends INativeComponent, IEventEmitter<WebSocketEvents> {
        /**
         * Gets headers of socket connection.
         * If you want to change the headers, you have to call the constructor again (create a new instance).
         *
         * @property {Object} headers
         * @readonly
         * @android
         * @ios
         * @since 1.1.17
         */
        headers: Record<string, string>;
        /**
         * Gets url of socket connection.
         * If you want to change the URL, you have to call the constructor again (create a new instance).
         *
         * @property {String} url
         * @readonly
         * @android
         * @ios
         * @since 1.1.17
         */
        url: string;
        /**
         * Close the web socket.
         * @param {Object} params
         * @param {Number} params.code
         * @param {String} [params.reason]
         * @since 1.1.17
         */
        close(params: {
            code: number;
            reason?: string;
        }): void;
        /**
         * Send data to a web socket server.
         * @param {Object} params
         * @param {String|Blob} params.data
         * @return {Boolean}
         * @since 1.1.17
         */
        send(params: {
            data: string | Blob;
        }): boolean;
        /**
         * Invoked when a web socket has been accepted by the web socket server.
         * @event
         * @deprecated
         * @since 1.1.17
         * @example
         * ````
         * import WebSocket from '@smartface/native/net/websocket';
         *
         * const webSocket = new WebSocket();
         * webSocket.on(WebSocket.Events.Open, () => {
         *  console.info('onOpen');
         * });
         * ````
         */
        onOpen(): void;
        /**
         * Invoked when a message has been received.
         * @param {Object} params
         * @param {String} params.string
         * @param {Blob} params.blob
         * @deprecated
         * @event
         * @since 1.1.17
         * @example
         * ````
         * import WebSocket from '@smartface/native/net/websocket';
         *
         * const webSocket = new WebSocket();
         * webSocket.on(WebSocket.Events.Message, (params) => {
         *  console.info('onMessage', params);
         * });
         * ````
         */
        onMessage(e: {
            string?: string;
            blob?: Blob;
        }): void;
        /**
         * Invoked when the web socket has been closed.
         * @param {Object} e
         * @param {Number} e.code
         * @param {String} e.reason
         * @deprecated
         * @event
         * @since 1.1.17
         * @example
         * ````
         * import WebSocket from '@smartface/native/net/websocket';
         *
         * const webSocket = new WebSocket();
         * webSocket.on(WebSocket.Events.Close, (params) => {
         *  console.info('onClose', params);
         * });
         * ````
         */
        onClose(e: {
            code: number;
            reason: string;
        }): void;
        /**
         * Invoked when an error occured on reading or writing to the network.
         * @param {Object} e
         * @param {String} e.message
         * @param {Number} e.code
         * @deprecated
         * @event
         * @since 1.1.17
         * @example
         * ````
         * import WebSocket from '@smartface/native/net/websocket';
         *
         * const webSocket = new WebSocket();
         * webSocket.on(WebSocket.Events.Failure, (params) => {
         *  console.info('onFailure', params);
         * });
         * ````
         */
        onFailure(e: {
            code: number;
            message: string;
        }): void;
    }
    export abstract class WebSocketBase<TEvent extends string = WebSocketEvents, TMobile extends MobileOSProps = MobileOSProps> extends NativeEventEmitterComponent<TEvent | WebSocketEvents, any, TMobile> implements IWebSocket {
        constructor(params?: TMobile);
        headers: Record<string, string>;
        get url(): string;
        set url(value: string);
        close(params: {
            code: number;
            reason?: string | undefined;
        }): void;
        send(params: {
            data: string | BlobBase;
        }): boolean;
        onOpen(): void;
        onMessage(e: {
            string?: string | undefined;
            blob?: BlobBase | undefined;
        }): void;
        onClose(e: {
            code: number;
            reason: string;
        }): void;
        onFailure(e: {
            code: number;
            message: string;
        }): void;
    }
}
declare module "net/websocket/index" {
    import { WebSocketBase } from "net/websocket/websocket";
    const WebSocket: typeof WebSocketBase;
    type WebSocket = WebSocketBase;
    export default WebSocket;
}
declare module "net/index" {
    export { default as Http } from "net/http/index";
    export { default as WebSocket } from "net/websocket/index";
}
declare module "net/http/http.android" {
    import { HttpBase, HttpRequest, IHttp } from "net/http/http";
    export default class HttpAndroid extends HttpBase {
        private _clientBuilder;
        private _timeout;
        private _defaultHeaders;
        private _cookiePersistenceEnabled;
        private _client;
        constructor(params?: Partial<IHttp>);
        get timeout(): number;
        set timeout(value: number);
        get headers(): Record<string, string>;
        set headers(value: Record<string, string>);
        get cookiePersistenceEnabled(): boolean;
        set cookiePersistenceEnabled(value: boolean);
        static cancelAll(): void;
        cancelAll(): void;
        upload(params: Parameters<IHttp['upload']>['0']): HttpRequest;
        requestString(params: Parameters<IHttp['requestString']>['0']): HttpRequest;
        requestImage(params: Parameters<IHttp['requestImage']>['0']): HttpRequest;
        requestJSON(params: Parameters<IHttp['requestJSON']>['0']): HttpRequest;
        requestFile(params: Parameters<IHttp['requestFile']>['0']): HttpRequest;
        request(params: Parameters<IHttp['request']>['0'], isMultipart?: boolean): HttpRequest;
        private createRequest;
        createRequestBody(body: any, contentType: any, isMultipart: any): any;
        createMultipartBody(bodies: any): any;
        getResponseHeaders(headers: any): {};
        checkInternet(): boolean;
    }
}
declare module "net/http/http.ios" {
    import { HttpBase, HttpRequest, IHttp } from "net/http/http";
    export default class HttpIOS extends HttpBase {
        cookiePersistenceEnabled: boolean;
        private _sslPinning;
        constructor(params?: Partial<IHttp>);
        private getIOSProps;
        get timeout(): number;
        set timeout(value: number);
        get headers(): {
            [key: string]: string;
        };
        set headers(value: {
            [key: string]: string;
        });
        cancelAll(): void;
        requestFile(params: Parameters<IHttp['requestFile']>['0']): HttpRequest;
        requestImage(params: Parameters<IHttp['requestImage']>['0']): HttpRequest;
        requestString(params: Parameters<IHttp['requestString']>['0']): HttpRequest;
        requestJSON(params: Parameters<IHttp['requestJSON']>['0']): HttpRequest;
        request(params: Parameters<IHttp['request']>['0']): HttpRequest;
        upload(params: Parameters<IHttp['upload']>['0']): HttpRequest;
    }
}
declare module "net/websocket/websocket.android" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { IWebSocket, WebSocketBase } from "net/websocket/websocket";
    import { WebSocketEvents } from "net/websocket/websocket-events";
    export default class WebSocketAndroid<TEvent extends string = WebSocketEvents, TProps extends MobileOSProps = MobileOSProps> extends WebSocketBase<TEvent | WebSocketEvents, TProps> {
        private _listener;
        private _request;
        private _client;
        private _url;
        constructor(params?: TProps & Partial<IWebSocket>);
        get url(): string;
        createClientAndRequest(): void;
        createWebSocketListener(): void;
        close(params: Parameters<IWebSocket['close']>['0']): void;
        send(params: Parameters<IWebSocket['send']>['0']): any;
    }
}
declare module "net/websocket/websocket.ios" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { Invocation } from "util/index";
    import { WebSocketBase } from "net/websocket/websocket";
    import { WebSocketEvents } from "net/websocket/websocket-events";
    export default class WebSocketIOS<TEvent extends string = WebSocketEvents, TProps extends MobileOSProps = MobileOSProps> extends WebSocketBase<TEvent | WebSocketEvents, TProps> {
        private delegateInstance;
        private socket;
        constructor(params?: TProps);
        get url(): string;
        onOpen(): void;
        close(params: {
            code: number;
            reason?: string;
        }): void;
        send(params: {
            data: any;
        }): boolean;
        getHeaderKeyValue(key: string, value: any): Invocation.Argument[];
    }
}
declare module "primitive/boundary" {
    export type Boundary = {
        top?: number;
        left?: number;
        bottom?: number;
        right?: number;
    };
}
declare module "primitive/iflexlayout" {
    import FlexLayout from "ui/flexlayout/index";
    export interface ILayoutable {
        readonly layout: FlexLayout;
    }
}
declare module "primitive/position" {
    export type Position = {
        top?: number;
        left?: number;
        bottom?: number;
        right?: number;
    };
}
declare module "ui/shared/ios/contentinsetadjustment" {
    /**
     * Constants indicating how safe area insets are added to the adjusted content inset.
     * @ios
     * @since 4.0.0
     */
    enum ContentInsetAdjustment {
        /**
         * Automatically adjust the scroll view insets.
         * @ios
         * @since 4.0.0
         */
        AUTOMATIC = 0,
        /**
         * Adjust the insets only in the scrollable directions.
         * @ios
         * @since 4.0.0
         */
        SCROLLABLEAXES = 1,
        /**
         * Do not adjust the scroll view insets.
         * @ios
         * @since 4.0.0
         */
        NEVER = 2,
        /**
         * Always include the safe area insets in the content adjustment.
         * @ios
         * @since 4.0.0
         */
        ALWAYS = 3
    }
    export default ContentInsetAdjustment;
}
declare module "ui/view/view.ios" {
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import { ViewEvents } from "ui/view/view-event";
    import View, { IView, IViewProps, ViewBase } from "ui/view/index";
    export default class ViewIOS<TEvent extends string = ViewEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TProps extends IViewProps = IViewProps> extends ViewBase<TEvent, TNative, TProps> implements IView {
        protected _uniqueId: string;
        protected _maskedBorders: number[];
        protected _nativeObject: any;
        private _rotation;
        private _rotationX;
        private _rotationY;
        private _scale;
        onTouchHandler: (e: {
            point: Point2D;
        }) => void;
        onTouchEndedHandler: (e?: {
            point: Point2D;
        } | undefined) => void;
        onTouchCancelledHandler: (e?: {
            point: Point2D;
        } | undefined) => void;
        onTouchMovedHandler: (e?: {
            point: Point2D;
        } | undefined) => void;
        gradientColor: any;
        private _parent?;
        static Border: {
            readonly TOP_LEFT: number;
            readonly TOP_RIGHT: number;
            readonly BOTTOM_LEFT: number;
            readonly BOTTOM_RIGHT: number;
        };
        constructor(params?: Partial<TProps>);
        get uniqueId(): string;
        get parent(): View | undefined;
        set parent(view: View | undefined);
        get accessibilityLabel(): string;
        set accessibilityLabel(value: string);
        get accessible(): boolean;
        set accessible(value: boolean);
        private get shadowOffset();
        private set shadowOffset(value);
        private get shadowRadius();
        private set shadowRadius(value);
        private get shadowOpacity();
        private set shadowOpacity(value);
        private get shadowColor();
        private set shadowColor(value);
        private get exclusiveTouch();
        private set exclusiveTouch(value);
        get masksToBounds(): boolean;
        set masksToBounds(value: boolean);
        private get clipsToBounds();
        private set clipsToBounds(value);
        get borderColor(): Color;
        set borderColor(value: Color);
        get alpha(): any;
        set alpha(value: any);
        get borderRadius(): any;
        set borderRadius(value: any);
        get maskedBorders(): number[];
        set maskedBorders(value: number[]);
        get backgroundColor(): IView['backgroundColor'];
        set backgroundColor(value: IView['backgroundColor']);
        get id(): any;
        set id(value: any);
        get transitionId(): any;
        set transitionId(value: any);
        get rotation(): number;
        set rotation(value: number);
        get rotationX(): number;
        set rotationX(value: number);
        get rotationY(): number;
        set rotationY(value: number);
        get visible(): any;
        set visible(value: any);
        get scale(): Point2D;
        set scale(value: Point2D);
        get touchEnabled(): any;
        set touchEnabled(value: any);
        getPosition(): {
            left: any;
            top: any;
            width: any;
            height: any;
        };
        flipHorizontally(): void;
        flipVertically(): void;
        setPosition(position: any): void;
        bringToFront(): void;
        getParent(): View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>> | null;
        getScreenLocation(): Point2D;
        get onTouch(): (e?: Point2D | undefined) => boolean | void;
        set onTouch(value: (e?: Point2D | undefined) => boolean | void);
        get onTouchEnded(): (isInside: boolean, point: Point2D) => boolean | void;
        set onTouchEnded(value: (isInside: boolean, point: Point2D) => boolean | void);
        get onTouchMoved(): (e: boolean | {
            isInside: boolean;
        }, point?: Point2D | undefined) => boolean | void;
        set onTouchMoved(value: (e: boolean | {
            isInside: boolean;
        }, point?: Point2D | undefined) => boolean | void);
        get onTouchCancelled(): (point: Point2D) => boolean | void;
        set onTouchCancelled(value: (point: Point2D) => boolean | void);
        get isIncludedInLayout(): any;
        set isIncludedInLayout(value: any);
        get flexEnabled(): any;
        set flexEnabled(value: any);
        get direction(): any;
        set direction(value: any);
        get flexDirection(): any;
        set flexDirection(value: any);
        get justifyContent(): any;
        set justifyContent(value: any);
        get alignContent(): any;
        set alignContent(value: any);
        get alignItems(): any;
        set alignItems(value: any);
        get alignSelf(): any;
        set alignSelf(value: any);
        get positionType(): any;
        set positionType(value: any);
        get flexWrap(): any;
        set flexWrap(value: any);
        get display(): any;
        set display(value: any);
        get flexGrow(): any;
        set flexGrow(value: any);
        get flexShrink(): any;
        set flexShrink(value: any);
        get flexBasis(): any;
        set flexBasis(value: any);
        get left(): any;
        set left(value: any);
        get top(): any;
        set top(value: any);
        get right(): any;
        set right(value: any);
        get bottom(): any;
        set bottom(value: any);
        get marginLeft(): any;
        set marginLeft(value: any);
        get marginTop(): any;
        set marginTop(value: any);
        get marginRight(): any;
        set marginRight(value: any);
        get marginBottom(): any;
        set marginBottom(value: any);
        get marginStart(): any;
        set marginStart(value: any);
        get marginEnd(): any;
        set marginEnd(value: any);
        get marginHorizontal(): any;
        set marginHorizontal(value: any);
        get marginVertical(): any;
        set marginVertical(value: any);
        get margin(): any;
        set margin(value: any);
        get paddingLeft(): any;
        set paddingLeft(value: any);
        get paddingTop(): any;
        set paddingTop(value: any);
        get paddingRight(): any;
        set paddingRight(value: any);
        get paddingBottom(): any;
        set paddingBottom(value: any);
        get paddingStart(): any;
        set paddingStart(value: any);
        get paddingEnd(): any;
        set paddingEnd(value: any);
        get paddingHorizontal(): any;
        set paddingHorizontal(value: any);
        get paddingVertical(): any;
        set paddingVertical(value: any);
        get padding(): any;
        set padding(value: any);
        get borderLeftWidth(): any;
        set borderLeftWidth(value: any);
        get borderTopWidth(): any;
        set borderTopWidth(value: any);
        get borderRightWidth(): any;
        set borderRightWidth(value: any);
        get borderBottomWidth(): any;
        set borderBottomWidth(value: any);
        get borderStartWidth(): any;
        set borderStartWidth(value: any);
        get borderEndWidth(): any;
        set borderEndWidth(value: any);
        get borderWidth(): any;
        set borderWidth(value: any);
        get width(): any;
        set width(value: any);
        get height(): any;
        set height(value: any);
        get minWidth(): any;
        set minWidth(value: any);
        get minHeight(): any;
        set minHeight(value: any);
        get maxWidth(): any;
        set maxWidth(value: any);
        get maxHeight(): any;
        set maxHeight(value: any);
        get testId(): any;
        set testId(value: any);
        get aspectRatio(): any;
        set aspectRatio(value: any);
        get resolvedDirection(): any;
        applyLayout(): void;
        get intrinsicSize(): any;
        get numberOfChildren(): any;
        get isLeaf(): any;
        dirty(): void;
        static readonly ios: {
            viewAppearanceSemanticContentAttribute: number;
            performWithoutAnimation(functionWithoutAnimation: any): void;
        };
        static readonly iOS: {
            SemanticContentAttribute: {
                readonly AUTO: 0;
                readonly FORCELEFTTORIGHT: 3;
                readonly FORCERIGHTTOLEFT: 4;
            };
        };
    }
}
declare module "ui/viewgroup/viewgroup.ios" {
    import { IViewGroup } from "ui/viewgroup/index";
    import { ExtractEventValues } from "core/eventemitter/extract-event-values";
    import { IView } from "ui/view/index";
    import View from "ui/view/view.ios";
    import { ViewGroupEvents } from "ui/viewgroup/viewgroup-events";
    /**
     * @class UI.ViewGroup
     * @since 0.1
     * @extends View
     * A ViewGroup is a special view that can contain other views (called children) like layouts and views.
     * ViewGroup is an abstract class. You can't create instance from it.
     */
    export default class ViewGroupIOS<TEvent extends string = ViewGroupEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TProps extends IViewGroup = IViewGroup> extends View<ViewGroupEvents | ExtractEventValues<TEvent>, TNative, TProps> implements IViewGroup {
        private _children;
        onViewRemovedInnerCallback: IViewGroup['onViewRemoved'];
        onViewAddedInnerCallback: IViewGroup['onViewAdded'];
        onChildViewAdded: IViewGroup['onViewAdded'];
        onChildViewRemoved: IViewGroup['onViewRemoved'];
        constructor(params?: Partial<TProps>);
        onViewAdded: (view: IView) => void;
        onViewRemoved: (view: IView) => void;
        addChild(view: IView): void;
        removeChild(view: View): void;
        removeAll(): void;
        getChildCount(): number;
        getChildList(): IView<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>[];
        findChildById(id: string): any;
        onViewAddedHandler(e: __SF_UIView): void;
        onViewRemovedHandler(e: __SF_UIView): void;
    }
}
declare module "ui/scrollview/scrollview-events" {
    export const ScrollViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly ViewAdded: "viewAdded";
        readonly ViewRemoved: "viewRemoved";
        readonly Scroll: "scroll";
        readonly ScrollBeginDecelerating: "scrollBeginDecelerating";
        readonly ScrollBeginDragging: "scrollBeginDragging";
        readonly ScrollEndDecelerating: "scrollEndDecelerating";
        readonly ScrollEndDraggingWillDecelerate: "scrollEndDraggingWillDecelerate";
        readonly ScrollEndDraggingWithVelocityTargetContentOffset: "scrollEndDraggingWithVelocityTargetContentOffset";
    };
    export type ScrollViewEvents = ExtractValues<typeof ScrollViewEvents>;
}
declare module "ui/scrollview/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import FlexLayout from "ui/flexlayout/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import ContentInsetAdjustment from "ui/shared/ios/contentinsetadjustment";
    import { AbstractViewGroup, IViewGroup } from "ui/viewgroup/index";
    import ViewGroupIOS from "ui/viewgroup/viewgroup.ios";
    import { ScrollViewEvents } from "ui/scrollview/scrollview-events";
    export enum ScrollViewAlign {
        VERTICAL = "verticall",
        HORIZONTAL = "horizontal"
    }
    export enum ScrollViewEdge {
        LEFT = "left",
        TOP = "top",
        RIGHT = "right",
        BOTTOM = "bottom"
    }
    type IScrollViewIOS = ViewGroupIOS & Partial<{
        decelerationRate: number;
        /**
         * If the value of this property is YES , scrolling is enabled, and if it is NO , scrolling is disabled. The default is YES.
         *
         * @property {Boolean} [scrollEnabled = true]
         * @ios
         * @since 3.1.3
         */
        scrollEnabled: boolean;
        /**
         * Sets/Gets the bounce effect when scrolling.
         *
         * @property {Boolean} bounces
         * @ios
         * @since 3.2.1
         */
        bounces: boolean;
        /**
         * The behavior for determining the adjusted content offsets.
         *
         * @property {UI.iOS.ContentInsetAdjustment} [contentInsetAdjustmentBehavior = UI.iOS.ContentInsetAdjustment.NEVER]
         * @ios
         * @since 4.0.0
         */
        contentInsetAdjustmentBehavior: ContentInsetAdjustment;
        /**
         * This event is called when the scroll view is about to start scrolling the content.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDragging
         * @ios
         * @since 3.2.1
         * @deprecated
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.ScrollBeginDragging, (params) => {
         * 	console.info('onScrollBeginDragging', params);
         * });
         * ````
         */
        onScrollBeginDragging: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when the scroll view is starting to decelerate the scrolling movement.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDecelerating
         * @ios
         * @since 3.2.1
         * @deprecated
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.ScrollBeginDecelerating, (params) => {
         * 	console.info('onScrollBeginDecelerating', params);
         * });
         * ````
         */
        onScrollBeginDecelerating: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when the scroll view has ended decelerating the scrolling movement.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollEndDecelerating
         * @ios
         * @since 3.2.1
         * @deprecated
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.ScrollEndDecelerating, (params) => {
         * 	console.info('onScrollEndDecelerating', params);
         * });
         * ````
         */
        onScrollEndDecelerating: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when dragging ended in the scroll view.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @param {Boolean} decelerate
         * @event onScrollEndDraggingWillDecelerate
         * @ios
         * @since 3.2.1
         * @deprecated
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.ScrollEndDraggingWillDecelerate, (params) => {
         * 	console.info('onScrollEndDraggingWillDecelerate', params);
         * });
         * ````
         */
        onScrollEndDraggingWillDecelerate: (contentOffset: __SF_NSRect, decelerate: boolean) => void;
        /**
         * This event is called when the user finishes scrolling the content.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @param {Object} velocity
         * @param {Number} velocity.x
         * @param {Number} velocity.y
         * @param {Object} targetContentOffset
         * @param {Number} targetContentOffset.x
         * @param {Number} targetContentOffset.y
         * @event onScrollEndDraggingWithVelocityTargetContentOffset
         * @ios
         * @since 3.2.1
         * @deprecated
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.ScrollEndDraggingWithVelocityTargetContentOffset, (params) => {
         * 	console.info('onScrollEndDraggingWithVelocityTargetContentOffset', params);
         * });
         * ````
         */
        onScrollEndDraggingWithVelocityTargetContentOffset: (contentOffset: __SF_NSRect, velocity: __SF_NSRect, targetContentOffset: Point2D) => void;
    }>;
    /**
     * @class UI.ScrollView
     * @extends UI.ViewGroup
     * @since 0.1
     *
     * ScrollView enables user to view pages with large content exceeding screen size via scroll action.
     * ScrollView can have only one child layout. The layout should be added if there are child views more
     * than one.
     *
     *     @example
     *     const FlexLayout = require('@smartface/native/ui/flexlayout');
     *     const ScrollView = require('@smartface/native/ui/scrollview');
     *     const Button = require('@smartface/native/ui/button');
     *     const Color = require('@smartface/native/ui/color');
     *
     *     var scrollView = new ScrollView({
     *        flexGrow: 1,
     *        backgroundColor: Color.GREEN,
     *        alignSelf: FlexLayout.AlignSelf.STRETCH
     *     });
     *     scrollView.layout.height = 2000;
     *     scrollView.layout.backgroundColor = Color.RED;
     *     scrollView.layout.alignItems = FlexLayout.AlignItems.CENTER;
     *     var buttonTop = new Button({
     *       height: 100,
     *       width: 100,
     *       top:10,
     *       text: "Scroll to 1100",
     *       backgroundColor: Color.BLUE,
     *       onPress: function(){
     *           scrollView.scrollToCoordinate(1100);
     *       }
     *     });
     *     var buttonBottom = new Button({
     *       height: 100,
     *       width: 100,
     *       top: 1000,
     *       text: "Scroll to 10",
     *       backgroundColor: Color.BLUE,
     *       onPress: function(){
     *           scrollView.scrollToCoordinate(10);
     *       }
     *     });
     *     scrollView.layout.addChild(buttonTop);
     *     scrollView.layout.addChild(buttonBottom);
     */
    export interface IScrollView<TEvent extends string = ScrollViewEvents, TMobile extends MobileOSProps<IScrollViewIOS, {}> = MobileOSProps<IScrollViewIOS, {}>> extends IViewGroup<TEvent | ScrollViewEvents, any, TMobile> {
        /**
         * Gets/sets over-scroll mode for this view.
         *
         * @property {UI.Android.OverScrollMode} [overScrollMode = UI.Android.OverScrollMode.ALWAYS]
         * @android
         * @since 3.0.2
         */
        overScrollMode: OverScrollMode;
        /**
         * Gets/sets the alignment of the scrollview. If alignment is HORIZONTAL, the ScrollView
         * will scroll horizontally, otherwise will scroll vertically.
         * It must be set as constructor parameter. This property cannot be set after the object is initialized.
         *
         * @property {UI.ScrollView.Align} [align = UI.ScrollView.Align.VERTICAL]
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        align: ScrollViewAlign;
        /**
         * Gets layout of the ScrollView. Use this property to add a child to the ScrollView instead of {@link ScrollView#addChild}
         *
         * @property {UI.FlexLayout} [layout = UI.FlexLayout]
         * @android
         * @ios
         * @readonly
         * @since 1.1.10
         */
        layout: FlexLayout;
        /**
         * Gets/sets the visibility of the scrollbar.
         *
         * @property {Boolean} [scrollBarEnabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        scrollBarEnabled: boolean;
        /**
         * Scrollview layout size will be calculated by device automatically when autoSizeEnabled is true. To do the automatic calculation, you need to set scrollview.autoSizeEnabled property true and need to call scrollview.layout.applyLayout() function after every change.
         *
         * @property {Boolean} [autoSizeEnabled = false]
         * @android
         * @ios
         * @since 3.0.2
         */
        autoSizeEnabled: boolean;
        /**
         * Immediately scrolls to the edge set.
         *
         * @method scrollToEdge
         * @android
         * @ios
         * @param {UI.ScrollView.Edge} edge
         * @since 0.1
         */
        scrollToEdge(edge: ScrollViewEdge): void;
        /**
         * Immediately scrolls to the given coordinate. Coordinate is X position for horizontal alignment and
         * Y position for vertical alignment.
         *
         * @method scrollToCoordinate
         * @android
         * @ios
         * @param {Number} coordinate
         * @since 0.1
         */
        scrollToCoordinate(coordinate: number, animate?: boolean): void;
        /**
         * This event is called when a ScrollView is scrolled.
         * For better performance, don't set any callback if does not
         * necessary.
         *
         * @event onScroll
         * @deprecated
         * @param {Object} params
         * @param {Object} params.translation
         * @param {Number} params.translation.x
         * @param {Number} params.translation.y
         * @param {Object} params.contentOffset
         * @param {Number} params.contentOffset.x
         * @param {Number} params.contentOffset.y
         * @android
         * @ios
         * @since 1.1.13
         * @example
         * ````
         * import ScrollView from '@smartface/native/ui/scrollview';
         *
         * const scrollView = new ScrollView();
         * scrollView.on(ScrollView.Events.Scroll, (params) => {
         * 	console.info('onScroll', params);
         * });
         * ````
         */
        onScroll: (params: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void;
        /**
         * Gets contentOffset of the ScrollView.
         *
         * @property contentOffset
         * @android
         * @ios
         * @readonly
         * @return {Object}
         * @return {Number} return.x
         * @return {Number} return.y
         * @since 1.1.13
         */
        readonly contentOffset: Point2D;
    }
    export class AbstractScrollView<TEvent extends string = ScrollViewEvents, TIOS extends Record<string, any> = IScrollViewIOS, TAND extends Record<string, any> = {}> extends AbstractViewGroup<TEvent | ScrollViewEvents, any, IScrollView> implements IScrollView<TEvent | ScrollViewEvents> {
        constructor(params?: IScrollView);
        overScrollMode: OverScrollMode;
        align: ScrollViewAlign;
        layout: FlexLayout;
        scrollBarEnabled: boolean;
        autoSizeEnabled: boolean;
        scrollToEdge(edge: ScrollViewEdge): void;
        scrollToCoordinate(coordinate: number): void;
        onScroll: (params: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void;
        contentOffset: Point2D;
        useForeground?: boolean;
        rippleEnabled?: boolean;
        rippleColor?: Color;
        elevation?: number;
        zIndex?: number;
        static Align: ScrollViewAlign;
        static Edge: ScrollViewEdge;
    }
    const ScrollView: typeof AbstractScrollView;
    type ScrollView = AbstractScrollView;
    export default ScrollView;
}
declare module "ui/view/view.android" {
    import { Point2D } from "primitive/point2d";
    import { Rectangle } from "primitive/rectangle";
    import Color from "ui/color/index";
    import { ViewEvents } from "ui/view/view-event";
    import View, { IView, IViewProps, ViewBase } from "ui/view/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    export class ViewAndroid<TEvent extends string = ViewEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TProps extends IViewProps = IViewProps> extends ViewBase<TEvent, TNative, TProps> implements IView {
        static readonly Border: {
            readonly TOP_LEFT: number;
            readonly TOP_RIGHT: number;
            readonly BOTTOM_RIGHT: number;
            readonly BOTTOM_LEFT: number;
            readonly ALL: number;
        };
        static readonly State: {
            STATE_NORMAL: any[];
            STATE_DISABLED: any[];
            STATE_SELECTED: any[];
            STATE_PRESSED: any[];
            STATE_FOCUSED: any[];
        };
        nativeInner: any;
        uniqueId: string;
        protected _maskedBorders: never[];
        protected _masksToBounds: boolean;
        private _parent?;
        private _rotation;
        private _rotationX;
        private _rotationY;
        private _scale;
        protected _borderColor: Color;
        protected _borderWidth: number;
        protected _borderRadius: number;
        protected _backgroundColor: IView['backgroundColor'];
        protected _overScrollMode: OverScrollMode;
        private didSetTouchHandler;
        private _sfOnTouchViewManager;
        private _touchEnabled;
        private _rippleEnabled;
        private _rippleColor?;
        private _useForeground;
        protected yogaNode: any;
        constructor(params?: Partial<TProps>);
        get parent(): View | undefined;
        set parent(view: View | undefined);
        private setTouchHandlers;
        protected _setBorderToAllEdges(): void;
        private _setMaskedBorders;
        private _resetBackground;
        get zIndex(): number;
        set zIndex(index: number);
        get elevation(): any;
        set elevation(value: any);
        aspectRatio: number;
        get overScrollMode(): OverScrollMode;
        set overScrollMode(mode: OverScrollMode);
        get backgroundColor(): IView['backgroundColor'];
        set backgroundColor(color: IView['backgroundColor']);
        get testId(): any;
        set testId(value: any);
        get accessible(): any;
        set accessible(value: any);
        get accessibilityLabel(): any;
        set accessibilityLabel(value: any);
        get borderColor(): Color;
        set borderColor(value: Color);
        get borderWidth(): number;
        set borderWidth(value: number);
        get borderRadius(): number;
        set borderRadius(value: number);
        get maskedBorders(): never[];
        set maskedBorders(value: never[]);
        get masksToBounds(): boolean;
        set masksToBounds(value: boolean);
        private _touchCallbacks;
        get transitionId(): any;
        set transitionId(id: any);
        get alpha(): any;
        set alpha(alpha: any);
        get id(): any;
        set id(id: any);
        get rotation(): any;
        set rotation(value: any);
        get rotationX(): any;
        set rotationX(value: any);
        get rotationY(): any;
        set rotationY(value: any);
        get scaleX(): any;
        set scaleX(value: any);
        get scale(): {
            x: any;
            y: any;
        };
        set scale(value: {
            x: any;
            y: any;
        });
        get scaleY(): any;
        set scaleY(value: any);
        get enabled(): any;
        set enabled(enabled: any);
        get touchEnabled(): boolean;
        set touchEnabled(value: boolean);
        get onTouch(): (e?: Point2D | undefined) => boolean | void;
        set onTouch(onTouch: (e?: Point2D | undefined) => boolean | void);
        get onTouchEnded(): (isInside: boolean, point: Point2D) => boolean | void;
        set onTouchEnded(onTouchEnded: (isInside: boolean, point: Point2D) => boolean | void);
        get onTouchMoved(): (e: boolean | {
            isInside: boolean;
        }, point?: Point2D | undefined) => boolean | void;
        set onTouchMoved(onTouchMoved: (e: boolean | {
            isInside: boolean;
        }, point?: Point2D | undefined) => boolean | void);
        get onTouchCancelled(): (point: Point2D) => boolean | void;
        set onTouchCancelled(onTouchCancelled: (point: Point2D) => boolean | void);
        get visible(): boolean;
        set visible(visible: boolean);
        getScreenLocation(): Point2D;
        bringToFront(): void;
        flipHorizontally(): void;
        flipVertically(): void;
        getParent(): View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>> | null;
        getPosition(): {
            width: any;
            height: any;
            top: any;
            left: any;
        };
        setPosition(position: Rectangle): void;
        applyLayout(): void;
        toString(): string;
        get left(): any;
        set left(left: any);
        get top(): any;
        set top(top: any);
        get right(): any;
        set right(right: any);
        get bottom(): any;
        set bottom(bottom: any);
        get start(): any;
        set start(start: any);
        get end(): any;
        set end(end: any);
        get height(): any;
        set height(height: any);
        get width(): any;
        set width(width: any);
        get minWidth(): any;
        set minWidth(minWidth: any);
        get minHeight(): any;
        set minHeight(minHeight: any);
        get maxWidth(): any;
        set maxWidth(maxWidth: any);
        get maxHeight(): any;
        set maxHeight(maxHeight: any);
        get paddingTop(): any;
        set paddingTop(paddingTop: any);
        get paddingBottom(): any;
        set paddingBottom(paddingBottom: any);
        get paddingStart(): any;
        set paddingStart(paddingStart: any);
        get paddingEnd(): any;
        set paddingEnd(paddingEnd: any);
        get paddingLeft(): any;
        set paddingLeft(paddingLeft: any);
        get paddingRight(): any;
        set paddingRight(paddingRight: any);
        get paddingHorizontal(): any;
        set paddingHorizontal(paddingHorizontal: any);
        get paddingVertical(): any;
        set paddingVertical(paddingVertical: any);
        get padding(): any;
        set padding(padding: any);
        get marginTop(): any;
        set marginTop(marginTop: any);
        get marginBottom(): any;
        set marginBottom(marginBottom: any);
        get marginStart(): any;
        set marginStart(marginStart: any);
        get marginEnd(): any;
        set marginEnd(marginEnd: any);
        get marginLeft(): any;
        set marginLeft(marginLeft: any);
        get marginRight(): any;
        set marginRight(marginRight: any);
        get marginHorizontal(): any;
        set marginHorizontal(marginHorizontal: any);
        get marginVertical(): any;
        set marginVertical(marginVertical: any);
        get margin(): any;
        set margin(margin: any);
        get borderTopWidth(): any;
        set borderTopWidth(borderTopWidth: any);
        get borderBottomWidth(): any;
        set borderBottomWidth(borderBottomWidth: any);
        get borderStartWidth(): any;
        set borderStartWidth(borderStartWidth: any);
        get borderEndWidth(): any;
        set borderEndWidth(borderEndWidth: any);
        get borderLeftWidth(): any;
        set borderLeftWidth(borderLeftWidth: any);
        get borderRightWidth(): any;
        set borderRightWidth(borderRightWidth: any);
        get flexGrow(): any;
        set flexGrow(flexGrow: any);
        get flexShrink(): any;
        set flexShrink(flexShrink: any);
        get flexBasis(): any;
        set flexBasis(flexBasis: any);
        get alignSelf(): any;
        set alignSelf(alignSelf: any);
        get positionType(): any;
        set positionType(position: any);
        dirty(): void;
        get rippleEnabled(): boolean;
        set rippleEnabled(value: boolean);
        get useForeground(): boolean;
        set useForeground(value: boolean);
        get rippleColor(): Color | undefined;
        set rippleColor(value: Color | undefined);
    }
}
declare module "ui/activityindicator/activityindicator" {
    import Color from "ui/color/index";
    import { AbstractView, IView } from "ui/view/index";
    import { ViewEvents } from "ui/view/view-event";
    export enum ActivityIndicatorViewStyle {
        /**
         * @property {Number} LARGE
         * @ios
         * @static
         * @readonly
         * @since 3.2.1
         */
        LARGE = 0,
        /**
         * @property {Number} NORMAL
         * @ios
         * @static
         * @readonly
         * @since 3.2.1
         */
        NORMAL = 1
    }
    export interface IActivityIndicator extends IView<undefined, any, IActivityIndicator> {
        ios: IView['ios'] & {
            /**
             * Gets/sets style of the activity indicator.
             *
             * @ios
             * @since 3.2.1
             */
            activityIndicatorViewStyle: ActivityIndicatorViewStyle;
        };
        android: IView['android'];
    }
    export class ActivityIndicatorBase<TEvent extends string = ViewEvents> extends AbstractView<TEvent> {
        /**
         * Gets/sets color of the activity indicator.
         *
         * @android
         * @ios
         * @since 0.1
         */
        color: Color;
        static iOS: {
            ActivityIndicatorViewStyle: typeof ActivityIndicatorViewStyle;
        };
    }
}
declare module "ui/activityindicator/activityindicator.android" {
    import { ViewAndroid } from "ui/view/view.android";
    import Color from "ui/color/index";
    import { ViewEvents } from "ui/view/view-event";
    import { IActivityIndicator } from "ui/activityindicator/activityindicator";
    export default class ActivityIndicatorAndroid<TEvent extends string = ViewEvents> extends ViewAndroid<TEvent, any, IActivityIndicator> {
        private _color;
        constructor(params?: Partial<IActivityIndicator>);
        get color(): Color;
        set color(value: Color);
        toString(): string;
    }
}
declare module "ui/activityindicator/activityindicator.ios" {
    import Color from "ui/color/index";
    import { ViewEvents } from "ui/view/view-event";
    import ViewIOS from "ui/view/view.ios";
    import { IActivityIndicator } from "ui/activityindicator/activityindicator";
    export default class ActivityIndicatorIOS<TEvent extends string = ViewEvents> extends ViewIOS<TEvent, any, IActivityIndicator> {
        private _color;
        _nativeObject: __SF_UIActivityIndicatorView;
        constructor(params?: Partial<IActivityIndicator>);
        get color(): Color;
        set color(value: Color);
        get visible(): boolean;
        set visible(value: boolean);
        toString(): string;
    }
}
declare module "ui/activityindicator/index" {
    import { ActivityIndicatorBase } from "ui/activityindicator/activityindicator";
    const ActivityIndicator: typeof ActivityIndicatorBase;
    export default ActivityIndicator;
}
declare module "ui/shared/textalignment" {
    enum TextAlignment {
        TOPLEFT = 0,
        TOPCENTER = 1,
        TOPRIGHT = 2,
        MIDLEFT = 3,
        MIDCENTER = 4,
        MIDRIGHT = 5,
        BOTTOMLEFT = 6,
        BOTTOMCENTER = 7,
        BOTTOMRIGHT = 8
    }
    export default TextAlignment;
}
declare module "ui/shared/keyboardappearance" {
    /**
     * @since 0.1
     * @ios
     *
     * KeyboardAppearance is an enum. It defines keyboard appearance theme on iOS devices only.
     *
     *     @example
     *     import Color from '@smartface/native/ui/color';
     *     import TextBox from '@smartface/native/ui/textbox';
     *     import KeyboardAppearance from '@smartface/native/ui/keyboardappearance';
     *
     *     const myTextBox = new TextBox({
     *         top: 50, left:50, width: 100, height: 80,
     *         hint: "your hint text",
     *         backgroundColor: Color.create("#67fcaa")
     *     });
     *     myTextBox.ios.keyboardAppearance = KeyboardAppearance.DARK;
     *     myPage.layout.addChild(myTextBox);
     *
     */
    enum KeyboardAppearance {
        /**
         * @ios
         * Default colored keyboard appearance. This constant corresponds to UI.KeyboardAppearance.LIGHT.
         * @since 0.1
         */
        DEFAULT = 0,
        /**
         * @ios
         * Dark colored keyboard appearance.
         * @since 0.1
         */
        DARK = 1,
        /**
         * @ios
         * Light colored keyboard appearance.
         * @since 0.1
         */
        LIGHT = 2
    }
    export default KeyboardAppearance;
}
declare module "ui/shared/textcontenttype" {
    enum TextContentType {
        NAME = 0,
        NAMEPREFIX = 1,
        GIVENNAME = 2,
        MIDDLENAME = 3,
        FAMILYNAME = 4,
        NAMESUFFIX = 5,
        NICKNAME = 6,
        JOBTITLE = 7,
        ORGANIZATIONNAME = 8,
        LOCATION = 9,
        FULLSTREETADDRESS = 10,
        STREETADDRESSLINE1 = 11,
        STREETADDRESSLINE2 = 12,
        ADDRESSCITY = 13,
        ADDRESSSTATE = 14,
        ADDRESSCITYANDSTATE = 15,
        SUBLOCALITY = 16,
        COUNTRYNAME = 17,
        POSTALCODE = 18,
        TELEPHONENUMBER = 19,
        EMAILADDRESS = 20,
        URL = 21,
        CREDITCARDNUMBER = 22,
        USERNAME = 23,
        PASSWORD = 24,
        NEWPASSWORD = 25,
        ONETIMECODE = 26
    }
    export default TextContentType;
}
declare module "ui/shared/keyboardtype" {
    /**
     * @static
     * @since 0.1
     *
     * KeyboardType is an enum. When user focused on the TextBox or TextArea keyboard appears
     * with different layouts based on the KeyboardType such as number, email etc. Text based
     * fields like TextBox or TextArea have different behaviors based on KeyboardType in iOS
     * and Android. Android forces user to input data matched with KeyboardType but iOS doesn't.
     * For example with KeyboardType.DECIMAL user can't enter 5.1.1 for Android because it's not
     * a decimal number but can enter this number for iOS.
     *
     * Keyboard types will cause differences between iOS and Android due to native differences. In Android, a few indicated enums are not
     * supported with the usage of password.
     *
     *     @example
     *     import TextBox from '@smartface/native/ui/textbox';
     *     import KeyboardType from '@smartface/native/ui/keyboardtype';
     *     const myTextBox = new TextBox({
     *         height: 75,
     *         width: 100,
     *         hint: 'Smartface Hint',
     *         keyboardType: KeyboardType.NUMBER,
     *         isPassword: true
     *     });
     *
     */
    const KeyboardType: {
        /**
         * Default keyboard appearance.
         * @android
         * @ios
         * @since 0.1
         */
        DEFAULT: 0;
        /**
         * Numeric specific keyboard appearance.
         * @android
         * @ios
         * @since 0.1
         */
        NUMBER: 1;
        /**
         * Decimal specific keyboard appearance.
         * @android
         * @ios
         * @since 0.1
         */
        DECIMAL: 2;
        /**
         * Phone number specific keyboard appearance.
         * @android
         * @ios
         * @since 0.1
         */
        PHONE: 3;
        /**
         * URL address specific keyboard appearance
         * @android
         * @ios
         * @since 0.1
         */
        URL: 4;
        ios: {
            /**
             * Twitter specific keyboard appearance. This keyboard type works only for iOS.
             * @ios
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.iOS.TWITTER} instead.
             */
            TWITTER: 5;
            /**
             * Web search specific keyboard appearance. This keyboard type works only for iOS.
             * @ios
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.iOS.WEBSEARCH} instead.
             */
            WEBSEARCH: 6;
        };
        android: {
            /**
             * Date and time specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.DATETIME} instead.
             */
            DATETIME: 7;
            /**
             * Signed number specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.SIGNEDNUMBER} instead.
             */
            SIGNEDNUMBER: 8;
            /**
             * Signed decimal specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.SIGNEDDECIMAL} instead.
             */
            SIGNEDDECIMAL: 9;
            /**
             * Auto complete text specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTAUTOCOMPLETE} instead.
             */
            TEXTAUTOCOMPLETE: 10;
            /**
             * Auto correct text specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTAUTOCORRECT} instead.
             */
            TEXTAUTOCORRECT: 11;
            /**
             * Auto capitalized characters specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTCAPCHARACTERS} instead.
             */
            TEXTCAPCHARACTERS: 12;
            /**
             * Auto capitalized sentences specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTCAPSENTENCES} instead.
             */
            TEXTCAPSENTENCES: 13;
            /**
             * Auto capitalized word specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTCAPWORDS} instead.
             */
            TEXTCAPWORDS: 14;
            /**
             * Email subject specific keyboard appearance. This keyboard type works only for Android. Setting the content as password is not supported.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTEMAILSUBJECT} instead.
             */
            TEXTEMAILSUBJECT: 15;
            /**
             * Long message specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTLONGMESSAGE} instead.
             */
            TEXTLONGMESSAGE: 16;
            /**
             * Text with no suggestion keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTNOSUGGESTIONS} instead.
             */
            TEXTNOSUGGESTIONS: 17;
            /**
             * Person name specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTPERSONNAME} instead.
             */
            TEXTPERSONNAME: 18;
            /**
             * Short message specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TEXTSHORTMESSAGE} instead.
             */
            TEXTSHORTMESSAGE: 19;
            /**
             * @property {Number} TIME
             * Time specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 0.1
             * @deprecated 3.2.0 {@link UI.KeyboardType.Android.TIME} instead.
             */
            TIME: 20;
        };
        /**
         * Email address specific keyboard appearance. In Android, setting the content as password is not supported.
         * @android
         * @ios
         * @since 0.1
         */
        EMAILADDRESS: 21;
        iOS: {
            /**
             * Twitter specific keyboard appearance. This keyboard type works only for iOS.
             * @ios
             * @since 3.2.1
             */
            TWITTER: 5;
            /**
             * Web search specific keyboard appearance. This keyboard type works only for iOS.
             * @ios
             * @since 3.2.1
             */
            WEBSEARCH: 6;
        };
        Android: {
            /**
             * Date and time specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            DATETIME: 7;
            /**
             * Signed number specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            SIGNEDNUMBER: 8;
            /**
             * Signed decimal specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            SIGNEDDECIMAL: 9;
            /**
             * Auto complete text specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            TEXTAUTOCOMPLETE: 10;
            /**
             * Auto correct text specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            TEXTAUTOCORRECT: 11;
            /**
             * Auto capitalized characters specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             * @deprecated 4.0.2 Use {@link UI.TextBox.AutoCapitalize#CHARACTERS} instead.
             *
             */
            TEXTCAPCHARACTERS: 12;
            /**
             * Auto capitalized sentences specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             * @deprecated 4.0.2 Use {@link UI.TextBox.AutoCapitalize#SENTENCES} instead.
             */
            TEXTCAPSENTENCES: 13;
            /**
             * Auto capitalized word specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             * @deprecated 4.0.2 Use {@link UI.TextBox.AutoCapitalize#WORDS} instead.
             */
            TEXTCAPWORDS: 14;
            /**
             * Email subject specific keyboard appearance. This keyboard type works only for Android.Setting the content as password is not supported.
             * @android
             * @since 3.2.1
             */
            TEXTEMAILSUBJECT: 15;
            /**
             * Long message specific keyboard appearance. This keyboard type works only for Android
             * @android
             * @since 3.2.1
             */
            TEXTLONGMESSAGE: 16;
            /**
             * Text with no suggestion keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            TEXTNOSUGGESTIONS: 17;
            /**
             * Person name specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            TEXTPERSONNAME: 18;
            /**
             * Short message specific keyboard appearance. This keyboard type works only for Android.
             * @android
             * @since 3.2.1
             */
            TEXTSHORTMESSAGE: 19;
            /**
             * Time specific keyboard appearance. This keyboard type works only for Android. Setting the content as password is not supported.
             * @android
             * @since 3.2.1
             */
            TIME: 20;
        };
    };
    type KeyboardType = ExtractValues<typeof KeyboardType>;
    export default KeyboardType;
}
declare module "ui/shared/android/actionkeytype" {
    enum ActionKeyType {
        DEFAULT = 0,
        NEXT = 1,
        GO = 2,
        SEARCH = 3,
        SEND = 4
    }
    export default ActionKeyType;
}
declare module "ui/textbox/textbox-events" {
    export const TextBoxEvents: any;
    export type TextBoxEvents = ExtractValues<typeof TextBoxEvents>;
}
declare module "ui/textbox/autocapitalize" {
    /**
     * @enum {Number} UI.TextBox.AutoCapitalize
     *
     * Automatically capitalize certain characters.
     * @static
     * @since 2.8
     *
     */
    const AutoCapitalize: {
        /**
         * @property {Number} NONE
         * Don't auto capitalize anything.
         * @ios
         * @android
         * @static
         * @readonly
         * @since 2.8
         */
        NONE: 0;
        /**
         * @property {Number} WORDS
         * Capitalize the first character of each word.
         * @ios
         * @android
         * @static
         * @readonly
         * @since 2.8
         */
        WORDS: 1;
        /**
         * @property {Number} SENTENCES
         * Capitalize the first character of each sentence.
         *
         * @ios
         * @android
         * @static
         * @readonly
         * @since 2.8
         */
        SENTENCES: 2;
        /**
         * @property {Number} CHARACTERS
         * Capitalize all characters.
         * @ios
         * @android
         * @static
         * @readonly
         * @since 2.8
         */
        CHARACTERS: 3;
    };
    /**
     * @enum {Number} UI.TextBox.AutoCapitalize
     *
     * Automatically capitalize certain characters.
     * @static
     * @since 2.8
     *
     */
    type AutoCapitalize = ExtractValues<typeof AutoCapitalize>;
    export default AutoCapitalize;
}
declare module "ui/textbox/index" {
    import View, { IView } from "ui/view/index";
    import Font from "ui/font/index";
    import TextAlignment from "ui/shared/textalignment";
    import Color from "ui/color/index";
    import FlexLayout from "ui/flexlayout/index";
    import KeyboardAppearance from "ui/shared/keyboardappearance";
    import TextContentType from "ui/shared/textcontenttype";
    import KeyboardType from "ui/shared/keyboardtype";
    import ActionKeyType from "ui/shared/android/actionkeytype";
    import { TextBoxEvents } from "ui/textbox/textbox-events";
    import AutoCapitalize from "ui/textbox/autocapitalize";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    export type TextBoxAndroidProps = View['android'] & {
        cursorPosition: {
            start: number;
            end: number;
        };
        /**
         * Set an input filter to constrain the text length to the specified number. This property works only for Android.
         *
         * @method maxLength
         * @param {Number} value
         * @android
         * @since 2.0.10
         */
        maxLength?: (value: number) => void;
    };
    export type TextBoxiOSProps = View['ios'] & {
        /**
         * This property adjusts font size according to view's fixed width. If you set it true,
         * you should set minimum font size by changing the minimumFontSize property.
         * This property works only for iOS.
         *
         * @property {Boolean} [adjustFontSizeToFit = false]
         * @ios
         * @since 0.1
         */
        adjustFontSizeToFit: boolean;
        /**
         * Gets/sets minimum font size of TextBox.
         * This property works only for iOS.
         *
         * @property {Number} [minimumFontSize = 7]
         * @ios
         * @since 0.1
         */
        minimumFontSize: number;
        /**
         * Gets/sets the visibility of clear button. If enabled, clear button will be shown
         * at right of the TextBox. This property works only for iOS only.
         *
         * @property {Boolean} [clearButtonEnabled = false]
         * @ios
         * @since 0.1
         */
        clearButtonEnabled?: boolean;
        /**
         * Gets/sets a layout to be displayed above the standard system keyboard
         * when the textbox object became focus. This property works only for iOS only.
         * Default is undefined.
         *
         * @property {UI.FlexLayout} [keyboardLayout = undefined]
         * @ios
         */
        keyboardLayout?: FlexLayout | undefined;
        /**
         * The custom input view to display instead of system keyboard
         * when the textbox object became focus. This property works only for iOS only.
         * Default is undefined.
         *
         * @property {Object} inputView
         * @property {Number} inputView.height
         * @property {UI.View} inputView.view
         * @ios
         */
        inputView?: {
            height: number;
            view: View;
        };
        /**
         * Gets/sets the appearance style of the keyboard that is associated with the TextBox.
         * This property works only for iOS.
         *
         * @property {UI.KeyboardAppearance} [keyboardAppearance = UI.KeyboardAppearance.DEFAULT]
         * @ios
         * @since 0.1
         */
        keyboardAppearance?: KeyboardAppearance;
        /**
         * Use this property to give the keyboard and the system information about the expected semantic meaning for the content that users enter.
         * This property works only for iOS.
         *
         * @property {UI.iOS.TextContentType} textContentType
         * @ios
         * Creates a textContentType for ios.
         *
         *     @example
         *     const TextContentType = require("@smartface/native/ui/ios/textcontenttype");
         *     const System = require('@smartface/native/device/system');
         *
         *     if (System.OS == "iOS" && System.OSVersion >= 12){
         *         textbox.ios.textContentType = TextContentType.ONETIMECODE;
         *     }
         *
         * @since 4.1.3
         *
         */
        textContentType?: TextContentType;
    };
    export interface ITextBox<TEvent extends string = TextBoxEvents, TMobile extends MobileOSProps<TextBoxiOSProps, TextBoxAndroidProps> = MobileOSProps<TextBoxiOSProps, TextBoxAndroidProps>> extends IView<TEvent | TextBoxEvents, any, TMobile> {
        /**
         * Gets/sets the font of the TextBox.
         * @property {UI.Font} [font = null]
         * @android
         * @ios
         * @since 0.1
         */
        font: Font;
        /**
         * Gets/sets the text of the TextBox.
         * @property {String} [text = ""]
         * @android
         * @ios
         * @since 0.1
         */
        text: string;
        /**
         * Gets/sets automatically capitalization of the TextBox. {@link UI.TextBox#cursorPosition Cursor Position} might be necessary to re-set.
         * @property {UI.TextBox.AutoCapitalize} [autoCapitalize = UI.TextBox.AutoCapitalize.NONE]
         * @android
         * @ios
         * @since 2.8
         */
        autoCapitalize: AutoCapitalize;
        /**
         * Gets/sets the text alignment of the TextBox.
         * @property {UI.TextAlignment} [textAlignment = UI.TextAlignment.MIDLEFT]
         * @android
         * @ios
         * @since 0.1
         */
        textAlignment: TextAlignment;
        /**
         * Gets/sets the text color of TextBox.
         *
         * @property {UI.Color} [textColor = UI.Color.BLACK]
         * @android
         * @ios
         * @since 0.1
         */
        textColor: Color;
        /**
         * Gets/sets the cursor position of TextBox.
         *
         * @property {Object} cursorPosition
         * @property {Number} cursorPosition.start
         * @property {Number} cursorPosition.end
         * @android
         * @ios
         * @since 2.0.8
         * @deprecated
         * @example
         * ````
         * import TextBox from '@smartface/native/ui/textbox';
         *
         * const textBox = new TextBox();
         * textBox.on(TextBox.Events.EditBegins, (params) => {
         * 	console.info('onEditBegins', params);
         * });
         * ````
         */
        cursorPosition: {
            start: number;
            end: number;
        };
        onEditBegins: () => void;
        /**
         * Gets/sets the cursor color of TextBox.
         *
         * @property {UI.Color} cursorColor
         * @android
         * @ios
         * @since 3.2.1
         */
        cursorColor: Color;
        /**
         * Gets/sets hint text that will be displayed when TextBox is empty.
         *
         * @property {String} [hint = ""]
         * @android
         * @ios
         * @since 0.1
         */
        hint: string;
        /**
         * Gets/sets the color of the hint text.
         *
         * @property {UI.Color} [hintTextColor = UI.Color.LIGHTGRAY]
         * @android
         * @ios
         * @since 0.1
         */
        hintTextColor: Color;
        /**
         * Gets/sets the content of the TextBox is password or not. {@link UI.TextBox#cursorPosition Cursor Position} might be necessary to re-set.
         *
         * @property {Boolean} [isPassword = false]
         * @android
         * @ios
         * @since 0.1
         */
        isPassword: boolean;
        /**
         * Gets/sets keyboard type for TextBox. {@link UI.TextBox#cursorPosition Cursor Position} might be necessary to re-set.
         *
         * @property {UI.KeyboardType} [keyboardType = UI.KeyboardType.DEFAULT]
         * @android
         * @ios
         * @since 0.1
         */
        keyboardType: KeyboardType | null;
        /**
         * Gets/sets action key type for TextBox.
         *
         * @property {UI.ActionKeyType} [actionKeyType = UI.ActionKeyType.DEFAULT]
         * @android
         * @ios
         * @since 0.1
         */
        actionKeyType: ActionKeyType;
        /**
         * This function shows keyboard.
         *
         * @method showKeyboard
         * @android
         * @ios
         * @since 0.1
         * @deprecated 1.1.8 Use {@link UI.TextBox#requestFocus} instead.
         */
        showKeyboard(): void;
        /**
         * This function hides keyboard.
         *
         * @method hideKeyboard
         * @android
         * @ios
         * @since 0.1
         * @deprecated 1.1.8 Use {@link UI.TextBox#removeFocus} instead.
         */
        hideKeyboard(): void;
        /**
         * This function gives focus to the TextBox. When the TextBox gained focus, keyboard will appear.
         *
         * @method requestFocus
         * @android
         * @ios
         * @since 1.1.8
         */
        requestFocus(): void;
        /**
         * This function removes focus from the TextBox. When the TextBox lost its focus, keyboard will disappear.
         *
         * @method removeFocus
         * @android
         * @ios
         * @since 1.1.8
         */
        removeFocus(): void;
        /**
         * This event is called when user inserts or removes a character from TextBox.
         * @param {Object} e Event arguments.
         * @param {String} e.insertedText The text that inserted into TextBox.
         * @param {Number} e.location Index of inserted text.
         * @event onTextChanged
         * @android
         * @ios
         * @since 0.1
         * @deprecated
         * @example
         * ````
         * import TextBox from '@smartface/native/ui/textbox';
         *
         * const textBox = new TextBox();
         * textBox.on(TextBox.Events.TextChanged, (params) => {
         * 	console.info('onTextChanged', params);
         * });
         * ````
         */
        onTextChanged: (e?: {
            insertedText: string;
            location: number;
        }) => void;
        /**
         * The text box calls this method in response to the user pressing the built-in clear button. Return value is YES if the text box contents should be cleared; otherwise, NO.
         * If you do not implement this method, the text box clears the text as if the method had returned YES.
         *
         * @event onClearButtonPress
         * @ios
         * @since 4.0.2
         * @deprecated
         * @example
         * ````
         * import TextBox from '@smartface/native/ui/textbox';
         *
         * const textBox = new TextBox();
         * textBox.on(TextBox.Events.ClearButtonPress, () => {
         * 	console.info('onClearButtonPress');
         * });
         * ````
         */
        onClearButtonPress: () => void;
        /**
         * This event is called when user finishes editing by clicking return key
         * or clicking outside of the TextBox.
         *
         * @event onEditEnds
         * @android
         * @ios
         * @since 0.1
         * @deprecated
         * @example
         * ````
         * import TextBox from '@smartface/native/ui/textbox';
         *
         * const textBox = new TextBox();
         * textBox.on(TextBox.Events.EditEnds, () => {
         * 	console.info('onEditEnds');
         * });
         * ````
         */
        onEditEnds: () => void;
        /**
         * This event is called when user clicks action key on the keyboard.
         *
         * @param {Object} e Event arguments.
         * @param {UI.ActionKeyType} e.actionKeyType Pressed action key type.
         * @event onActionButtonPress
         * @android
         * @ios
         * @since 0.1
         * @deprecated
         * @example
         * ````
         * import TextBox from '@smartface/native/ui/textbox';
         *
         * const textBox = new TextBox();
         * textBox.on(TextBox.Events.ActionButtonPress, (params) => {
         * 	console.info('onActionButtonPress', params);
         * });
         * ````
         */
        onActionButtonPress: (e?: {
            actionKeyType: ActionKeyType;
        }) => void;
        enabled?: boolean;
    }
    /**
     * @class UI.TextBox
     * @since 0.1
     * @extends UI.View
     * TextBox is a UI which users can edit the text.
     *
     *     @example
     *     import TextBox from '@smartface/native/ui/textbox';
     *     const myTextBox = new TextBox({
     *         left: 10, top: 10, width: 200, height: 65,
     *         hint: "Your hint text",
     *         borderWidth: 1
     *     });
     *     myPage.layout.addChild(myTextBox);
     *
     */
    const TextBox: ConstructorOf<ITextBox, Partial<ITextBox>>;
    type TextBox = ITextBox;
    export default TextBox;
}
declare module "ui/alertview/alertview" {
    import { INativeComponent } from "core/inative-component";
    import { MobileOSProps } from "core/native-mobile-component";
    /**
     * @enum {Number} UI.AlertView.Android.ButtonType
     * @since 0.1
     *
     * ButtonType is used to indicate the behaviors of buttons in UI.AlertView.
     * You can specify a button have negative, positive or neutral user experience.
     * According to operating system button appearance or positions may change.
     *
     *     @example
     *     import AlertView from '@smartface/native/ui/alertview';
     *
     *     const myAlertView = new AlertView({
     *         title: "Alert Title",
     *         message: "Alert Message"
     *     });
     *     myAlertView.addButton({
     *         type: AlertView.Android.ButtonType.NEUTRAL,
     *         text: "Ignore",
     *     });
     *     myAlertView.addButton({
     *         type: AlertView.Android.ButtonType.NEGATIVE,
     *         text: "Cancel"
     *     });
     *     myAlertView.addButton({
     *         type: AlertView.Android.ButtonType.POSITIVE,
     *         text: "Okay"
     *     });
     *
     *     myAlertView.show();
     */
    export enum ButtonType {
        POSITIVE = 0,
        NEUTRAL = 1,
        NEGATIVE = 2
    }
    /**
     * @class UI.AlertView
     * @since 0.1
     *
     * AlertView is an alert box with buttons having custom behaviors. You can
     * use AlertView for informing user or asking for confirmations. AlertView
     * has buttons with callbacks that you can take action for each of them separately.
     *
     *     @example
     *     import AlertView from '@smartface/native/ui/alertview';
     *
     *     const myAlertView = new AlertView({
     *         title: "Alert Title",
     *         message: "Alert Message"
     *     });
     *     myAlertView.addButton({
     *         type: AlertView.Android.ButtonType.NEGATIVE,
     *         text: "Cancel"
     *     });
     *     myAlertView.addButton({
     *         type: AlertView.Android.ButtonType.POSITIVE,
     *         text: "Okay",
     *         onClick: () => {
     *             console.log("Okay clicked.");
     *         }
     *     });
     *
     *     myAlertView.show();
     */
    export interface IAlertView extends INativeComponent, MobileOSProps {
        /**
         * Gets showing status of AlertView. It is set to true if AlertView is
         * currently displayed on screen, false otherwise.
         *
         * @property {boolean} isShowing
         * @android
         * @ios
         * @since 0.1
         * @readonly
         */
        isShowing(): void;
        /**
         * Shows AlertView on the screen with specified properties, isShowing property
         * set to true after this operation.
         *
         * @method show
         * @android
         * @ios
         * @since 0.1
         */
        show(): void;
        toString(): string;
        /**
         * Gets/sets title of AlertView.
         *
         * @android
         * @ios
         * @since 0.1
         */
        title: string;
        /**
         * Gets/sets message of AlertView.
         *
         * @android
         * @ios
         * @since 0.1
         */
        message: string;
        /**
         * Gets/sets dismiss callback function.
         *
         *     @example
         *     myAlertView.onDismiss = (alertView) =>  {
         *         console.log("Dismissed alert view with title: " + alertView.title);
         *     };
         *
         * @android
         * @ios
         * @param {UI.AlertView} alertView Dismissed AlertView object
         * @since 0.1
         */
        onDismiss: (alertView?: IAlertView) => void;
        readonly android: Partial<{
            /**
             * Gets/sets whether the alert view is cancelable or not when touched outside.
             *
             * @android
             * @since 0.1
             */
            cancellable: boolean;
        }>;
        /**
         * Dismisses the AlertView, isShowing property set to false after this
         * operation.
         *
         * @android
         * @ios
         * @since 0.1
         */
        dismiss(): void;
        /**
         * Returns object which contains text of added TextBox
         *
         * @android
         * @ios
         * @since 4.1.2
         * @readonly
         */
        get textBoxes(): {
            text: string;
        }[];
        /**
         * Allows you to add button to AlertView. You can add maximum 3 buttons
         * on Android platform, on iOS there is no limitation.
         *
         *     @example
         *     myAlertView.addButton({
         *         type: AlertView.Android.ButtonType.POSITIVE,
         *         text: "Okay",
         *         onClick: function() {
         *             console.log("Okay clicked.");
         *         }
         *     });
         *
         * @android
         * @ios
         * @since 0.1
         */
        addButton(params: {
            type: ButtonType;
            text: string;
            onClick: () => void;
            index: number;
        }): void;
        /**
         * Allows to add TextBox to AlertView. In iOS, maximum two textbox can be added. It is not applied to Android but 2 textboxes recommended.
         *
         *     @example
         *     myAlertView.addTextBox({
         *          text: "Hello!",
         *          hint: "Hint!",
         *          isPassword: false,
         *          android: {
         *              viewSpacings: { left: 50, right: 50 }
         *          }
         *     });
         * @android
         * @ios
         * @since 4.1.2
         */
        addTextBox(params: {
            text: string;
            hint: string;
            isPassword: boolean;
            android: Partial<{
                width: number;
                height: number;
                viewSpacings: {
                    left: number;
                    top: number;
                    right: number;
                    bottom: number;
                };
            }>;
        }): void;
    }
    export class AbstractAlertView implements IAlertView {
        constructor(params?: Partial<IAlertView>);
        ios: Partial<{
            [key: string]: any;
        }>;
        isShowing(): void;
        show(): void;
        dismiss(): void;
        toString(): string;
        title: string;
        message: string;
        onDismiss: (alertView?: IAlertView) => void;
        android: Partial<{
            /**
             * Gets/sets whether the alert view is cancelable or not when touched outside.
             *
             * @android
             * @since 0.1
             */
            cancellable: boolean;
        }>;
        get textBoxes(): {
            text: string;
        }[];
        addButton(params: {
            type: ButtonType;
            text: string;
            onClick?: () => void;
            index: number;
        }): void;
        addTextBox(params: {
            text: string;
            hint: string;
            isPassword: boolean;
            android: Partial<{
                width: number;
                height: number;
                viewSpacings: {
                    left: number;
                    top: number;
                    right: number;
                    bottom: number;
                };
            }>;
        }): void;
        nativeObject: any;
        static Android: {
            ButtonType: typeof ButtonType;
        };
    }
}
declare module "ui/alertview/alertview.android" {
    import { ButtonType, IAlertView } from "ui/alertview/alertview";
    import { NativeMobileComponent } from "core/native-mobile-component";
    export default class AlertViewAndroid extends NativeMobileComponent<any, IAlertView> implements IAlertView {
        private __didSetOnDismissListener;
        private __buttonCallbacks;
        private __title;
        private __message;
        private __textBoxes;
        private __onDismiss;
        private _cancellable;
        constructor(params?: Partial<IAlertView>);
        isShowing(): void;
        show(): void;
        toString(): string;
        dismiss(): void;
        addButton(params: Partial<Parameters<IAlertView['addButton']>['0']>): void;
        addTextBox(params: Partial<Parameters<IAlertView['addTextBox']>['0']>): void;
        private dpToPixel;
        private setOnDismissListener;
        private androidSpecificProperties;
        get textBoxes(): IAlertView['textBoxes'];
        get title(): IAlertView['title'];
        set title(value: IAlertView['title']);
        get message(): IAlertView['message'];
        set message(value: IAlertView['message']);
        get onDismiss(): IAlertView['onDismiss'];
        set onDismiss(value: IAlertView['onDismiss']);
        get android(): Partial<{
            cancellable: boolean;
        }>;
        static Android: {
            ButtonType: typeof ButtonType;
        };
    }
}
declare module "ui/alertview/alertview.ios" {
    import { NativeMobileComponent } from "core/native-mobile-component";
    import { ButtonType, IAlertView } from "ui/alertview/alertview";
    export default class AlertViewIOS extends NativeMobileComponent<any, IAlertView> implements IAlertView {
        private delegate;
        private _onDismiss;
        constructor(params?: Partial<IAlertView>);
        isShowing(): void;
        show(): void;
        get title(): IAlertView['title'];
        set title(value: IAlertView['title']);
        get message(): IAlertView['message'];
        set message(value: IAlertView['message']);
        get onDismiss(): IAlertView['onDismiss'];
        set onDismiss(value: IAlertView['onDismiss']);
        dismiss(): void;
        get textBoxes(): {
            text: string;
        }[];
        addButton(params: Parameters<IAlertView['addButton']>['0']): void;
        addTextBox(params: Parameters<IAlertView['addTextBox']>['0']): void;
        static Android: {
            ButtonType: typeof ButtonType;
        };
    }
}
declare module "ui/alertview/index" {
    import { AbstractAlertView } from "ui/alertview/alertview";
    const AlertView: typeof AbstractAlertView;
    type AlertView = AbstractAlertView;
    export default AlertView;
}
declare module "ui/animator/index" {
    import ViewGroup from "ui/viewgroup/index";
    export type AnimatorParams = {
        layout: ViewGroup;
        duration: number;
        animFn: () => void;
    };
    export interface IAnimator {
        perform(): AnimatorBase;
        /**
         * Performs the changes declared in animFunction with animation.
         * Duration indicates how long the animation will take in milliseconds.
         * @android
         * @ios
         * @since 0.1
         */
        then(duration: number, animFn: () => void): AnimatorBase;
        /**
         * Runs the function provided after all animations are completed.
         * Note that: It does not perform any animations.
         * @android
         * @ios
         * @since 0.1
         */
        complete(callback: () => void): void;
    }
    export class AnimatorBase implements IAnimator {
        constructor(params: Partial<AnimatorParams>);
        perform(): AnimatorBase;
        then(duration: number, animFn: () => void): AnimatorBase;
        complete(callback: () => void): void;
        /**
         * Performs the changes declared in animFunction with animation inside the layout provided.
         * Duration indicates how long the animation will take in milliseconds.
         * For animation rootLayout you should choose parent layout for Android, you can choose page
         * layout for iOS as shown in example.
         * While animating Textbox, you may see the hint of the Textbox disappear on Android.
         * This is related with Android internal issue (same reason of Google Issue Tracker 38303812, 37048478). For getting over from this problem you should
         * set empty text to the Textbox onComplete callback of animation.
         * @android
         * @ios
         * @since 0.1
         */
        static animate(rootLayout: ViewGroup, duration: number, animFn: () => void): AnimatorBase;
    }
    const Animator: typeof AnimatorBase;
    type Animator = AnimatorBase;
    export default Animator;
}
declare module "ui/animator/animator.android" {
    import ViewGroup from "ui/viewgroup/index";
    import { AnimatorBase, AnimatorParams } from "ui/animator/index";
    export default class AnimatorAndroid extends AnimatorBase {
        private _layout;
        private _duration;
        private _animFn;
        private _nextAnimator;
        private _completeFn;
        private _onComplete;
        constructor(params: Partial<AnimatorParams>);
        perform(): AnimatorAndroid;
        then(duration: number, animFn: () => void): AnimatorAndroid;
        complete(callback: () => void): void;
        toString(): string;
        static animate(rootLayout: ViewGroup, duration: number, animFn: () => void): AnimatorAndroid;
        applyLayoutInners(rootLayout: ViewGroup): void;
        addInnerNativeViewGroups(viewGroup: any, viewGroups: ViewGroup[]): void;
    }
}
declare module "ui/animator/animator.ios" {
    import ViewGroup from "ui/viewgroup/index";
    import { AnimatorBase, AnimatorParams } from "ui/animator/index";
    export default class AnimatorIOS extends AnimatorBase {
        private _layout;
        private _duration;
        private _animFn;
        private _thenAnimator;
        private _completeFn;
        constructor(params: Partial<AnimatorParams>);
        perform(): AnimatorBase;
        then(duration: number, animFn: () => void): AnimatorIOS;
        complete(callback: () => void): void;
        static animate(rootLayout: ViewGroup, duration: number, animFn: () => void): AnimatorIOS;
    }
}
declare module "ui/badge/badge.android" {
    import { IBadge } from "ui/badge/index";
    import NativeComponent from "core/native-component";
    export default class BadgeAndroid extends NativeComponent implements IBadge {
        private _borderColor;
        private _visible;
        private _text;
        private _backgroundColor;
        private _textColor;
        private _font;
        private _borderRadius;
        private _borderWidth;
        private nativeGradientDrawable;
        constructor(params?: Partial<IBadge>);
        move(x: number, y: number): void;
        get text(): IBadge['text'];
        set text(value: IBadge['text']);
        get visible(): IBadge['visible'];
        set visible(value: IBadge['visible']);
        get backgroundColor(): IBadge['backgroundColor'] | null;
        set backgroundColor(value: IBadge['backgroundColor'] | null);
        get textColor(): IBadge['textColor'];
        set textColor(value: IBadge['textColor']);
        get font(): IBadge['font'];
        set font(value: IBadge['font']);
        get borderColor(): IBadge['borderColor'];
        set borderColor(value: IBadge['borderColor']);
        get borderWidth(): IBadge['borderWidth'];
        set borderWidth(value: IBadge['borderWidth']);
        private createColorStateList;
        private setDefaults;
    }
}
declare module "ui/badge/badge.ios" {
    import { IBadge } from "ui/badge/index";
    import NativeComponent from "core/native-component";
    export default class BadgeAndroid extends NativeComponent implements IBadge {
        private _visible;
        private _text;
        private _backgroundColor;
        private _borderColor;
        private _textColor;
        private _font;
        private _borderRadius;
        private _borderWidth;
        private _height;
        private _isBadgeFirstLoad;
        private _isRTL;
        constructor(params?: Partial<IBadge>);
        get text(): IBadge['text'];
        set text(value: IBadge['text']);
        get visible(): IBadge['visible'];
        set visible(value: IBadge['visible']);
        get backgroundColor(): IBadge['backgroundColor'];
        set backgroundColor(value: IBadge['backgroundColor']);
        get textColor(): IBadge['textColor'];
        set textColor(value: IBadge['textColor']);
        get font(): IBadge['font'];
        set font(value: IBadge['font']);
        get height(): number;
        set height(value: number);
        get borderColor(): IBadge['borderColor'];
        set borderColor(value: IBadge['borderColor']);
        get borderWidth(): IBadge['borderWidth'];
        set borderWidth(value: IBadge['borderWidth']);
        get isRTL(): boolean;
        set isRTL(value: boolean);
        move(x: number, y: number): void;
    }
}
declare module "ui/blurview/blurview-events" {
    export const BlurViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type BlurViewEvents = ExtractValues<typeof BlurViewEvents>;
}
declare module "ui/blurview/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import View, { AbstractView, IView } from "ui/view/index";
    import { BlurViewEvents } from "ui/blurview/blurview-events";
    /**
     * Blur styles
     * @enum {Number} UI.BlurView.iOS.EffectStyle
     * @since 4.3.1
     * @ios
     */
    export enum BlurViewEffectStyle {
        EXTRALIGHT = 0,
        LIGHT = 1,
        DARK = 2,
        REGULAR = 4,
        PROMINENT = 5,
        SYSTEMULTRATHINMATERIAL = 6,
        SYSTEMTHINMATERIAL = 7,
        SYSTEMMATERIAL = 8,
        SYSTEMTHICKMATERIAL = 9,
        SYSTEMCHROMEMATERIAL = 10,
        SYSTEMULTRATHINMATERIALLIGHT = 11,
        SYSTEMTHINMATERIALLIGHT = 12,
        SYSTEMMATERIALLIGHT = 13,
        SYSTEMTHICKMATERIALLIGHT = 14,
        SYSTEMCHROMEMATERIALLIGHT = 15,
        SYSTEMULTRATHINMATERIALDARK = 16,
        SYSTEMTHINMATERIALDARK = 17,
        SYSTEMMATERIALDARK = 18,
        SYSTEMTHICKMATERIALDARK = 19,
        SYSTEMCHROMEMATERIALDARK = 20
    }
    export enum BlurViewSemanticContentAttribute {
        /**
         * Layout direction will be the same as the device direction. You can use {@link Application#userInterfaceLayoutDirection userInterfaceLayoutDirection} property to check device direction.
         *
         * @property {Number} AUTO
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        AUTO = 0,
        /**
         * Layout direction is always left to right.
         *
         * @property {Number} FORCELEFTTORIGHT
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        FORCELEFTTORIGHT = 3,
        /**
         * Layout direction is always right to left.
         *
         * @property {Number} FORCERIGHTTOLEFT
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        FORCERIGHTTOLEFT = 4
    }
    export type iOSProps = View['ios'] & {
        /**
         * Gets/sets blur style.
         * @property {UI.BlurView.iOS.EffectStyle} effectStyle
         * @ios
         * @since 4.3.1
         */
        effectStyle?: BlurViewEffectStyle;
    };
    export type AndroidProps = View['android'] & {
        /**
         * Gets/sets the blur radius. The value range is between (0, 25].
         * @property {Number} [blurRadius=16]
         * @android
         * @since 4.3.1
         */
        blurRadius: number;
        /**
         * Gets/sets the root to start blur from.
         * @property {UI.FlexLayout} rootView
         * @android
         * @since 4.3.1
         */
        rootView: View;
        /**
         * Gets/sets the color overlay to be drawn on top of blurred content.
         * @property {UI.Color} overlayColor
         * @android
         * @since 4.3.1
         */
        overlayColor: Color;
    };
    export interface IBlurView<TEvent extends string = BlurViewEvents, TIOS = iOSProps, TAND = AndroidProps> extends IView<TEvent | BlurViewEvents, any, MobileOSProps<iOSProps, AndroidProps>> {
    }
    export class AbstractBlurView<TEvent extends string = BlurViewEvents> extends AbstractView<TEvent, any, IBlurView> implements IBlurView<TEvent> {
        static iOS: {
            /**
             * Blur styles
             * @enum {Number} UI.BlurView.iOS.EffectStyle
             * @since 4.3.1
             * @ios
             */
            EffectStyle: typeof BlurViewEffectStyle;
            SemanticContentAttribute: typeof BlurViewSemanticContentAttribute;
        };
    }
    /**
     * BlurView that blurs its underlying content.
     *
     * @example
     * import BlurView '@smartface/native/ui/blurview';
     * import FlexLayout from '@smartface/native/ui/flexlayout';
     *
     * const myBlurView = new BlurView({
     *     top: 0,
     *     right: 0,
     *     left: 0,
     *     bottom: 0,
     *     positionType: FlexLayout.PositionType.ABSOLUTE
     * });
     *
     * myBlurView.android.rootView = page.layout;
     *
     * page.layout.addChild(myBlurView);
     *
     * @since 4.3.1
     */
    const BlurView: typeof AbstractBlurView;
    type BlurView = AbstractBlurView;
    export default BlurView;
}
declare module "ui/blurview/blurview.android" {
    import { IBlurView } from "ui/blurview/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { BlurViewEvents } from "ui/blurview/blurview-events";
    export default class BlurViewAndroid<TEvent extends string = BlurViewEvents> extends ViewAndroid<TEvent | BlurViewEvents, any, IBlurView> implements IBlurView {
        private _overlayColor;
        private _rootView;
        private _blurRadius;
        private _blurRender;
        constructor(params?: Partial<IBlurView>);
        refreshBlurView(): void;
    }
}
declare module "ui/blurview/blurview.ios" {
    import { IBlurView } from "ui/blurview/index";
    import ViewIOS from "ui/view/view.ios";
    import { BlurViewEvents } from "ui/blurview/blurview-events";
    export default class BlurViewIOS<TEvent extends string = BlurViewEvents> extends ViewIOS<TEvent | BlurViewEvents, __SF_SMFVisualEffectView, IBlurView> implements IBlurView {
        private _effectStyle;
        constructor(params?: Partial<IBlurView>);
    }
}
declare module "ui/bottomtabbar/bottomtabbar.android" {
    import NativeComponent from "core/native-component";
    import Color from "ui/color/index";
    import TabBarItem from "ui/tabbaritem/index";
    import BottomTabBar, { IBottomTabBar } from "ui/bottomtabbar/index";
    export default class BottomTabBarAndroid extends NativeComponent implements IBottomTabBar {
        private _itemColors;
        private _backgroundColor;
        private _items;
        private _android;
        private _ios;
        constructor(params?: Partial<BottomTabBar>);
        get android(): any;
        get ios(): any;
        get height(): number;
        get items(): TabBarItem[];
        set items(tabBarItems: TabBarItem[]);
        get itemColor(): {
            normal: Color;
            selected: Color;
        };
        set itemColor(colors: {
            normal: Color;
            selected: Color;
        });
        get backgroundColor(): Color;
        set backgroundColor(color: Color);
        toString(): string;
        createTabbarMenuItems(tabBarItems: any[]): void;
        addBadgeToItem(tabBarItems: any): void;
    }
}
declare module "ui/color/color.ios" {
    import { AbstractColor } from "ui/color/index";
    import { GradientDirection } from "ui/color/index";
    export default class ColorIOS extends AbstractColor {
        static create(alpha: number, red: number, green: number, blue: number): ColorIOS;
        static create(red: number, green: number, blue: number): ColorIOS;
        static create(hexCode: string): ColorIOS;
        static createGradient(params: {
            direction: GradientDirection;
            startColor: ColorIOS;
            endColor: ColorIOS;
        }): ColorIOS;
        static red(color: ColorIOS): number;
        static green(color: ColorIOS): number;
        static blue(color: ColorIOS): number;
        static alpha(color: ColorIOS): number;
        static BLACK: ColorIOS;
        static BLUE: ColorIOS;
        static CYAN: ColorIOS;
        static DARKGRAY: ColorIOS;
        static GRAY: ColorIOS;
        static GREEN: ColorIOS;
        static LIGHTGRAY: ColorIOS;
        static MAGENTA: ColorIOS;
        static RED: ColorIOS;
        static TRANSPARENT: ColorIOS;
        static YELLOW: ColorIOS;
        static WHITE: ColorIOS;
        constructor(params: {
            color: __SF_UIColor | __SF_CAGradientLayer;
        });
        red(): number;
        green(): number;
        blue(): number;
        alpha(): number;
    }
}
declare module "ui/bottomtabbar/bottomtabbar.ios" {
    import { IBottomTabBar } from "ui/bottomtabbar/index";
    import NativeComponent from "core/native-component";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import TabBarItem from "ui/tabbaritem/index";
    export default class BottomTabBarIOS extends NativeComponent implements IBottomTabBar {
        private _android;
        private _ios;
        private appearance;
        private _items;
        private _borderVisibility;
        private _itemColor;
        private _selectionIndicatorImage;
        constructor(params?: Partial<IBottomTabBar> & Partial<NativeComponent>);
        get android(): Partial<{
            maxItemCount: boolean;
            disableItemAnimation: boolean;
        }>;
        get ios(): Partial<{
            translucent: boolean;
        }>;
        get height(): any;
        get items(): TabBarItem[];
        set items(value: TabBarItem[]);
        get itemColor(): {
            normal: undefined;
            selected: undefined;
        };
        set itemColor(itemColorObject: {
            normal: undefined;
            selected: undefined;
        });
        get backgroundColor(): Color;
        set backgroundColor(value: Color);
        tabBarControllerItemsDidChange(): void;
        get tintColor(): {
            selected: Color;
            normal: Color;
        };
        set tintColor(value: {
            selected: Color;
            normal: Color;
        });
        get unselectedItemColor(): Color;
        set unselectedItemColor(value: Color);
        get backgroundImage(): Image;
        set backgroundImage(value: Image);
        get borderVisibility(): boolean;
        set borderVisibility(value: boolean);
        get selectionIndicatorImage(): any;
        set selectionIndicatorImage(value: any);
    }
}
declare module "ui/bottomtabbarcontroller/bottomtabbarcontroller.android" {
    import { IBottomTabBarController } from "ui/bottomtabbarcontroller/index";
    import { BottomTabbarControllerEvents } from "ui/bottomtabbarcontroller/bottomtabbarcontroller-events";
    import { IController } from "ui/navigationcontroller/index";
    import { EventEmitter } from "core/eventemitter/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    export default class BottomTabbarControllerAndroid extends EventEmitter<BottomTabbarControllerEvents> implements IBottomTabBarController {
        static Events: {
            readonly SelectByIndex: "selectByIndex";
            readonly ShouldSelectByIndex: "shouldSelectByIndex";
        };
        private _addedToActivity;
        private _disabledShiftingMode;
        private _menu;
        private _childControllers;
        private _selectedIndex;
        private _shouldSelectByIndexCallback;
        private _didSelectByIndexCallback;
        private initializeOneTime;
        private cahceNativeViews;
        private cacheNativeBuilders;
        private __isActive;
        private __targetIndex;
        pageID: number;
        popupBackNavigator: any;
        isActive: boolean;
        parentController: IController;
        headerBar?: HeaderBar;
        nativeObject: any;
        isInsideBottomTabBar: boolean;
        constructor(params?: Partial<IBottomTabBarController>);
        shouldSelectViewController(index: any): boolean;
        didSelectViewController(index: any): void;
        get tabBar(): any;
        set tabBar(params: any);
        get childControllers(): IController[];
        set childController(childrenArray: any[]);
        get selectedIndex(): number;
        set selectedIndex(index: number);
        get didSelectByIndex(): (params: {
            index: number;
        }) => void;
        set didSelectByIndex(callback: (params: {
            index: number;
        }) => void);
        get shouldSelectByIndex(): ({ index: number }: {
            index: any;
        }) => boolean;
        set shouldSelectByIndex(callback: ({ index: number }: {
            index: any;
        }) => boolean);
        toString(): string;
        addTabBarToActivity(): void;
        push(childController: any): void;
        show(): void;
        setChecked(): void;
        initializeOnce(): void;
        getCurrentController(): IController | null;
        setNormalColorToAttributed(): void;
        controlAttributedTextColor(index: any, cache: any): void;
        attributedItem(tabBarItem: any, color: any): any;
        attributedItemBuilder(tabBarItem: any, color: any): any;
        disableShiftMode(bottomTabBar: any): boolean;
    }
}
declare module "ui/bottomtabbarcontroller/bottomtabbarcontroller.ios" {
    import { IBottomTabBarController } from "ui/bottomtabbarcontroller/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { IController, INavigationController } from "ui/navigationcontroller/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import Page from "ui/page/index";
    import { BottomTabbarControllerEvents } from "ui/bottomtabbarcontroller/bottomtabbarcontroller-events";
    export default class BottomTabbarControllerIOS extends NativeEventEmitterComponent<BottomTabbarControllerEvents> implements IBottomTabBarController {
        static Events: {
            readonly SelectByIndex: "selectByIndex";
            readonly ShouldSelectByIndex: "shouldSelectByIndex";
        };
        private view;
        private model;
        private _tabBar;
        private _shouldSelectByIndex;
        private _didSelectByIndex;
        private _shouldSelectViewController;
        private _didSelectViewController;
        private viewModel;
        private nativeObjectDelegate;
        private currentIndex;
        parentController: IController;
        pageID: number;
        popupBackNavigator: any;
        isActive: boolean;
        headerBar?: HeaderBar;
        isInsideBottomTabBar: boolean;
        constructor(params?: Partial<IBottomTabBarController & {
            viewModel?: any;
        }>);
        getCurrentController(): INavigationController | Page | null;
        get didSelectByIndex(): any;
        set didSelectByIndex(value: any);
        get shouldSelectByIndex(): any;
        set shouldSelectByIndex(value: any);
        get shouldSelectViewController(): any;
        set shouldSelectViewController(value: any);
        get didSelectViewController(): any;
        set didSelectViewController(value: any);
        get childControllers(): any;
        set childControllers(childControllers: any);
        get tabBar(): any;
        set tabBar(value: any);
        get selectedIndex(): any;
        set selectedIndex(value: any);
        show(): void;
        present(params?: any): void;
        getVisiblePage(currentPage: any): null;
        dismiss(params: any): void;
    }
}
declare module "ui/button/button-events" {
    export const ButtonEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly Press: "press";
        readonly LongPress: "longPress";
    };
    export type ButtonEvents = ExtractValues<typeof ButtonEvents>;
}
declare module "ui/shared/android/ellipsizemode" {
    type EllipsizeMode = 'start' | 'middle' | 'end' | 'none' | 'ios_wordwrapping' | 'ios_charwrapping';
    /**
     * @enum {Number} UI.EllipsizeMode
     * @static
     * @readonly
     * @since 4.0.2
     *
     * EllipsizeMode is an enum. It defines how to text will be truncated.
     *
     *     @example
     *     import Color from '@smartface/native/ui/color';
     *     import TextView from '@smartface/native/ui/textview';
     *     import EllipsizeMode from '@smartface/native/ui/ellipsizemode';
     *
     *     const myTextView = new TextView({
     *         hint: "hint",
     *         width: 100,
     *         backgroundColor: Color.create("#7fd0ff"),
     *         ellipsizeMode: EllipsizeMode.START
     *     });
     *
     *     myPage.layout.addChild(myTextView);
     *
     */
    const EllipsizeMode: {
        /**
         * End of text fits in the container and the missing text at the beginning of the line is indicated by
         * an ellipsis glyph. Such as "...smrtfc"
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.0.2
         */
        START: 'start';
        /**
         * End & start of text fits in the container and the missing middle of the text  is indicated by
         * an ellipsis glyph. Such as "smrt...fc"
         * @android
         * @ios
         * @static
         * @readonly
         * @since 4.0.2
         */
        MIDDLE: 'middle';
        /**
         * Start of text fits in the container and the missing end of the text  is indicated by
         * an ellipsis glyph. Such as "smrtfc..."
         * @android
         * @ios
         * @static
         * @since 4.0.2
         * @readonly
         */
        END: 'end';
        /**
         * Turns off ellipsizing
         * @android
         * @ios
         * @static
         * @since 4.0.2
         * @readonly
         */
        NONE: 'none';
        iOS: {
            /**
             * Wrapping occurs at word boundaries, unless the word itself doesnt fit on a single line. This mode may not work correctly when the maxLines value is 1.
             *
             * @property {Number} WORDWRAPPING
             * @ios
             * @static
             * @since 4.0.2
             * @readonly
             */
            WORDWRAPPING: 'ios_wordwrapping';
            /**
             * Wrap at character boundaries. This mode may not work correctly when the maxLines value is 1.
             * @ios
             * @static
             * @since 4.0.2
             * @readonly
             */
            CHARWRAPPING: 'ios_charwrapping';
        };
        /**
         * Wrapping occurs at word boundaries, unless the word itself doesnt fit on a single line. This mode may not work correctly when the maxLines value is 1.
         * @ios
         * @static
         * @since 4.0.2
         * @readonly
         */
        WORDWRAPPING: 'ios_wordwrapping';
        /**
         * Wrap at character boundaries. This mode may not work correctly when the maxLines value is 1.
         * @ios
         * @static
         * @since 4.0.2
         * @readonly
         */
        CHARWRAPPING: 'ios_charwrapping';
    };
    export default EllipsizeMode;
}
declare module "ui/shared/textdirection" {
    enum TextDirection {
        INHERIT = 0,
        FIRST_STRONG = 1,
        ANY_RTL = 2,
        LTR = 3,
        RTL = 4,
        LOCALE = 5,
        FIRST_STRONG_LTR = 6,
        FIRST_STRONG_RTL = 7
    }
    export default TextDirection;
}
declare module "ui/label/index" {
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import TextAlignment from "ui/shared/textalignment";
    import { ViewEvents } from "ui/view/view-event";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    import { IView, IViewState } from "ui/view/index";
    import EllipsizeMode from "ui/shared/android/ellipsizemode";
    import TextDirection from "ui/shared/textdirection";
    export type LabelAndroidProps = IView['android'] & {
        /**
         * Gets/sets adjustable-font step granularity. It is used in conjunction with the minimum and maximum text size in order to build the set of text sizes the system uses to choose from when auto-sizing
         *
         * @android
         * @since 4.2.2
         */
        adjustableFontSizeStep?: number;
        /**
         * Gets/sets the text direction.
         *
         * @property {UI.Android.TextDirection} textDirection
         * @android
         * @since 4.0.2
         */
        textDirection?: TextDirection;
    };
    export type LabelIOSProps = IView['ios'];
    export interface ILabel<TEvent extends string = ViewEvents, TMobile extends MobileOSProps<LabelIOSProps, LabelAndroidProps> = MobileOSProps<LabelIOSProps, LabelAndroidProps>> extends IView<TEvent, any, TMobile> {
        /**
         * Gets/sets font of a Label. When set to null label uses system font.
         * It is set to null by default.
         *
         *     @example
         *     import Label from '@smartface/native/ui/label';
         *     import Font from '@smartface/native/ui/font';
         *     const myLabel = new Label({
         *         text: "This is my label",
         *         visible: true
         *     });
         *     myLabel.font = Font.create("Arial", 16, Font.BOLD);
         *
         * @android
         * @ios
         * @since 0.1
         */
        font: Font;
        /**
         * Enables/disables multiple line property of a Label. If set to true
         * and the text is long enough, text will be shown in multiline. Setting multiline will override the {@link UI.Label#ellipsizeMode ellipsizeMode} prop.
         *
         * @default false
         * @android
         * @ios
         * @since 0.1
         * @deprecated 4.0.2 Use {@link UI.Label#maxLines maxLines} instead
         */
        multiline: boolean;
        /**
         * Sets the height of the Label to be at most maxLines tall. Setting 0 indicates that maxLines will be as much as given content.
         *
         * @android
         * @ios
         * @since 4.0.2
         */
        maxLines: number;
        /**
         * Causes words in the text that are longer than the view's width to be ellipsized instead of broken in the middle. If {@link UI.Label#maxLines maxLines} has been used to set two or more lines, only {@link UI.EllipsizeMode#END EllipsizeMode.END} is supported
         *
         * @property {UI.EllipsizeMode} ellipsizeMode
         * @android
         * @ios
         * @since 4.0.2
         */
        ellipsizeMode: EllipsizeMode;
        /**
         * Gets/sets text on Label.
         *
         * @property {String} [text = ""]
         * @android
         * @ios
         * @since 0.1
         */
        text: string;
        /**
         * Gets/sets text alignment of a Label. UI.TextAlignment constants
         * can be used. Label textAlignment property only supports UI.TextAlignment.MIDLEFT, UI.TextAlignment.MIDCENTER, UI.TextAlignment.MIDRIGHT.
         *
         *     @example
         *     const Label = require('@smartface/native/ui/label');
         *     const TextAlignment = require('@smartface/native/ui/textalignment');
         *     var myLabel = new Label();
         *     myLabel.textAlignment = TextAlignment.MIDCENTER;
         *
         * @property {UI.TextAlignment} [textAlignment = UI.TextAlignment.MIDLEFT]
         * @android
         * @ios
         * @since 0.1
         */
        textAlignment: TextAlignment;
        /**
         * Gets/sets text color of Label.
         *
         * @property {UI.Color} [textColor = UI.Color.BLACK]
         * @android
         * @ios
         * @since 0.1
         */
        textColor: Color | IViewState<Color>;
        /**
         * This property adjusts font size according to view's fixed width. The adjustment of font size happens according to {@link UI.Label#minimumFontSize minimumFontSize} , maximum font size (which is current label font size) & {@link UI.Label#adjustableFontSizeStep adjustableFontSizeStep}(just Android)
         *
         * @property {Boolean} [adjustFontSizeToFit = false]
         * @ios
         * @android
         * @since 4.2.2
         * @see {@link UI.Label#minimumFontSize minimumFontSize}
         * @see {@link UI.Label#adjustableFontSizeStep adjustableFontSizeStep}
         */
        adjustFontSizeToFit: boolean;
        /**
         * Gets/sets minimum font size of Label.
         *
         * @property {Number} [minimumFontSize = 1]
         * @ios
         * @android
         * @since 4.2.2
         */
        minimumFontSize: number;
    }
    const Label: ConstructorOf<ILabel, Partial<ILabel>>;
    type Label = ILabel;
    export default Label;
}
declare module "ui/button/index" {
    import Image from "ui/image/index";
    import { ButtonEvents } from "ui/button/button-events";
    import { ILabel } from "ui/label/index";
    import { IViewState } from "ui/view/index";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    type MobileProps = MobileOSProps<ILabel['ios'], ILabel['android']>;
    export interface IButton<TEvent extends string = ButtonEvents, TMobile extends MobileProps = MobileProps> extends ILabel<TEvent | ButtonEvents, TMobile> {
        /**
         * Enables/disables the Button. This will dim the button color. You can set the dim property on Button style.
         *
         *     @example
         *     import Button from '@smartface/native/ui/button';
         *     const myButton = new Button();
         *     myButton.enabled = false;
         *
         * @since 0.1
         * @android
         * @ios
         */
        enabled: boolean;
        /**
         * Gets/sets background image of a Button.
         *
         *     @example
         *     import Image from '@smartface/native/ui/image';
         *     import Button from '@smartface/native/ui/button';
         *     var myButton = new Button();
         *     myButton.backgroundImage = {
         *         normal: Image.createFromFile("images://normal.png"),
         *         disabled: Image.createFromFile("images://disabled.png"),
         *         pressed: Image.createFromFile("images://pressed.png"),
         *     };
         *     myButton.text = "First button text";
         *
         *     const myButton2 = new Button();
         *     myButton2.backgroundImage = Image.createFromFile("images://normal.png");
         *     myButton2.text = "Second button text";
         *
         * @since 0.1
         * @android
         * @ios
         */
        backgroundImage: Image | IViewState<Image>;
        /**
         * @deprecated
         * @example
         * ````
         * import Button from '@smartface/native/ui/button';
         *
         * this.button1.on(Button.Events.Press, () => {
         *  console.info('Button pressed');
         * });
         * ````
         */
        onPress: () => void;
        /**
         * This only works for Android
         * @deprecated
         * @example
         * ````
         * import Button from '@smartface/native/ui/button';
         *
         * this.button1.on(Button.Events.LongPress, () => {
         *  console.info('Button long pressed');
         * });
         * ````
         */
        onLongPress: () => void;
    }
    const Button: ConstructorOf<IButton, Partial<IButton>>;
    type Button = IButton;
    export default Button;
}
declare module "ui/label/label.android" {
    import TextAlignment from "ui/shared/textalignment";
    import { ViewAndroid } from "ui/view/view.android";
    import { ILabel, LabelAndroidProps } from "ui/label/index";
    import { ViewEvents } from "ui/view/view-event";
    export default class LabelAndroid<TEvent extends string = ViewEvents, TNative = LabelAndroidProps, TProps extends ILabel = ILabel> extends ViewAndroid<TEvent, TNative, TProps> implements ILabel {
        private _ellipsizeMode;
        protected _textAlignment: TextAlignment;
        protected viewNativeDefaultTextAlignment: number;
        private skipDefaults;
        private _adjustFontSizeToFit;
        private _minimumFontSize;
        private _textDirection;
        private _adjustableFontSizeStep;
        private fontInitial;
        private _textColor;
        constructor(params: Partial<TProps>);
        toString(): string;
        private initWithlabelType;
        private initAndroidProps;
        private setAutoSizeTextTypeUniformWithConfiguration;
        private createColorStateList;
        get font(): ILabel['font'];
        set font(value: ILabel['font']);
        get multiline(): ILabel['multiline'];
        set multiline(value: ILabel['multiline']);
        get maxLines(): ILabel['maxLines'];
        set maxLines(value: ILabel['maxLines']);
        get ellipsizeMode(): ILabel['ellipsizeMode'];
        set ellipsizeMode(value: ILabel['ellipsizeMode']);
        get text(): ILabel['text'];
        set text(value: ILabel['text']);
        get textAlignment(): ILabel['textAlignment'];
        set textAlignment(value: ILabel['textAlignment']);
        get textColor(): ILabel['textColor'];
        set textColor(value: ILabel['textColor']);
        get adjustFontSizeToFit(): ILabel['adjustFontSizeToFit'];
        set adjustFontSizeToFit(value: ILabel['adjustFontSizeToFit']);
        get minimumFontSize(): ILabel['minimumFontSize'];
        set minimumFontSize(value: ILabel['minimumFontSize']);
        get padding(): ILabel['padding'];
        set padding(value: ILabel['padding']);
        get paddingLeft(): ILabel['paddingLeft'];
        set paddingLeft(value: ILabel['paddingLeft']);
        get paddingRight(): ILabel['paddingRight'];
        set paddingRight(value: ILabel['paddingRight']);
        get paddingTop(): ILabel['paddingTop'];
        set paddingTop(value: ILabel['paddingTop']);
        get paddingBottom(): ILabel['paddingBottom'];
        set paddingBottom(value: ILabel['paddingBottom']);
    }
}
declare module "ui/button/button.android" {
    import { IButton } from "ui/button/index";
    import { ButtonEvents } from "ui/button/button-events";
    import LabelAndroid from "ui/label/label.android";
    export default class ButtonAndroid<TEvent extends string = ButtonEvents, TNative = any, TProps extends IButton = IButton> extends LabelAndroid<ButtonEvents, TNative, TProps> implements IButton<TEvent> {
        private __onPress;
        private __onLongPress;
        protected _backgroundColor: IButton['backgroundColor'];
        private __backgroundImages;
        private borderShapeDrawable;
        private layerDrawable;
        private backgroundDrawable;
        private __didSetOnClickListener;
        private __didSetOnLongClickListener;
        constructor(params?: Partial<TProps>);
        static Events: {
            Touch: "touch";
            TouchCancelled: "touchCancelled";
            TouchEnded: "touchEnded";
            TouchMoved: "touchMoved";
            Press: "press";
            LongPress: "longPress";
        };
        get backgroundColor(): IButton['backgroundColor'];
        set backgroundColor(value: IButton['backgroundColor']);
        get backgroundImage(): IButton['backgroundImage'];
        set backgroundImage(value: IButton['backgroundImage']);
        get borderWidth(): IButton['borderWidth'];
        set borderWidth(value: IButton['borderWidth']);
        get borderRadius(): IButton['borderRadius'];
        set borderRadius(value: IButton['borderRadius']);
        get borderColor(): IButton['borderColor'];
        set borderColor(value: IButton['borderColor']);
        get textAlignment(): IButton['textAlignment'];
        set textAlignment(value: IButton['textAlignment']);
        get onPress(): IButton['onPress'];
        set onPress(value: IButton['onPress']);
        onLongPress: () => void;
        private setBackgroundColor;
        private setBackgroundImage;
        private setBorder;
        private setBackground;
        private createNewLayerDrawable;
        private setOnClickListener;
        private setOnLongClickListener;
    }
}
declare module "util/iOS/nslinebreakmode" {
    import EllipsizeMode from "ui/shared/android/ellipsizemode";
    namespace NSLineBreakMode {
        const byWordWrapping = 0;
        const byCharWrapping = 1;
        const byClipping = 2;
        const byTruncatingHead = 3;
        const byTruncatingTail = 4;
        const byTruncatingMiddle = 5;
        function ellipsizeModeToNSLineBreakMode(mode: EllipsizeMode): 1 | 2 | 3 | 4 | 5 | 0;
        function nsLineBreakModeToEllipsizeMode(mode: number): "start" | "end" | "middle" | "none" | "ios_wordwrapping" | "ios_charwrapping";
    }
    export default NSLineBreakMode;
}
declare module "ui/label/label.ios" {
    import { ViewEvents } from "ui/view/view-event";
    import ViewIOS from "ui/view/view.ios";
    import { ILabel } from "ui/label/index";
    export default class LabelIOS<TEvent extends string = ViewEvents, TNative = any, TProps extends ILabel = ILabel> extends ViewIOS<TEvent, TNative, TProps> implements ILabel {
        private _minimumFontSize;
        private _textAlignment;
        protected _textColor: ILabel['textColor'];
        constructor(params?: Partial<TProps>);
        get font(): ILabel['font'];
        set font(value: ILabel['font']);
        get adjustFontSizeToFit(): ILabel['adjustFontSizeToFit'];
        set adjustFontSizeToFit(value: ILabel['adjustFontSizeToFit']);
        get minimumFontSize(): ILabel['minimumFontSize'];
        set minimumFontSize(value: ILabel['minimumFontSize']);
        get ellipsizeMode(): ILabel['ellipsizeMode'];
        set ellipsizeMode(value: ILabel['ellipsizeMode']);
        get maxLines(): ILabel['maxLines'];
        set maxLines(value: ILabel['maxLines']);
        get multiline(): ILabel['multiline'];
        set multiline(value: ILabel['multiline']);
        get text(): ILabel['text'];
        set text(value: ILabel['text']);
        get textAlignment(): ILabel['textAlignment'];
        set textAlignment(value: ILabel['textAlignment']);
        get textColor(): ILabel['textColor'];
        set textColor(value: ILabel['textColor']);
    }
}
declare module "ui/button/button.ios" {
    import { IButton } from "ui/button/index";
    import LabelIOS from "ui/label/label.ios";
    import { ButtonEvents } from "ui/button/button-events";
    export default class ButtonIOS<TEvent extends string = ButtonEvents> extends LabelIOS<ButtonEvents> implements IButton<TEvent> {
        protected _backgroundImage: IButton['backgroundImage'];
        protected _textColor: IButton['textColor'];
        protected _backgroundColor: IButton['backgroundColor'];
        protected _nativeObject: __SF_UIButton;
        protected _text: IButton['text'];
        private gradientColorObject;
        private _onPressFunc;
        constructor(params?: Partial<IButton>);
        onLongPress: () => void;
        get nativeObject(): __SF_UIButton;
        get enabled(): IButton['enabled'];
        set enabled(value: IButton['enabled']);
        get text(): IButton['text'];
        set text(value: IButton['text']);
        get textAlignment(): IButton['textAlignment'];
        set textAlignment(value: IButton['textAlignment']);
        get textColor(): IButton['textColor'];
        set textColor(value: IButton['textColor']);
        get backgroundColor(): IButton['backgroundColor'];
        set backgroundColor(value: IButton['backgroundColor']);
        private checkAndSetBackground;
        get backgroundImage(): IButton['backgroundImage'];
        set backgroundImage(value: IButton['backgroundImage']);
        get onPress(): IButton['onPress'];
        set onPress(value: IButton['onPress']);
        get font(): IButton['font'];
        set font(value: IButton['font']);
    }
}
declare module "ui/color/color.android" {
    import Color, { AbstractColor } from "ui/color/index";
    interface GradientParams {
        startColor: Color;
        endColor: Color;
        direction: Color['direction'];
    }
    interface ColorAndroidConstructorParams {
        color: any;
        isGradient: Color['isGradient'];
    }
    export default class ColorAndroid extends AbstractColor {
        static create(alpha: number, red: number, green: number, blue: number): ColorAndroid;
        static create(red: number, green: number, blue: number): ColorAndroid;
        static create(hexCode: string): ColorAndroid;
        static createGradient(params: GradientParams): ColorAndroid;
        static red(color: ColorAndroid): number;
        static green(color: ColorAndroid): number;
        static blue(color: ColorAndroid): number;
        static alpha(color: ColorAndroid): number;
        static BLACK: ColorAndroid;
        static BLUE: ColorAndroid;
        static CYAN: ColorAndroid;
        static DARKGRAY: ColorAndroid;
        static GRAY: ColorAndroid;
        static GREEN: ColorAndroid;
        static LIGHTGRAY: ColorAndroid;
        static MAGENTA: ColorAndroid;
        static RED: ColorAndroid;
        static TRANSPARENT: ColorAndroid;
        static YELLOW: ColorAndroid;
        static WHITE: ColorAndroid;
        private colors;
        constructor(params: Partial<ColorAndroidConstructorParams & GradientParams>);
        red(): number;
        green(): number;
        blue(): number;
        alpha(): number;
    }
}
declare module "ui/datepicker/datepicker-events" {
    export const DatePickerEvents: {
        /**
         * This event is called when scroll ends & an item is selected on a picker.
         *
         * @param {Number} index
         * @event onSelected
         * @android
         * @ios
         * @since 0.1
         */
        readonly Selected: "selected";
        readonly Cancelled: "cancelled";
    };
    export type DatePickerEvents = ExtractValues<typeof DatePickerEvents>;
}
declare module "ui/datepicker/index" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { DatePickerEvents } from "ui/datepicker/datepicker-events";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    /**
     * @enum UI.DatePicker.Android.Style
     * @android
     * @since 3.1.3
     *
     * According to your requirements, you should choose of the theme enums.
     * If there is no theme specified then default them style will be applied. Theme enum must be given with constructor.
     *
     *     @example
     *     import DatePicker from '@smartface/native/ui/datepicker';
     *     const myDatePicker = new DatePicker({
     *        android: {
     *          style: DatePicker.Android.Style.DEFAULT_DARK
     *        }
     *     });
     *     myDatePicker.onDateSelected = (date) => {
     *         console.log('Year: ' + date.getFullYear() + ' Month: ' + date.getMonth() + ' Day' + date.getDate());
     *     };
     *     myDatePicker.show();
     *
     */
    export enum Style {
        /**
         * Native default DatePicker theme.
         *
         * @property DEFAULT
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        DEFAULT = 0,
        /**
         * Native default dark theme with a dark background.
         *
         * @property DEFAULT_DARK
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        DEFAULT_DARK = 16974545,
        /**
         * Native default light theme with a light background.
         *
         * @property DEFAULT_LIGHT
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        DEFAULT_LIGHT = 16974546,
        /**
         * Material dark theme with two-tone backgrounds.
         *
         * @property MATERIAL_DARK
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        MATERIAL_DARK = 16974374,
        /**
         * Material light theme  with two-tone backgrounds.
         *
         * @property MATERIAL_LIGHT
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        MATERIAL_LIGHT = 16974394
    }
    /**
     * @enum {Number} UI.DatePicker.iOS.DatePickerMode
     * @since 3.1.3
     * @ios
     */
    export enum DatePickerMode {
        /**
         * A mode that displays the date in hours, minutes.
         *
         * @property {Number} TIME
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        TIME = 0,
        /**
         * A mode that displays the date in months, days of the month, and years.
         *
         * @property {Number} DATE
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        DATE = 1,
        /**
         * A mode that displays the date as unified day of the week, month, and day of the month values, plus hours, minutes.
         *
         * @property {Number} DATEANDTIME
         * @static
         * @ios
         * @readonly
         * @since 3.1.3
         */
        DATEANDTIME = 2
    }
    export interface DatePickerIOSProperties {
        /**
         * Gets/sets title of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} title
         * @ios
         * @since 3.1.3
         */
        title: string;
        /**
         * Gets/sets titleColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} titleColor
         * @ios
         * @since 3.1.3
         */
        titleColor: Color;
        /**
         * Gets/sets titleFont of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} titleFont
         * @ios
         * @since 3.1.3
         */
        titleFont: Font;
        /**
         * Gets/sets cancelColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} cancelColor
         * @ios
         * @since 3.1.3
         */
        cancelColor: Color;
        /**
         * Gets/sets cancelHighlightedColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} cancelHighlightedColor
         * @ios
         * @since 3.1.3
         */
        cancelHighlightedColor: Color;
        /**
         * Gets/sets cancelFont of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} cancelFont
         * @ios
         * @since 3.1.3
         */
        cancelFont: Font;
        /**
         * Gets/sets okColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} okColor
         * @ios
         * @since 3.1.3
         */
        okColor: Color;
        /**
         * Gets/sets okHighlightedColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} okHighlightedColor
         * @ios
         * @since 3.1.3
         */
        okHighlightedColor: Color;
        /**
         * Gets/sets okColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} okColor
         * @ios
         * @since 3.1.3
         */
        okFont: Font;
        /**
         * The mode determines whether dates, times, or both dates and times are displayed.
         *
         * @property {UI.DatePicker.iOS.DatePickerMode} datePickerMode
         * @ios
         * @since 3.1.3
         */
        datePickerMode: DatePickerMode;
        /**
         * Gets/sets cancelText of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} cancelText
         * @ios
         * @since 3.1.3
         */
        cancelText: string;
        /**
         * Gets/sets okText of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} okText
         * @ios
         * @since 3.1.3
         */
        okText: string;
        /**
         * Gets/sets textColor of Picker.
         *
         * @property {UI.Color} textColor
         * @ios
         * @since 4.2.3
         */
        textColor?: Color;
        /**
         * Gets/sets dialogLineColor of Picker.
         *
         * @property {UI.Color} dialogLineColor
         * @ios
         * @since 4.2.3
         */
        dialogLineColor: Color;
        /**
         * Gets/sets dialogBackgroundColor of Picker.
         *
         * @property {UI.Color} dialogBackgroundColor
         * @ios
         * @since 4.2.3
         */
        dialogBackgroundColor: Color;
    }
    export interface DatePickerAndroidProperties {
        /**
         * According to your requirements, this property enables you to specify native built-in styles.
         *
         * @property {UI.DatePicker.Android.Style} style
         * @android
         * @since 3.1.3
         */
        style: Style;
    }
    export interface IDatePicker<TEvent extends string = DatePickerEvents> extends NativeEventEmitterComponent<TEvent> {
        ios: Partial<DatePickerIOSProperties>;
        android: Partial<DatePickerAndroidProperties>;
        /**
         * Sets the initial date avaliable on the picker.
         *
         * @method setDate
         * @android
         * @ios
         * @param {Date} date
         * @since 0.1
         */
        setDate(date: Date): void;
        /**
         * Sets the minimum date avaliable on the picker.
         *
         * @method setMinDate
         * @android
         * @ios
         * @param {Date} minDate
         * @since 0.1
         */
        setMinDate(date: Date): void;
        /**
         * Sets the maximum date avaliable on the picker.
         *
         * @method setMaxDate
         * @android
         * @ios
         * @param {Date} maxDate
         * @since 0.1
         */
        setMaxDate(date: Date): void;
        /**
         * Makes the picker appear on the screen.
         *
         * @method show
         * @android
         * @ios
         * @since 0.1
         */
        show(): void;
        /**
         * Triggered when a date is selected on the picker.
         *
         * @since 0.1
         * @param {Date} date
         * @event onDateSelected
         * @deprecated
         * @android
         * @ios
         * @example
         * ````
         * import DatePicker from '@smartface/native/ui/datepicker';
         *
         * const datePicker = new DatePicker();
         * datePicker.on(DatePicker.Events.Selected, (params) => {
         *  console.info('onDateSelected', params);
         * });
         * ````
         */
        onDateSelected: (date: Date) => void;
        /**
         * Triggered when click cancel button on the picker.
         *
         * @since 3.1.3
         * @event onCancelled
         * @deprecated
         * @android
         * @ios
         * @example
         * ````
         * import DatePicker from '@smartface/native/ui/datepicker';
         *
         * const datePicker = new DatePicker();
         * datePicker.on(DatePicker.Events.Cancelled, () => {
         *  console.info('onCancelled');
         * });
         * ````
         */
        onCancelled: () => void;
    }
    export abstract class AbstractDatePicker extends NativeEventEmitterComponent<DatePickerEvents, any, IDatePicker> implements IDatePicker {
        constructor(params?: Partial<IDatePicker>);
        abstract setDate(date: Date): void;
        abstract setMinDate(date: Date): void;
        abstract setMaxDate(date: Date): void;
        abstract show(): void;
        onDateSelected: (date: Date) => void;
        onCancelled: () => void;
        static Android: {
            Style: typeof Style;
        };
        static iOS: {
            DatePickerMode: typeof DatePickerMode;
        };
    }
    /**
     * Only to use type of export
     */
    class DatePickerImpl extends AbstractDatePicker {
        setDate(date: Date): void;
        setMinDate(date: Date): void;
        setMaxDate(date: Date): void;
        show(): void;
    }
    const DatePicker: typeof DatePickerImpl;
    type DatePicker = DatePickerImpl;
    export default DatePicker;
}
declare module "ui/datepicker/datepicker.android" {
    import { AbstractDatePicker, IDatePicker } from "ui/datepicker/index";
    export default class DatePickerAndroid extends AbstractDatePicker {
        private _onDateSelected;
        private _onCancelled;
        constructor(params?: Partial<IDatePicker>);
        show(): void;
        setMinDate(date: Date): void;
        setMaxDate(date: Date): void;
        setDate(date: Date): void;
        toString(): string;
    }
}
declare module "ui/datepicker/datepicker.ios" {
    import { AbstractDatePicker, IDatePicker } from "ui/datepicker/index";
    import { DatePickerEvents } from "ui/datepicker/datepicker-events";
    export default class DatePickerIOS<TEvent extends string = DatePickerEvents> extends AbstractDatePicker implements IDatePicker<TEvent | DatePickerEvents> {
        protected _nativeObject: __SF_UIDatePicker;
        private _titleColor;
        private _titleFont;
        private _cancelColor;
        private _cancelHighlightedColor;
        private _cancelFont;
        private _okColor;
        private _okHighlightedColor;
        private _okFont;
        private _okText;
        private _cancelText;
        private onDateSelectedListener;
        private onCancelledListener;
        constructor(params?: Partial<IDatePicker>);
        setDate(date: Date): void;
        setMinDate(date: Date): void;
        setMaxDate(date: Date): void;
        show(): void;
        private get iosProps();
    }
}
declare module "ui/dialog/dialog" {
    import NativeComponent from "core/native-component";
    import FlexLayout from "ui/flexlayout/index";
    export const DEFAULT_TRANSLUCENCY = 58;
    /**
     * @enum UI.Dialog.Android.Style
     * @android
     * @since 3.0.2
     *
     * According to your requirements, you should choose of the theme enums.
     *
     *     @example
     *     import Dialog from "@smartface/native/ui/dialog";
     *     import Button from "@smartface/native/ui/button";
     *     import Color from "@smartface/native/ui/color";
     *
     *     const myDialog = new Dialog({
     *      android: {
     *          themeStyle: Dialog.Android.Style.ThemeNoHeaderBar
     *        }
     *     });
     *
     *     const myButton = new Button({
     *         width: 100,
     *         height: 80,
     *         backgroundColor: Color.BLUE,
     *         text: "Hide Dialog",
     *         onPress: function() {
     *             myDialog.hide();
     *         }
     *     });
     *
     *     myDialog.layout.addChild(myButton);
     *     myDialog.layout.applyLayout();
     *     myDialog.show();
     *
     */
    export enum DialogStyle {
        /**
         * This is default enum which will act as default when no themeStyle given.Default theme has no title bar and fills the entire screen.
         *
         * @android
         * @since 3.0.2
         */
        ThemeDefault = 16974065,
        /**
         * This theme with no header bar.
         *
         * @android
         * @since 3.0.2
         */
        ThemeNoHeaderBar = 16974064,
        /**
         * This theme has no title bar and fills the entire screen and extends into the display overscan region.
         *
         * @android
         * @since 3.0.2
         */
        ThemeNoHeaderBarWithOverscan = 16974302,
        /**
         * This theme  has no title bar and translucent system decor.
         *
         * @android
         * @since 3.0.2
         */
        ThemeNoHeaderBarWithTranslucentDecor = 16974306
    }
    export abstract class AbstractDialog extends NativeComponent {
        constructor(params?: Partial<AbstractDialog>);
        abstract setShowListener(): void;
        /**
         * Gets the layout of Dialog. You should add views to the layout of the dialog instance.
         *
         * @android
         * @ios
         * @since 0.1
         */
        abstract get layout(): FlexLayout;
        /**
         * Hides the dialog.
         *
         * @android
         * @ios
         * @since 0.1
         */
        abstract hide(): void;
        /**
         * Shows the dialog.
         *
         * @since 0.1
         * @android
         * @ios
         */
        abstract show(): void;
        static Style: DialogStyle;
        abstract get android(): Partial<{
            /**
             * Sets the theme style of dialog.
             *
             * @property {UI.Dialog.Android.Style} themeStyle
             * @android
             * @since 3.0.2
             */
            themeStyle: DialogStyle;
            /**
             * Sets whether the dialog is full transparent. This property must be given in constructor function.
             * If {@link UI.StatusBar statusBar} is visible, the dialog is drawn under status bar.
             *
             * @property {Boolean} isTransparent
             * @android
             * @since 3.2.0
             */
            isTransparent: boolean;
            /**
             * Sets whether this dialog is cancelable with the {@link Application#onBackButtonPressed BACK} key.
             *
             * @property {Boolean} cancelable
             * @android
             * @since 4.0.2
             */
            cancelable: boolean;
        }>;
        static Android: {
            Style: Partial<typeof DialogStyle>;
        };
    }
}
declare module "ui/dialog/dialog.android" {
    import FlexLayout from "ui/flexlayout/index";
    import { AbstractDialog, DialogStyle } from "ui/dialog/dialog";
    interface IDialogAndroid {
        hideKeyboard(): void;
        onShow(): void;
        cancelable: boolean;
        isTransparent: boolean;
        themeStyle: DialogStyle;
    }
    export default class DialogAndroid extends AbstractDialog {
        private _android;
        private _isTransparent;
        private _themeStyle;
        private _layout;
        private _onShowCallback;
        private _isSetListener;
        private _cancelable;
        skipDefaults: boolean;
        private dialogWindow;
        private colorDrawable;
        constructor(params?: Partial<DialogAndroid>);
        setShowListener(): void;
        private initDialogLayout;
        private assignAndroidProperties;
        get android(): Partial<IDialogAndroid>;
        set android(value: Partial<IDialogAndroid>);
        get layout(): FlexLayout;
        show(): void;
        hide(): void;
        toString(): string;
        static Android: {
            Style: typeof DialogStyle;
        };
    }
}
declare module "ui/dialog/dialog.ios" {
    import { AbstractDialog } from "ui/dialog/dialog";
    import FlexLayout from "ui/flexlayout/index";
    export default class DialogIOS extends AbstractDialog {
        setShowListener(): void;
        private dialogView;
        private _android;
        constructor(params?: Partial<DialogIOS>);
        hide(): void;
        show(): void;
        calculatePosition(): void;
        get layout(): FlexLayout;
        get android(): {};
        static Android: {
            Style: {};
        };
        static iOS: {
            ID: number;
        };
    }
}
declare module "ui/dialog/index" {
    import FlexLayout from "ui/flexlayout/index";
    import { AbstractDialog, DialogStyle } from "ui/dialog/dialog";
    class DialogImpl extends AbstractDialog {
        setShowListener(): void;
        get layout(): FlexLayout;
        hide(): void;
        show(): void;
        get android(): Partial<{
            themeStyle: DialogStyle;
            isTransparent: boolean;
            cancelable: boolean;
        }>;
    }
    const Dialog: typeof DialogImpl;
    type Dialog = DialogImpl;
    export default Dialog;
}
declare module "ui/emailcomposer/index" {
    import File from "io/file/index";
    import Blob from "global/blob/index";
    import Page from "ui/page/index";
    import { MobileOSProps, NativeMobileComponent } from "core/native-mobile-component";
    type EmailComposerAndroidProps = {
        /**
         * Attach the given file to email composer.
         *
         * @param {IO.File} file
         * @android
         * @method addAttachmentForAndroid
         * @since 3.0.3
         */
        addAttachmentForAndroid(file: File): void;
    };
    type EmailComposerIOSProps = {
        /**
         * Attach the given file to email composer.
         * For Images; if you have multiple sizes of image resource (e.g smartface@2x.png, smartface@3x.png); you should give exact path of an image file.
         *
         * @param {Blob} blob
         * @param {String} mimeType mimeType's "image/jpeg","image/png","image/gif","image/tiff","image/tiff","application/pdf","application/vnd","text/plain",
         * @param {String} fileName
         * @ios
         * @method addAttachmentForiOS
         * @since 3.0.3
         */
        addAttachmentForiOS(blob: Blob, mimeType?: string, fileName?: string): void;
    };
    /**
     * @class UI.EmailComposer
     * @since 3.0.3
     * A standard interface for managing, editing, and sending an email message. When email composer is dismiss, page's onShow will be triggered.
     *
     *     @example
     *     const File = require('@smartface/native/io/file');
     *     const FileStream = require('@smartface/native/io/filestream');
     *     const EmailComposer = require('@smartface/native/ui/emailcomposer');
     *     const System = require('@smartface/native/device/system');
     *
     *     if (EmailComposer.canSendMail()) {
     *         var emailcomposer = new EmailComposer();
     *         emailcomposer.setBCC(["bcc@smartface.io","bcc2@smartface.io"]);
     *         emailcomposer.setCC(["cc@smartface.io","cc2@smartface.io"]);
     *         emailcomposer.setTO(["to@smartface.io","to2@smartface.io"]);
     *         emailcomposer.setMessage("message");
     *         emailcomposer.setSubject("subject");
     *         emailcomposer.onClose = function(){
     *             console.log("onClose");
     *         };
    
     *         var imageFile = new File({
     *             path: 'assets://smartface.png'
     *         });
     *
     *         emailcomposer.android.addAttachmentForAndroid(imageFile);
     *
     *         if (System.OS == "iOS") {
     *             var imageFileStream = imageFile.openStream(FileStream.StreamType.READ, FileStream.ContentMode.BINARY);
     *             var fileBlob = imageFileStream.readToEnd();
     *             imageFileStream.close();
     *             emailcomposer.ios.addAttachmentForiOS(fileBlob,"image/png","smartface.png");
     *         }
     *
     *         emailcomposer.show(page);
     *     }
     *
     */
    export abstract class AbstractEmailComposer extends NativeMobileComponent<any, MobileOSProps<EmailComposerIOSProps, EmailComposerAndroidProps>> {
        /**
         * Sets the initial recipients to include in the emails CC field.
         *
         * @param {String[]} cc
         * @android
         * @ios
         * @method setCC
         * @since 3.0.3
         */
        abstract setCC(cc: string[]): void;
        /**
         * Sets the initial recipients to include in the emails BCC field.
         *
         * @param {String[]} bcc
         * @android
         * @ios
         * @method setBCC
         * @since 3.0.3
         */
        abstract setBCC(bcc: string[]): void;
        /**
         * Sets the initial recipients to include in the emails TO field.
         *
         * @param {String[]} to
         * @android
         * @ios
         * @method setTO
         * @since 3.0.3
         */
        abstract setTO(to: string[]): void;
        /**
         * Sets the initial body text to include in the email composer.
         *
         * @param {String} text
         * @param {Boolean} [isHtmlText = false]
         * @android
         * @ios
         * @method setMessage
         * @since 3.0.3
         */
        abstract setMessage(text: string, isHtmlText?: boolean): void;
        /**
         * Sets the initial text for the subject line of the email composer.
         *
         * @param {String} subject
         * @android
         * @ios
         * @method setSubject
         * @since 3.0.3
         */
        abstract setSubject(subject: string): void;
        /**
         * This function will be triggered when email composer is closed.
         *
         * @android
         * @ios
         * @method onClose
         * @since 3.0.3
         */
        abstract onClose: () => void;
        /**
         * This function shows email composer on the given UI.Page.
         *
         * @param {UI.Page} page This is the page that email will be shown.
         * @android
         * @ios
         * @method show
         * @since 3.0.3
         */
        abstract show(page: Page): void;
        /**
         * You should call this method before attempting to display the email composition interface. If it returns NO, you must not display the email composition interface.
         *
         * @return {Boolean} canSendMail
         * @ios
         * @android
         * @method canSendMail
         * @static
         * @since 3.0.3
         */
        abstract canSendMail(): boolean;
    }
    class EmailComposerImpl extends AbstractEmailComposer {
        setCC(cc: string[]): void;
        setBCC(bcc: string[]): void;
        setTO(to: string[]): void;
        setMessage(text: string, isHtmlText?: boolean): void;
        setSubject(subject: string): void;
        onClose: () => void;
        show(page: Page): void;
        canSendMail(): boolean;
    }
    const EmailComposer: typeof EmailComposerImpl;
    type EmailComposer = EmailComposerImpl;
    export default EmailComposer;
}
declare module "ui/emailcomposer/emailcomposer.android" {
    import { AbstractEmailComposer } from "ui/emailcomposer/index";
    import { RequestCodes } from "util/index";
    import Page from "ui/page/index";
    export default class EmailComposerAndroid extends AbstractEmailComposer {
        static EMAIL_REQUESTCODE: RequestCodes.EmailComposer;
        private _closeCallback;
        constructor();
        canSendMail(): boolean;
        get onClose(): () => void;
        set onClose(callback: () => void);
        setCC(cc: string[]): void;
        setBCC(bcc: string[]): void;
        setTO(to: string[]): void;
        setMessage(text: string, isHtmlText?: boolean): void;
        setSubject(subject: string): void;
        show(page: Page): void;
        static _closeCallback: () => void;
        static canSendMail(): boolean;
        static onActivityResult(requestCode: number, resultCode: number, data: any): void;
    }
}
declare module "ui/emailcomposer/emailcomposer.ios" {
    import { AbstractEmailComposer } from "ui/emailcomposer/index";
    import Page from "ui/page/index";
    export default class EmailComposerIOS extends AbstractEmailComposer {
        private _cc;
        private _bcc;
        private _to;
        private _message;
        private _subject;
        private _attaches;
        private _closeCallback;
        private nativeObjectDelegate;
        constructor();
        get onClose(): () => void;
        set onClose(callback: () => void);
        setCC(cc: string[]): void;
        setBCC(bcc: string[]): void;
        setTO(to: string[]): void;
        setMessage(text: string, isHtmlText?: boolean): void;
        setSubject(subject: string): void;
        show(page: Page): void;
        canSendMail(): boolean;
    }
}
declare module "ui/viewgroup/viewgroup.android" {
    import { ViewAndroid } from "ui/view/view.android";
    import { ViewGroupEvents } from "ui/viewgroup/viewgroup-events";
    import { IViewGroup } from "ui/viewgroup/index";
    import View, { IView } from "ui/view/index";
    export default class ViewGroupAndroid<TEvent extends string = ViewGroupEvents, TNative extends {
        [key: string]: any;
    } = {
        [key: string]: any;
    }, TProps extends IViewGroup = IViewGroup> extends ViewAndroid<TEvent | ViewGroupEvents, TNative, TProps> implements IViewGroup {
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
            readonly ViewAdded: "viewAdded";
            readonly ViewRemoved: "viewRemoved";
        };
        childViews: Record<string, View>;
        constructor(params?: Partial<TProps>);
        onViewAdded: IViewGroup['onViewAdded'];
        onViewRemoved: IViewGroup['onViewRemoved'];
        updateRippleEffectIfNeeded?: () => void;
        requestDisallowInterceptTouchEvent?(disallow: boolean): void;
        addChild(view: View): void;
        removeChild(view: IView): void;
        removeAll(): void;
        getChildCount(): any;
        getChildList(): View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<import("ui/view").IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>[];
        findChildById(id: any): View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<import("ui/view").IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>> | null;
        toString(): string;
        private setHierarchyChangeListener;
    }
}
declare module "ui/flexlayout/flexlayout.android" {
    import ViewGroupAndroid from "ui/viewgroup/viewgroup.android";
    import FlexLayout, { IFlexLayout } from "ui/flexlayout/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    export default class FlexLayoutAndroid<TEvent extends string = FlexLayoutEvents, TNative = any, TProps extends IFlexLayout = IFlexLayout> extends ViewGroupAndroid<TEvent | FlexLayoutEvents, TNative, TProps> implements IFlexLayout {
        private _onInterceptTouchEvent;
        private _flexWrap;
        constructor(params?: Partial<TProps>);
        content: FlexLayout;
        get direction(): any;
        set direction(direction: any);
        get flexDirection(): any;
        set flexDirection(flexDirection: any);
        get justifyContent(): any;
        set justifyContent(justifyContent: any);
        get alignContent(): any;
        set alignContent(alignContent: any);
        get alignItems(): any;
        set alignItems(alignItems: any);
        get flexWrap(): number | null;
        set flexWrap(flexWrap: number | null);
        toString(): string;
        protected _masksToBounds: boolean;
        _nativeObject: any;
    }
}
declare module "ui/flexlayout/flexlayout.ios" {
    import IView from "ui/view/index";
    import ViewGroupIOS from "ui/viewgroup/viewgroup.ios";
    import { IFlexLayout } from "ui/flexlayout/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    class FlexLayoutIOS<TEvent extends string = FlexLayoutEvents, TNative = any, TProps extends IFlexLayout = IFlexLayout> extends ViewGroupIOS<TEvent | FlexLayoutEvents, TNative, TProps> implements IFlexLayout {
        constructor(params?: Partial<TProps>);
        content: IFlexLayout;
        onViewAdded: (view: IView) => void;
        onViewRemoved: (view: IView) => void;
    }
    /**
    // YG Enums are inherited from UIView
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.Direction = {};
    
    Object.defineProperty(FlexLayout.Direction, 'INHERIT', {
      get: function () {
        return YogaEnums.YGDirection.Inherit;
      }
    });
    Object.defineProperty(FlexLayout.Direction, 'LTR', {
      get: function () {
        return YogaEnums.YGDirection.LTR;
      }
    });
    Object.defineProperty(FlexLayout.Direction, 'RTL', {
      get: function () {
        return YogaEnums.YGDirection.RTL;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.PositionType = {};
    
    Object.defineProperty(FlexLayout.PositionType, 'RELATIVE', {
      get: function () {
        return YogaEnums.YGPositionType.Relative;
      }
    });
    Object.defineProperty(FlexLayout.PositionType, 'ABSOLUTE', {
      get: function () {
        return YogaEnums.YGPositionType.Absolute;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.FlexDirection = {};
    
    Object.defineProperty(FlexLayout.FlexDirection, 'ROW', {
      get: function () {
        return YogaEnums.YGFlexDirection.Row;
      }
    });
    Object.defineProperty(FlexLayout.FlexDirection, 'ROW_REVERSE', {
      get: function () {
        return YogaEnums.YGFlexDirection.RowReverse;
      }
    });
    Object.defineProperty(FlexLayout.FlexDirection, 'COLUMN', {
      get: function () {
        return YogaEnums.YGFlexDirection.Column;
      }
    });
    Object.defineProperty(FlexLayout.FlexDirection, 'COLUMN_REVERSE', {
      get: function () {
        return YogaEnums.YGFlexDirection.ColumnReverse;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.JustifyContent = {};
    
    Object.defineProperty(FlexLayout.JustifyContent, 'FLEX_START', {
      get: function () {
        return YogaEnums.YGJustify.FlexStart;
      }
    });
    Object.defineProperty(FlexLayout.JustifyContent, 'FLEX_END', {
      get: function () {
        return YogaEnums.YGJustify.FlexEnd;
      }
    });
    Object.defineProperty(FlexLayout.JustifyContent, 'CENTER', {
      get: function () {
        return YogaEnums.YGJustify.Center;
      }
    });
    Object.defineProperty(FlexLayout.JustifyContent, 'SPACE_BETWEEN', {
      get: function () {
        return YogaEnums.YGJustify.SpaceBetween;
      }
    });
    Object.defineProperty(FlexLayout.JustifyContent, 'SPACE_AROUND', {
      get: function () {
        return YogaEnums.YGJustify.SpaceAround;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.AlignContent = {};
    
    Object.defineProperty(FlexLayout.AlignContent, 'AUTO', {
      get: function () {
        return YogaEnums.YGAlign.Auto;
      }
    });
    Object.defineProperty(FlexLayout.AlignContent, 'FLEX_START', {
      get: function () {
        return YogaEnums.YGAlign.FlexStart;
      }
    });
    Object.defineProperty(FlexLayout.AlignContent, 'FLEX_END', {
      get: function () {
        return YogaEnums.YGAlign.FlexEnd;
      }
    });
    Object.defineProperty(FlexLayout.AlignContent, 'CENTER', {
      get: function () {
        return YogaEnums.YGAlign.Center;
      }
    });
    Object.defineProperty(FlexLayout.AlignContent, 'STRETCH', {
      get: function () {
        return YogaEnums.YGAlign.Stretch;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.AlignItems = {};
    
    Object.defineProperty(FlexLayout.AlignItems, 'AUTO', {
      get: function () {
        return YogaEnums.YGAlign.Auto;
      }
    });
    Object.defineProperty(FlexLayout.AlignItems, 'FLEX_START', {
      get: function () {
        return YogaEnums.YGAlign.FlexStart;
      }
    });
    Object.defineProperty(FlexLayout.AlignItems, 'FLEX_END', {
      get: function () {
        return YogaEnums.YGAlign.FlexEnd;
      }
    });
    Object.defineProperty(FlexLayout.AlignItems, 'CENTER', {
      get: function () {
        return YogaEnums.YGAlign.Center;
      }
    });
    Object.defineProperty(FlexLayout.AlignItems, 'BASELINE', {
      get: function () {
        return YogaEnums.YGAlign.Baseline;
      }
    });
    Object.defineProperty(FlexLayout.AlignItems, 'STRETCH', {
      get: function () {
        return YogaEnums.YGAlign.Stretch;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.FlexWrap = {};
    
    Object.defineProperty(FlexLayout.FlexWrap, 'NOWRAP', {
      get: function () {
        return YogaEnums.YGWrap.NoWrap;
      }
    });
    Object.defineProperty(FlexLayout.FlexWrap, 'WRAP', {
      get: function () {
        return YogaEnums.YGWrap.Wrap;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.Display = {};
    
    Object.defineProperty(FlexLayout.Display, 'FLEX', {
      get: function () {
        return YogaEnums.YGDisplay.Flex;
      }
    });
    Object.defineProperty(FlexLayout.Display, 'NONE', {
      get: function () {
        return YogaEnums.YGDisplay.None;
      }
    });
    ////////////////////////////////////////////////////////////////////////
    FlexLayout.AlignSelf = {};
    
    Object.defineProperty(FlexLayout.AlignSelf, 'AUTO', {
      get: function () {
        return YogaEnums.YGAlign.Auto;
      }
    });
    Object.defineProperty(FlexLayout.AlignSelf, 'FLEX_START', {
      get: function () {
        return YogaEnums.YGAlign.FlexStart;
      }
    });
    Object.defineProperty(FlexLayout.AlignSelf, 'FLEX_END', {
      get: function () {
        return YogaEnums.YGAlign.FlexEnd;
      }
    });
    Object.defineProperty(FlexLayout.AlignSelf, 'CENTER', {
      get: function () {
        return YogaEnums.YGAlign.Center;
      }
    });
    Object.defineProperty(FlexLayout.AlignSelf, 'BASELINE', {
      get: function () {
        return YogaEnums.YGAlign.Baseline;
      }
    });
    Object.defineProperty(FlexLayout.AlignSelf, 'STRETCH', {
      get: function () {
        return YogaEnums.YGAlign.Stretch;
      }
    });
    ////////////////////////////////////////////////////////////////////////
     */
    export default FlexLayoutIOS;
}
declare module "ui/font/font.android" {
    import { AbstractFont, FontStyle } from "ui/font/font";
    export default class FontAndroid extends AbstractFont {
        static create(fontFamily: string, size: number, style: FontStyle): FontAndroid;
        static createFromFile(path: string, size: number): FontAndroid;
        static DEFAULT: FontStyle.DEFAULT;
        static IOS_SYSTEM_FONT: FontStyle.IOS_SYSTEM_FONT;
        static NORMAL: FontStyle.NORMAL;
        static BOLD: FontStyle.BOLD;
        static ITALIC: FontStyle.ITALIC;
        static BOLD_ITALIC: FontStyle.BOLD_ITALIC;
    }
}
declare module "ui/font/font.ios" {
    import { AbstractFont, FontStyle } from "ui/font/font";
    export default class FontIOS extends AbstractFont {
        static create(fontFamily: string, size: number, style: FontStyle): FontIOS | null;
        static createFromFile(path: string, size: number): AbstractFont;
        static ios: {
            allFontNames(): string[];
        };
        static DEFAULT: FontStyle.DEFAULT;
        static IOS_SYSTEM_FONT: FontStyle.IOS_SYSTEM_FONT;
        static NORMAL: FontStyle.NORMAL;
        static BOLD: FontStyle.BOLD;
        static ITALIC: FontStyle.ITALIC;
        static BOLD_ITALIC: FontStyle.BOLD_ITALIC;
    }
}
declare module "ui/gifimage/index" {
    import { INativeComponent } from "core/inative-component";
    import { MobileOSProps, NativeMobileComponent } from "core/native-mobile-component";
    import Blob from "global/blob/index";
    import { BlobBase } from "global/blob/blob";
    import File from "io/file/index";
    import { Size } from "primitive/size";
    import Image from "ui/image/index";
    export type iOSProps = {
        /**
         * Gets the frameCacheSizeCurrent of gifImage.
         * @ios
         * @since 3.2.0
         */
        frameCacheSizeCurrent?: number;
        /**
         * Returns delay times for indexes.
         * @ios
         * @since 3.2.0
         */
        getDelayTimesForIndexes?(): any;
    };
    export type AndroidProps = {
        /**
         * Seeks animation to given absolute position.
         * @android
         * @since 3.2.0
         */
        seekTo?: number;
        /**
         * Sets/Gets new animation speed factor. For example, set 2 to speed up double into current speed.
         * @android
         * @since 3.2.0
         */
        speed?: number;
        drawable?: any;
        content?: File | Blob;
        /**
         * Restarts the GifImage.
         * @android
         * @since 3.2.0
         */
        reset?(): void;
    };
    export interface IGifImage extends INativeComponent, MobileOSProps<iOSProps, AndroidProps> {
        /**
         * Gets/Sets the loopCount of gifImage. This property is readonly on iOS.
         * @android
         * @ios
         * @since 3.2.0
         */
        loopCount: number;
        /**
         * Gets/Sets the frameCount of gifImage.
         * @android
         * @ios
         * @since 3.2.0
         */
        frameCount: number;
        /**
         * Gets/Sets the posterImage of gifImage.
         * @android
         * @ios
         * @since 3.2.0
         */
        posterImage: Image;
        /**
         * Gets/Sets the instrinsicSize of gifImage.
         * @android
         * @ios
         * @since 3.2.0
         */
        instrinsicSize: Size;
        /**
         * Returns a Blob instance.
         * @android
         * @ios
         * @since 3.2.0
         */
        toBlob(): Blob | null;
    }
    export abstract class AbstractGifImage extends NativeMobileComponent<any, IGifImage> implements IGifImage {
        constructor(params?: Partial<IGifImage>);
        /**
         * Creates an gifImage object from given a blob.
         *
         * @param {Blob} blob Contains gif datas.
         * @method createFromBlob
         * @return UI.GifImage
         * @static
         * @android
         * @ios
         * @since 3.2.0
         */
        static createFromBlob(blob: Blob): AbstractGifImage | null;
        /**
         * Creates an GifImage instance from given file path. GifImage's file should not be in images folder. You can use assets folder.
         *
         *     @example
         *     import GifImage from '@smartface/native/ui/gifimage';
         *     const myGifImage = GifImage.createFromFile("assets://smartface.gif");
         *
         * @param {String|IO.File} path GifImage file path
         * @method createFromFile
         * @return {UI.GifImage} An GifImage instance.
         * @android
         * @ios
         * @static
         * @since 3.2.0
         */
        static createFromFile(path: string, width?: number, height?: number): AbstractGifImage | null;
        get loopCount(): number;
        set loopCount(value: number);
        get frameCount(): number;
        get posterImage(): Image;
        get instrinsicSize(): Size;
        toBlob(): BlobBase | null;
        static get android(): AndroidProps | undefined;
        static get ios(): iOSProps | undefined;
    }
    /**
     * @class UI.GifImage
     * @since 3.2.0
     *
     * GifImage is used to store the gif data read from the filesystem.
     * It can be set to UI objects' properties (e.g. UI.GifImageView.gifImage).
     * GifImage's file should not be in images folder. You can use assets folder.
     *
     *     @example
     *     import GifImage from '@smartface/native/ui/gifimage';
     *     import GifImageView from '@smartface/native/ui/gifimageview';
     *
     *     const myGifImage = GifImage.createFromFile("assets://smartface.gif")
     *     const myGifImageView = new GifImageView({
     *         gifImage: myGifImage,
     *         width: 200, height: 200
     *     });
     *
     *     myPage.layout.addChild(myGifImageView);
     *
     */
    class GifImageImpl extends AbstractGifImage {
    }
    const GifImage: typeof GifImageImpl;
    type GifImage = GifImageImpl;
    export default GifImage;
}
declare module "ui/gifimage/gifimage.android" {
    import Blob from "global/blob/index";
    import Image from "ui/image/index";
    import { AndroidProps, AbstractGifImage, IGifImage, iOSProps } from "ui/gifimage/index";
    import { Size } from "primitive/size";
    export default class GifImageAndroid extends AbstractGifImage {
        private _content;
        private _seekPosition;
        private _speed;
        constructor(params?: Partial<IGifImage>);
        static createFromFile(path: string, width?: number, height?: number): GifImageAndroid | null;
        static createFromBlob(blob: Blob): GifImageAndroid | null;
        get loopCount(): number;
        set loopCount(value: number);
        get frameCount(): number;
        get posterImage(): Image;
        get instrinsicSize(): Size;
        toBlob(): import("global/blob/blob").BlobBase | null;
        get android(): AndroidProps;
        get ios(): iOSProps;
    }
}
declare module "ui/image/image.ios" {
    import IBlob from "global/blob/blob";
    import BlobIOS from "global/blob/blob.ios";
    import IImage, { AbstractImage, Format, ImageAndroidProps } from "ui/image/index";
    /**
     * @since 4.5.0
     */
    class ImageiOS extends AbstractImage<__SF_UIImage> implements IImage {
        static createFromFile: (path: any) => any;
        static createFromName: (name: string) => ImageiOS;
        static createFromImage(image: string): ImageiOS;
        static createFromBlob(blob: IBlob): ImageiOS;
        static readandroid: {
            createRoundedImage: () => void;
        };
        private _flippedImage;
        private _nativeImage;
        private _autoMirrored;
        constructor(params: any);
        get android(): ImageAndroidProps;
        createSystemIcon(): this;
        get ios(): {
            resizableImageWithCapInsetsResizingMode: (capinsets: any, resizingMode: any) => ImageiOS;
            imageWithRenderingMode(value: any): ImageiOS;
            imageFlippedForRightToLeftLayoutDirection(): ImageiOS;
            readonly renderingMode: any;
            readonly flipsForRightToLeftLayoutDirection: any;
        };
        resize(width: number, height: number, onSuccess?: (e: {
            image: IImage;
        }) => void, onFailure?: (e?: {
            message: string;
        }) => void): ImageiOS | null;
        crop(x: number, y: number, width: number, height: number, onSuccess: (e: {
            image: IImage;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): ImageiOS | null;
        rotate(angle: number, onSuccess: (e: {
            image: IImage;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): ImageiOS | null;
        compress(format: Format, quality: number, onSuccess: (e: {
            blob: IBlob;
        }) => void, onFailure: (e?: {
            message: string;
        }) => void): BlobIOS | null;
        toBlob(): BlobIOS | null;
        set autoMirrored(value: boolean);
        get autoMirrored(): boolean;
    }
    export default ImageiOS;
}
declare module "ui/gifimage/gifimage.ios" {
    import Image from "ui/image/index";
    import Blob from "global/blob/index";
    import { AndroidProps, AbstractGifImage, IGifImage, iOSProps } from "ui/gifimage/index";
    import { Size } from "primitive/size";
    export default class GifImageIOS extends AbstractGifImage {
        constructor(params?: Partial<IGifImage>);
        static createFromFile(path: string): GifImageIOS;
        static createFromBlob(blob: Blob): GifImageIOS;
        get loopCount(): number;
        set loopCount(value: number);
        get frameCount(): number;
        get posterImage(): Image;
        get instrinsicSize(): Size;
        get ios(): iOSProps;
        get android(): AndroidProps;
    }
}
declare module "ui/imageview/imageview-events" {
    export const ImageViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type ImageViewEvents = ExtractValues<typeof ImageViewEvents>;
}
declare module "ui/gifimageview/gifimageview-events" {
    export const GifImageViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type GifImageViewEvents = ExtractValues<typeof GifImageViewEvents>;
}
declare module "ui/shared/imagecachetype" {
    /**
     * @class UI.ImageCacheType
     * @since 3.0.3
     */
    enum ImageCacheType {
        /**
         * The image wasn't available thecaches, but was downloaded from the web.
         *
         * @property {Number} NONE
         * @android
         * @ios
         * @static
         * @readonly
         * @since 3.0.3
         */
        NONE = 0,
        /**
         * The image was obtained from the disk cache.
         *
         * @property {Number} DISK
         * @android
         * @ios
         * @static
         * @readonly
         * @since 3.0.3
         */
        DISK = 1,
        /**
         * The image was obtained from the memory cache.
         *
         * @property {Number} MEMORY
         * @android
         * @ios
         * @static
         * @readonly
         * @since 3.0.3
         */
        MEMORY = 2,
        NETWORK = 3
    }
    export default ImageCacheType;
}
declare module "ui/imageview/index" {
    import { AbstractView, IView } from "ui/view/index";
    import type { IImage } from "ui/image/index";
    import Color from "ui/color/index";
    import File from "io/file/index";
    import ImageCacheType from "ui/shared/imagecachetype";
    import { ImageViewEvents } from "ui/imageview/imageview-events";
    import { MobileOSProps } from "core/native-mobile-component";
    export enum ImageViewFillTypeIOS {
        REDRAW = 3,
        /**
         * @property {Number} MIDCENTER
         * @ios
         * The source image position will be mid center. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        MIDCENTER = 4,
        /**
         * @property {Number} TOPCENTER
         * @ios
         * The source image position will be top center. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        TOPCENTER = 5,
        /**
         * @property {Number} BOTTOMCENTER
         * @ios
         * The source image position will be bottom center. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        BOTTOMCENTER = 6,
        /**
         * @property {Number} MIDLEFT
         * @ios
         * The source image position will be mid left. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        MIDLEFT = 7,
        /**
         * @property {Number} MIDRIGHT
         * @ios
         * The source image position will be mid right. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        MIDRIGHT = 8,
        /**
         * @property {Number} TOPLEFT
         * @ios
         * The source image position will be top center. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        TOPLEFT = 9,
        /**
         * @property {Number} TOPRIGHT
         * @ios
         * The source image position will be top right. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        TOPRIGHT = 10,
        /**
         * @property {Number} BOTTOMLEFT
         * @ios
         * The source image position will be bottom left. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        BOTTOMLEFT = 11,
        /**
         * @property {Number} BOTTOMRIGHT
         * @ios
         * The source image position will be bottom right. Works only for iOS.
         * @static
         * @readonly
         * @ios
         * @since 0.1
         */
        BOTTOMRIGHT = 12
    }
    /**
     * @enum {Number} UI.ImageView.FillType
     * @since 0.1
     * FillType is an enum. It defines the fill type of an UI.Image inside its parent.
     *
     *     @example
     *     const ImageView = require('@smartface/native/ui/imageview');
     *     const Image = require('@smartface/native/ui/image');
     *
     *     var myImage = Image.createFromFile("images://smartface.png")
     *     var myImageView = new ImageView({
     *         image: myImage,
     *         imageFillType: ImageView.FillType.NORMAL,
     *         width:200, height: 200
     *     });
     *     myPage.layout.addChild(myImageView);
     *
     */
    export enum ImageViewFillType {
        /**
         * @property {Number} NORMAL
         * @android
         * @ios
         * The source image will be displayed in its normal dimensions inside the parent.
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        NORMAL = 0,
        /**
         * @property {Number} STRETCH
         * @android
         * @ios
         * The source image will be stretched to the size of the parent.
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        STRETCH = 1,
        /**
         * @property {Number} ASPECTFIT
         * @android
         * @ios
         * The source image will grow by saving its aspect ratio until the image is at its max size inside the parent.
         * @static
         * @readonly
         * @android
         * @ios
         * @since 0.1
         */
        ASPECTFIT = 2,
        /**
         * @property {Number} ASPECTFILL
         * @android
         * @ios
         * The option to scale the content to fill the size of the view. Some portion of the content may be clipped to fill the views bounds.
         * @static
         * @readonly
         * @android
         * @ios
         * @since 3.0.2
         */
        ASPECTFILL = 3
    }
    export interface IImageView<TEvent extends string = ImageViewEvents, TNative extends {
        [key: string]: any;
    } = any, TMobile extends MobileOSProps<IView['ios'], IView['android']> = MobileOSProps<IView['ios'], IView['android']>> extends IView<TEvent | ImageViewEvents, TNative, TMobile> {
        /**
         * Gets/sets the image. Path of image or Image object can be set. Setting "image path"
         * to this property will be beneficial in terms of performance.
         *
         *     @example
         *     const Image = require('@smartface/native/ui/image');
         *     const ImageView = require('@smartface/native/ui/imageView');
         *
         *     var myImage = Image.createFromFile("images://smartface.png");
         *     var myImageView = new ImageView({
         *         width: 200, height: 200
         *     });
         *     myImageView.image = myImage; //OR myImageView.image = "images://smartface.png"
         *
         *     myPage.layout.addChild(myImageView);
         *
         * @property {UI.Image | Null}  [image = null]
         * @android
         * @ios
         * @since 0.1
         */
        image: IImage | null;
        /**
         * Gets/sets the tintColor.
         *
         *     @example
         *     const ImageView = require('@smartface/native/ui/imageview');
         *     const Image = require('@smartface/native/ui/image');
         *     const Color = require('@smartface/native/ui/color');
         *     const System = require('@smartface/native/device/system');
         *
         *     var image = Image.createFromFile("images://smartface.png");
         *
         *     var imageView = new ImageView();
         *     imageView.flexGrow = 1;
         *     imageView.tintColor = Color.RED;
         *     imageView.image = image;
         *
         * @property {UI.Color} tintColor
         * @android
         * @ios
         * @since 3.1.3
         */
        tintColor: Color | null;
        /**
         * Gets/sets image fill type.
         *
         *     @example
         *     const Image = require('@smartface/native/ui/image');
         *     const ImageView = require('@smartface/native/ui/imageview');
         *
         *     var myImage = Image.createFromFile("images://smartface.png")
         *     var myImageView = new ImageView({
         *         image: myImage,
         *         width: 200, height: 200
         *     });
         *     myImageView.imageFillType = ImageView.FillType.STRETCH;
         *
         *     myPage.layout.addChild(myImageView);
         *
         * @property {UI.ImageView.FillType} [imageFillType = UI.ImageView.FillType.NORMAL]
         * @android
         * @ios
         * @since 0.1
         */
        imageFillType: ImageViewFillTypeIOS | ImageViewFillType;
        /**
         * Load image from the server and place the returned image into the ImageView.
         * If you pass any image to placeHolder parameter, placeHolder image will shown until image loaded.
         *
         * @method loadFromUrl
         * @param {Object} object
         * @param {String} object.url
         * @param {Object} object.headers Headers to load the image with. e.g. { Authorization: 'someAuthToken' }.
         * @param {UI.Image} object.placeholder
         * @param {Boolean} object.fade = true
         * @param {Boolean} object.useHTTPCacheControl  if it is true then enables http cache control mechanism  and behaves as given directives of Cache-Control header in response. This argument overrides the useDiskCache argument.
         * @param {Function} object.onSuccess
         * @param {Function} object.onFailure
         * @param {Object} object.android Android specific argument
         * @param {boolean} object.android.useDiskCache Designates the using of disk cache.
         * @param {boolean} object.android.useMemoryCache Designates the using of memory cache.
         * @android
         * @ios
         * @since 3.1.3
         */
        loadFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            fade?: boolean;
            useHTTPCacheControl?: boolean;
            onSuccess?: () => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
        /**
         * Load image from the file and place the returned image into the ImageView.
         *
         * @method loadFromFile
         * @param {Object} object
         * @param {IO.File} object.file
         * @param {Boolean} object.fade = true
         * @param {Number} object.width
         * @param {Number} object.height
         * @param {Object} object.android Android specific argument
         * @param {useMemoryCache?: boolean} object.android.useMemoryCache Designates the using of memory cache.
         * @android
         * @ios
         * @since 3.1.0
         */
        loadFromFile(params: {
            file: File;
            fade?: boolean;
            width?: number;
            height?: number;
            android?: {
                useMemoryCache?: boolean;
            };
        }): void;
        /**
         * Fetch image from the server.
         * If you want better performance and automatically set image, use loadFromUrl.
         * If you pass any image to placeHolder parameter, placeHolder image will shown until image loaded.
         * In Android, this method is not recommended to use in listview.
         *
         * @method fetchFromUrl
         * @param {Object} object
         * @param {String} object.url
         * @param {Object} object.headers Headers to load the image with. e.g. { Authorization: 'someAuthToken' }.
         * @param {Boolean} object.useHTTPCacheControl  if it is true then enables http cache control mechanism  and behaves as given directives of Cache-Control header in response. This argument overrides the useDiskCache argument.
         * @param {UI.Image} object.placeholder
         * @param {Function} object.onSuccess
         * @param {UI.Image} object.onSuccess.image
         * @param {UI.ImageCacheType} object.onSuccess.cache
         * @param {Function} object.onFailure
         * @param {Object} object.android Android specific argument
         * @param {boolean} object.android.useDiskCache Designates the using of disk cache.
         * @param {boolean} object.android.useMemoryCache Designates the using of memory cache.
         * @android
         * @ios
         * @since 3.0.2
         */
        fetchFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            useHTTPCacheControl?: boolean;
            onSuccess?: (image: IImage, cache: ImageCacheType) => void;
            onFailure?: () => void;
            image: any;
            cache: ImageCacheType;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
    }
    export class AbstractImageView<TEvent extends string = ImageViewEvents> extends AbstractView<TEvent> implements IImageView<TEvent> {
        static FillType: {
            ios: typeof ImageViewFillTypeIOS;
        } & typeof ImageViewFillType;
        image: null | IImage;
        tintColor: Color;
        imageFillType: ImageViewFillTypeIOS | ImageViewFillType;
        loadFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            fade?: boolean;
            useHTTPCacheControl?: boolean;
            onSuccess?: () => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
        loadFromFile(params: {
            file: File;
            fade?: boolean;
            width?: number;
            height?: number;
            android?: {
                useMemoryCache?: boolean;
            };
        }): void;
        fetchFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            useHTTPCacheControl?: boolean;
            onSuccess?: (image: IImage, cache: ImageCacheType) => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
    }
    /**
     * @since 0.1
     * ImageView is simply an image container where UI.Image is displayed inside.
     *
     *     @example
     *     import Image from '@smartface/native/ui/image';
     *     import ImageView from '@smartface/native/ui/imageview';
     *
     *     const myImage = Image.createFromFile("images://smartface.png")
     *     const myImageView = new ImageView({
     *         image: myImage,
     *         left: 0, width: 300, height: 400
     *     });
     *
     *     myPage.layout.addChild(myImageView);
     *
     */
    const ImageView: typeof AbstractImageView;
    type ImageView = AbstractImageView;
    export default ImageView;
}
declare module "ui/gifimageview/index" {
    import { AbstractImageView, IImageView } from "ui/imageview/index";
    import GifImage from "ui/gifimage/index";
    import { IImage } from "ui/image/index";
    import Color from "ui/color/index";
    import { GifImageViewEvents } from "ui/gifimageview/gifimageview-events";
    export interface IGifImageView<TEvent extends string = GifImageViewEvents> extends IImageView<TEvent | GifImageViewEvents> {
        /**
         * Gets/sets the gifImage. GifImage object can be set.
         *
         * @property {UI.GifImage}  [gifImage = undefined]
         * @android
         * @ios
         * @since 3.2.0
         */
        gifImage: undefined | GifImage;
        /**
         * Gets the currentFrame.
         *
         * @property {UI.Image}  currentFrame
         * @readonly
         * @android
         * @ios
         * @since 3.2.0
         */
        readonly currentFrame: IImage;
        /**
         * Gets the currentFrameIndex.
         *
         * @property {Number}  currentFrameIndex
         * @readonly
         * @android
         * @ios
         * @since 3.2.0
         */
        readonly currentFrameIndex: number;
        /**
         * Gets the isAnimating.
         *
         * @property {Boolean}  isAnimating
         * @readonly
         * @android
         * @ios
         * @since 3.2.0
         */
        isAnimating: boolean;
        /**
         * You should call this method when you want start gif's animation.
         *
         * @method startAnimating
         * @android
         * @ios
         * @since 3.2.0
         */
        startAnimating(): void;
        /**
         * You should call this method when you want stop gif's animation.
         *
         * @method stopAnimating
         * @android
         * @ios
         * @since 3.2.0
         */
        stopAnimating(): void;
        /**
         * This event is called when every gif's loop ends.
         *
         * @event loopCompletionCallback
         * @param {Number} loopCountRemaining
         * @ios
         * @since 3.2.0
         */
        loopCompletionCallback: (loopCountRemain: number) => void;
        /**
         * Gets/sets the tintColor. Must create a new image object with the imageWithRenderingMode(Image.iOS.RenderingMode.TEMPLATE) method to work correctly on the iOS.
         *
         * @property {UI.Color} tintColor
         * @android
         * @removed
         * @ios
         * @since 3.2.0
         */
        tintColor: Color;
        /**
         * Load image from the server and place the returned image into the ImageView.
         * If you pass any image to placeHolder parameter, placeHolder image will shown until image loaded.
         *
         * @method loadFromUrl
         * @param {Object} object
         * @param {String} object.url
         * @param {UI.Image} object.placeholder
         * @param {Boolean} object.fade = true
         * @param {Function} object.onSuccess
         * @param {Function} object.onError
         * @android
         * @removed
         * @ios
         * @since 3.2.0
         */
        loadFromUrl(params: {
            url: string;
            placeholder?: IImage;
            fade?: boolean;
            onSuccess?: () => void;
            onError?: () => void;
        }): void;
    }
    export abstract class AbstractGifImageView<TEvent extends string = GifImageViewEvents> extends AbstractImageView<TEvent> implements IGifImageView<TEvent> {
        startAnimating(): void;
        stopAnimating(): void;
        gifImage: undefined | GifImage;
        readonly currentFrame: IImage;
        readonly currentFrameIndex: number;
        isAnimating: boolean;
        loopCompletionCallback: (loopCountRemain: number) => void;
        tintColor: Color;
    }
    /**
     * @class UI.GifImageView
     * @extends UI.ImageView
     * @since 3.2.0
     *
     * GifImageView is simply an gifimage container where UI.GifImage is displayed inside.
     *
     *     @example
     *     import GifImage from '@smartface/native/ui/gifimage';
     *     import GifImageView from '@smartface/native/ui/gifimageview';
     *
     *     const myGifImage = GifImage.createFromFile("assets://smartface.gif")
     *     const myGifImageView = new GifImageView({
     *         gifImage: myGifImage,
     *         width: 200, height: 200
     *     });
     *
     *     myPage.layout.addChild(myGifImageView);
     *
     */
    class GifImageViewImpl extends AbstractGifImageView {
    }
    const GifImageView: typeof GifImageViewImpl;
    type GifImageView = GifImageViewImpl;
    export default GifImageView;
}
declare module "ui/imageview/imageview.android" {
    import { IImageView, ImageViewFillType, ImageViewFillTypeIOS } from "ui/imageview/index";
    import { INativeComponent } from "core/inative-component";
    import File from "io/file/index";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import ImageCacheType from "ui/shared/imagecachetype";
    import { ViewAndroid } from "ui/view/view.android";
    import { ImageViewEvents } from "ui/imageview/imageview-events";
    export default class ImageViewAndroid<TEvent extends string = ImageViewEvents> extends ViewAndroid<TEvent | ImageViewEvents> implements IImageView {
        private _fillType;
        private _image;
        private _adjustViewBounds;
        private _tintColor;
        private _newImageLoaded;
        constructor(params?: Partial<IImageView>);
        get image(): string | Image;
        set image(value: string | Image);
        get tintColor(): Color;
        set tintColor(value: Color);
        get imageFillType(): ImageViewFillTypeIOS | ImageViewFillType;
        set imageFillType(value: ImageViewFillTypeIOS | ImageViewFillType);
        loadFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: Image;
            fade?: boolean;
            useHTTPCacheControl?: boolean;
            onSuccess?: () => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
        loadFromFile(params: {
            placeholder?: INativeComponent;
            file: File;
            fade?: boolean;
            width?: number;
            height?: number;
            android?: {
                useMemoryCache?: boolean;
            };
        }): void;
        fetchFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: Image;
            useHTTPCacheControl?: boolean;
            onSuccess?: (image: Image, cache: ImageCacheType) => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
        }): void;
        getCacheTypeByName(cacheName: string): ImageCacheType.DISK | ImageCacheType.MEMORY | ImageCacheType.NETWORK;
        toString(): string;
    }
}
declare module "ui/gifimageview/gifimageview.android" {
    import { IGifImageView } from "ui/gifimageview/index";
    import GifImage from "ui/gifimage/index";
    import { IImage } from "ui/image/index";
    import ImageViewAndroid from "ui/imageview/imageview.android";
    import { GifImageViewEvents } from "ui/gifimageview/gifimageview-events";
    export default class GifImageViewAndroid<TEvent extends string = GifImageViewEvents> extends ImageViewAndroid<TEvent | GifImageViewEvents> implements IGifImageView {
        private _gifImage;
        constructor(params?: Partial<IGifImageView>);
        get gifImage(): GifImage;
        set gifImage(value: GifImage);
        get currentFrame(): IImage;
        get currentFrameIndex(): number;
        get isAnimating(): boolean;
        startAnimating(): void;
        stopAnimating(): void;
        loopCompletionCallback(loopCountRemain: number): void;
    }
}
declare module "ui/imageview/imageview.ios" {
    import { IImageView, ImageViewFillType, ImageViewFillTypeIOS } from "ui/imageview/index";
    import File from "io/file/index";
    import Color from "ui/color/index";
    import { IImage } from "ui/image/index";
    import ImageCacheType from "ui/shared/imagecachetype";
    import ViewIOS from "ui/view/view.ios";
    import { ImageViewEvents } from "ui/imageview/imageview-events";
    export default class ImageViewIOS<TEvent extends string = ImageViewEvents> extends ViewIOS<TEvent | ImageViewEvents, __SF_UIImageView, IImageView> implements IImageView {
        private _imageTemplate;
        private _isSetTintColor;
        constructor(params?: IImageView);
        get image(): IImage | null;
        set image(value: IImage | null);
        get tintColor(): Color;
        set tintColor(value: Color);
        get imageFillType(): ImageViewFillTypeIOS | ImageViewFillType;
        set imageFillType(value: ImageViewFillTypeIOS | ImageViewFillType);
        loadFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            fade?: boolean;
            useHTTPCacheControl?: boolean;
            onSuccess?: () => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
            cache?: ImageCacheType;
        }): void;
        loadFromFile(params: {
            file: File;
            fade?: boolean;
            width?: number;
            height?: number;
            android?: {
                useMemoryCache?: boolean;
            };
        }): void;
        fetchFromUrl(params: {
            url: string;
            headers?: {
                [name: string]: string;
            };
            placeholder?: IImage;
            useHTTPCacheControl?: boolean;
            onSuccess?: (image: IImage | null, cache: ImageCacheType) => void;
            onFailure?: () => void;
            android?: {
                useDiskCache?: boolean;
                useMemoryCache?: boolean;
            };
            ios?: {
                isRefreshCached?: boolean;
            };
            image: any;
            cache: ImageCacheType;
        }): void;
    }
}
declare module "ui/gifimageview/gifimageview.ios" {
    import { GifImageViewEvents } from "ui/gifimageview/gifimageview-events";
    import ImageViewIOS from "ui/imageview/imageview.ios";
    import { IGifImageView } from "ui/gifimageview/index";
    import GifImage from "ui/gifimage/index";
    import IImage from "ui/image/index";
    export default class GifImageViewIOS<TEvent extends string = GifImageViewEvents> extends ImageViewIOS<TEvent | GifImageViewEvents> implements IGifImageView {
        private _gifimage;
        private _loopCompletionCallback;
        constructor(params?: IGifImageView);
        get gifImage(): GifImage;
        set gifImage(value: GifImage);
        get currentFrame(): IImage;
        get currentFrameIndex(): number;
        get isAnimating(): boolean;
        startAnimating(): void;
        stopAnimating(): void;
        get loopCompletionCallback(): (loopCountRemain: number) => void;
        set loopCompletionCallback(value: (loopCountRemain: number) => void);
    }
}
declare module "ui/gridview/gridview-events" {
    export const GridViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly AttachedToWindow: "attachedToWindow";
        readonly DetachedFromWindow: "detachedFromWindow";
        readonly Gesture: "gesture";
        readonly PullRefresh: "pullRefresh";
        readonly ItemLongSelected: "itemLongSelected";
        readonly ItemSelected: "itemSelected";
        readonly Scroll: "scroll";
        readonly ScrollBeginDecelerating: "scrollBeginDecelerating";
        readonly ScrollBeginDragging: "scrollBeginDragging";
        readonly ScrollEndDecelerating: "scrollEndDecelerating";
        readonly ScrollEndDraggingWillDecelerate: "scrollEndDraggingWillDecelerate";
        readonly ScrollEndDraggingWithVelocityTargetContentOffset: "scrollEndDraggingWithVelocityTargetContentOffset";
        readonly ScrollStateChanged: "scrollStateChanged";
    };
    export type GridViewEvents = ExtractValues<typeof GridViewEvents>;
}
declare module "ui/gridviewitem/index" {
    import { ConstructorOf } from "core/constructorof";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import { IFlexLayout } from "ui/flexlayout/index";
    import { MobileOSProps } from "core/native-mobile-component";
    /**
     * @since 0.1
     *
     * GridViewItem class can used for a row layout of the GridView.
     * For a better performance, you should give id for all child views of GridViewItem.
     *
     * For example usage you can look {@link UI.GridView}.
     *
     */
    export interface IGridViewItem<TEvent extends string = FlexLayoutEvents, TMobile extends MobileOSProps<IFlexLayout['ios'], IFlexLayout['android']> = MobileOSProps<IFlexLayout['ios'], IFlexLayout['android']>> extends IFlexLayout<TEvent | FlexLayoutEvents, TMobile> {
        /**
         * Inner nativeObject. This property is only available for Android.
         * @android
         */
        nativeInner: any;
        /**
         *  Used internally. Holds the return value of the onItemType
         */
        viewType: number;
    }
    const GridViewItem: ConstructorOf<IGridViewItem, Partial<IGridViewItem>>;
    type GridViewItem = IGridViewItem;
    export default GridViewItem;
}
declare module "ui/layoutmanager/index" {
    import { Point2D } from "primitive/point2d";
    import { Boundary } from "primitive/boundary";
    import { INativeComponent } from "core/inative-component";
    import { MobileOSProps, NativeMobileComponent } from "core/native-mobile-component";
    export interface LayoutManagerIOSParams {
        /**
         * If you want the scrolling behavior to snap to specific boundaries, you can override this method and use it to change the point at which to stop.
         * For example, you might use this method to always stop scrolling on a boundary between items, as opposed to stopping in the middle of an item.For Android, you can use {@link UI.GridView#snapToAlignment}.
         * @event targetContentOffset
         * @deprecated
         * @ios
         * @since 3.2.0
         * @example
         * ````
         * import LayoutManager from '@smartface/native/ui/layoutmanager';
         *
         * const layoutManager = new LayoutManager();
         * layoutManager.on(LayoutManager.Events.TargetContentOffset, (params) => {
         *  console.info('targetContentOffset', params);
         * });
         * ````
         */
        targetContentOffset: (proposedContentOffset: Point2D, velocity: Point2D) => Point2D;
    }
    /**
     * Constants indicating the direction of scrolling for the layout.
     * @class UI.LayoutManager.ScrollDirection
     * @readonly
     * @ios
     * @since 3.0.2
     */
    export enum ScrollDirection {
        /**
         * @property {Number} HORIZONTAL
         * @ios
         * @static
         * @readonly
         * @since 3.0.2
         */
        HORIZONTAL = 0,
        /**
         * @property {Number} VERTICAL
         * @ios
         * @static
         * @readonly
         * @since 3.0.2
         */
        VERTICAL = 1
    }
    /**
     * @class UI.LayoutManager
     * @since 3.0.2
     * Layout calculation class for GridView. It behaves iOSs UICollectionViewFlowLayout and Androids StaggeredGridLayout.
     *
     * spanCount and scrollDirection are 2 important parameters of this class.
     *
     * If user sets scrollDirection to vertical, spanCount represents count of colons.
     * For example; scrollDirection: vertical, spanCount: 2 means user can scroll vertically, object has 2 colons and width property of items are fixed numbers depends on colon count.
     * If user sets scrollDirection to horizontal, spanCount represents count of rows.
     * For example; scrollDirection: horizontal, spanCount : 2 means user can scroll horizontally, object has 2 rows and height property of items are fixed numbers depends on row count
     *
     *      @example
     *      var layoutManager = new LayoutManager({
     *           spanCount: 2,
     *           scrollDirection: LayoutManager.ScrollDirection.VERTICAL
     *      });
     *
     *
     */
    export interface ILayoutManager extends INativeComponent, MobileOSProps<LayoutManagerIOSParams, {}> {
        /**
         * User must return a length value for scrollDirection that user lays out the objects.
         * If vertical, length value will be height of item. If horizontal, length value will be width of item.
         *
         * @event onItemLength
         * @android
         * @ios
         * @since 3.0.2
         * @example
         * ````
         * import LayoutManager from '@smartface/native/ui/layoutmanager';
         *
         * const layoutManager = new LayoutManager();
         * layoutManager.on(LayoutManager.Events.ItemLength, (params) => {
         *  console.info('onItemLength', params);
         * });
         * ````
         */
        onItemLength: null | ((length: number) => number);
        /**
         * This event used to define specified gridview item  to fully occupy width/height  based on direction. According to direction return value must be either desired height or width of gridview item. If the direction
         * is {@link UI.LayoutManager.ScrollDirection#VERTICAL VERTICAL} then return value must be height or vice versa. Returning undefined indicates that
         * the gridview item will not modified.
         *
         * @event onFullSpan
         * @android
         * @ios
         * @since 4.0.1
         * @example
         * ````
         * import LayoutManager from '@smartface/native/ui/layoutmanager';
         *
         * const layoutManager = new LayoutManager();
         * layoutManager.on(LayoutManager.Events.FullSpan, (params) => {
         *  console.info('onFullSpan', params);
         * });
         * ````
         */
        onFullSpan: null | ((type: number) => number);
        /**
         * Gets/sets colon or row count depends on scrolling direction of layout.
         * If vertical it represents colon, if horizontal it represent row count.
         *
         * @property {Number} [spanCount = 1]
         * @android
         * @ios
         * @since 3.0.2
         */
        spanCount: number;
        /**
         * Gets/sets the custom distance that the content view is inset from the scroll view edges.
         *
         * @property {Number} [contentInset = {top:0, left:0, bottom:0, right:0}]
         * @android
         * @ios
         * @since 3.0.2
         */
        contentInset: Boundary;
        /**
         * The scroll direction of GridView.
         *
         * @property {LayoutManager.ScrollDirection} [scrollDirection = 0]
         * @android
         * @ios
         * @since 3.0.2
         */
        scrollDirection: ScrollDirection;
        lineSpacing: number;
        itemSpacing: number;
    }
    export abstract class AbstractLayoutManager<TNative = any> extends NativeMobileComponent<TNative, ILayoutManager> implements ILayoutManager {
        abstract lineSpacing: number;
        abstract itemSpacing: number;
        abstract onItemLength: null | ((length: number) => number);
        abstract onFullSpan: null | ((type: number) => number);
        abstract spanCount: number;
        abstract contentInset: Boundary;
        abstract scrollDirection: ScrollDirection;
        static ScrollDirection: typeof ScrollDirection;
    }
    const LayoutManager: typeof AbstractLayoutManager;
    type LayoutManager = AbstractLayoutManager;
    export default LayoutManager;
}
declare module "ui/shared/android/scrollstate" {
    enum ScrollState {
        IDLE = 0,
        DRAGGING = 1,
        SETTLING = 2
    }
    export default ScrollState;
}
declare module "ui/shared/ios/decelerationrate" {
    enum DecelerationRate {
        NORMAL,
        FAST
    }
    export default DecelerationRate;
}
declare module "ui/gridview/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import GridViewItem from "ui/gridviewitem/index";
    import LayoutManager from "ui/layoutmanager/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import ScrollState from "ui/shared/android/scrollstate";
    import ContentInsetAdjustment from "ui/shared/ios/contentinsetadjustment";
    import DecelerationRate from "ui/shared/ios/decelerationrate";
    import { AbstractView, IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import { GridViewEvents } from "ui/gridview/gridview-events";
    /**
     * @enum UI.GridView.Android.SnapAlignment
     * @since 1.1.16
     *
     * This enum class used to specify your alignment of snapping.
     */
    export enum GridViewSnapAlignment {
        /**
         * This property will align the snap at the left (horizontal) or top (vertical).
         *
         * @property SNAPTO_START
         * @static
         * @readonly
         * @since 3.2.0
         */
        SNAPTO_START = 0,
        /**
         * This property will align the snap in the center.
         *
         * @property SNAPTO_CENTER
         * @static
         * @readonly
         * @since 3.2.0
         */
        SNAPTO_CENTER = 1,
        /**
         * This property  will align the snap at the right (horizontal) or bottom (vertical).
         *
         * @property SNAPTO_END
         * @static
         * @readonly
         * @since 3.2.0
         */
        SNAPTO_END = 2,
        /**
         * This property  will stop snapping.
         *
         * @property SNAPTO_NONE
         * @static
         * @readonly
         * @since 4.1.3
         */
        SNAPTO_NONE = 3
    }
    export interface IGridViewIOS extends ViewIOSProps {
        /**
         * A floating-point value that determines the rate of deceleration after the user lifts their finger.
         *
         * @property {UI.iOS.DecelerationRate} [decelerationRate = UI.iOS.DecelerationRate.NORMAL]
         * @ios
         * @since 4.1.2
         */
        decelerationRate: DecelerationRate;
        /**
         * Sets/Gets the bounce effect when scrolling.
         *
         * @property {Boolean} bounces
         * @ios
         * @since 3.2.1
         */
        bounces: boolean;
        /**
         * This event is called when the grid view is about to start scrolling the content.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDragging
         * @ios
         * @since 3.2.1
         */
        onScrollBeginDragging: (contentOffset: Point2D) => void;
        /**
         * This event is called when the grid view is starting to decelerate the scrolling movement.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDecelerating
         * @ios
         * @since 3.2.1
         */
        onScrollBeginDecelerating: (contentOffset: Point2D) => void;
        onScrollEndDecelerating: (contentOffset: Point2D) => void;
        onScrollEndDraggingWillDecelerate: (contentOffset: Point2D, decelerate: boolean) => void;
        /**
         * This event is called when the user finishes scrolling the content.
         *
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @param {Object} velocity
         * @param {Number} velocity.x
         * @param {Number} velocity.y
         * @param {Object} targetContentOffset
         * @param {Number} targetContentOffset.x
         * @param {Number} targetContentOffset.y
         * @event onScrollEndDraggingWithVelocityTargetContentOffset
         * @ios
         * @since 3.2.1
         */
        onScrollEndDraggingWithVelocityTargetContentOffset: (contentOffset: Point2D, velocity: Point2D, targetContentOffset: Point2D) => void;
        /**
         * The behavior for determining the adjusted content offsets.
         *
         * @property {UI.iOS.ContentInsetAdjustment} [contentInsetAdjustmentBehavior = UI.iOS.ContentInsetAdjustment.NEVER]
         * @ios
         * @since 4.0.0
         */
        contentInsetAdjustmentBehavior: ContentInsetAdjustment;
    }
    export interface IGridViewAndroid extends ViewAndroidProps {
        /**
         * This event is called when a GridView's scroll state is changed. To remove this evet, set null.
         * For better performance, don't set any callback if does not
         * necessary
         *
         * @event onScrollStateChanged
         * @param {UI.Android.ScrollState} newState
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @android
         * @since 3.2.1
         */
        onScrollStateChanged: (scrollState: ScrollState, contentOffset: Point2D) => void;
        /**
         * This event is called when user long selects a item at specific index.
         *
         * @param {UI.GridViewItem} gridViewItem
         * @param {Number} index
         * @event onItemLongSelected
         * @android
         * @since 3.0.2
         */
        onItemLongSelected: (selectedItem: GridViewItem, index?: number) => void;
        /**
         * This property allows snapping to behave as pager. There is slight difference in both OS. In Android, paginated gridview item should occupy spaces as much as gridview but iOS
         * scrolls all visible gridview items at once.
         *
         * @property {Boolean} [paginationEnabled = true]
         * @android
         * @ios
         * @since 4.1.4
         */
        paginationEnabled: boolean;
        /**
         * This property enables/disables snapping the center of the target child view to the center of the GridView in either vertical or horizontal orientation. For iOS, prefer to UI.LayoutManager.targetContentOffset
         *
         * @property {UI.GridView.Android.SnapAlignment} [snapToAlignment = UI.GridView.Android.SnapAlignment.SNAPTO_NONE]
         * @android
         * @since 3.2.0
         */
        snapToAlignment: GridViewSnapAlignment;
        /**
         * Called when the GridView should save its layout state. This is a good time to save your scroll position,
         * configuration and anything else that may be required to restore the same layout state if the GridView is recreated.
         *
         * @method saveInstanceState
         * @android
         * @return {Object}
         * @since 4.0.2
         */
        saveInstanceState(): any;
        /**
         * Called when the GridView should restore its layout state. This is a good time to restore your scroll position,
         * configuration and anything else that may be required to restore the same layout state if the GridView is recreated.
         *
         * @param {Object} state
         * @method restoreInstanceState
         * @android
         * @since 4.0.2
         */
        restoreInstanceState(state: any): void;
        /**
         * Gets/sets over-scroll mode for this view.
         *
         * @property {UI.Android.OverScrollMode} [overScrollMode = UI.Android.OverScrollMode.ALWAYS]
         * @android
         * @since 3.2.1
         */
        overScrollMode: OverScrollMode;
        /**
         * This event is called when a scroll occurs.
         *
         * @param {Object} params
         * @param {Number} distanceX The distance along the X axis that has been scrolled since the last scroll
         * @param {Number} distanceY The distance along the Y axis that has been scrolled since the last scroll
         * @return {Boolean} Return true if the event is consumed.
         * @event onGesture
         * @android
         * @since 4.0.0
         */
        onGesture: (params: {
            distanceX: number;
            distanceY: number;
        }) => boolean;
        /**
         * This event is called when the view is attached to a window. At this point it has a Surface and will start drawing.
         *
         * @event onAttachedToWindow
         * @android
         * @since 4.0.2
         */
        onAttachedToWindow: () => void;
        /**
         * This event is called when the view is detached to a window. At this point it no longer has a surface for drawing.
         *
         * @event onDetachedFromWindow
         * @android
         * @since 4.0.2
         */
        onDetachedFromWindow: () => void;
    }
    export interface IGridView<TEvent extends string = GridViewEvents, TMobile extends MobileOSProps<IGridViewIOS, IGridViewAndroid> = MobileOSProps<IGridViewIOS, IGridViewAndroid>> extends IView<TEvent | GridViewEvents, any, TMobile> {
        /**
         * This event is called when a GridView starts to create a GridViewItem.
         * You can customize your UI(not data-binding) inside this callback.
         *
         * @event onItemCreate
         * @android
         * @ios
         * @param {Number} itemType
         * @return {UI.GridViewItem}
         * @since 3.0.2
         */
        onItemCreate: (type?: number) => GridViewItem;
        /**
         * This event is called when a UI.GridViewItem created at specified row index.
         * You can bind your data to row items inside this callback.
         *
         * @param {UI.GridViewItem} gridViewItem
         * @param {Number} index
         * @event onItemBind
         * @android
         * @ios
         * @since 3.0.2
         */
        onItemBind: (item?: GridViewItem, index?: number) => void;
        /**
         * This event is called before onItemCreate callback. Returns item type you should use based on position.
         *
         * @event onItemType
         * @param {Number} index
         * @android
         * @ios
         * @return {Number}
         * @since 3.2.1
         */
        onItemType: (index?: number) => number;
        /**
         * This event is called when user selects a item at specific index.
         *
         * @param {UI.GridViewItem} gridViewItem
         * @param {Number} index
         * @event onItemSelected
         * @android
         * @ios
         * @since 3.0.2
         */
        onItemSelected: (gridViewItem: GridViewItem, index?: number) => void;
        /**
         * If the value of this property is YES , scrolling is enabled, and if it is NO , scrolling is disabled. The default is YES. This property must be set after assigning layout manager.
         *
         * @property {Boolean} [scrollEnabled = true]
         * @ios
         * @android
         * @since 3.2.0
         */
        scrollEnabled: boolean;
        /**
         * Gets contentOffset of the GridView.
         *
         * @property contentOffset
         * @android
         * @ios
         * @readonly
         * @return {Object}
         * @return {Number} return.x
         * @return {Number} return.y
         * @since 3.1.3
         */
        readonly contentOffset: Point2D;
        /**
         * Gets/sets the number of items that will be shown in a GridView.
         * You should update this property after each data operation.
         *
         * @property {Number} [itemCount = 0]
         * @android
         * @ios
         * @since 3.0.2
         */
        itemCount: number;
        /**
         * Class for GridView layout calculation.
         * The layoutManager used to organize the collected views items.
         *
         * @property {UI.LayoutManager} layoutManager
         * @android
         * @ios
         * @since 3.0.2
         */
        layoutManager: LayoutManager;
        /**
         * Gets/sets the visibility of scroll bar of GridView.
         * If set to true, vertical or horizontal scroll bar will be shown depending on gridview's
         * scroll direction. This property must be set after assigning layout manager.
         *
         * @property {Boolean} [scrollBarEnabled = false]
         * @android
         * @ios
         * @since 3.0.2
         */
        scrollBarEnabled: boolean;
        /**
         * Enables/disables the refresh function of GridView. If set to false
         * onPullRefresh events will not be called.
         *
         * @property {Boolean} [refreshEnabled = true]
         * @android
         * @ios
         * @since 3.0.2
         */
        refreshEnabled: boolean;
        /**
         * Returns the adapter position of the first visible view for first span.
         *
         * @return {Number}
         * @method getFirstVisibleIndex
         * @android
         * @ios
         * @since 3.0.2
         */
        getFirstVisibleIndex(): number;
        /**
         * Returns the adapter position of the last visible view for last span.
         *
         * @return {Number}
         * @method getLastVisibleIndex
         * @android
         * @ios
         * @since 3.0.2
         */
        getLastVisibleIndex(): number;
        /**
         * Sets the colors used in the refresh animation. On Android the first color
         * will also be the color of the bar that grows in response to a
         * user swipe gesture. iOS uses only the first color of the array.
         *
         * @method setPullRefreshColors
         * @param {UI.Color[]} colors
         * @android
         * @ios
         * @since 3.0.2
         */
        setPullRefreshColors(color: Color[]): void;
        /**
         * This method notify the GridView  that given range of items deleted. Must set the itemCount value to a changed number before calling this function.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.GridView#performBatchUpdates performBatchUpdates}.
         *
         * @method deleteRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be removed from the data set
         * @android
         * @ios
         * @since 4.3.6
         */
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        /**
         * This method notify the GridView  that given range of items inserted. Must set the itemCount value to a changed number before calling this function.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.GridView#performBatchUpdates performBatchUpdates}.
         *
         * @method insertRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be inserted from the data set
         * @android
         * @ios
         * @since 4.3.6
         */
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        /**
         * This method notify the GridView  that given range of items changed.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.GridView#performBatchUpdates performBatchUpdates}.
         *
         * @method refreshRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be changed from the data set
         * @android
         * @ios
         * @since 4.3.6
         */
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        /**
         * This method notify GridView for data changes. After this method is called
         * GridView refreshes itself and recreates the items. Do not forget to
         * update itemCount property after data changes.
         *
         * @method refreshData
         * @android
         * @ios
         * @since 3.0.2
         */
        refreshData(): void;
        /**
         * This method scrolls GridView to a specific index.
         *
         * @param {Number} index
         * @param {Boolean} [animated = true]
         * @method scrollTo
         * @android
         * @ios
         * @since 3.0.2
         */
        scrollTo(index: number, animated?: boolean): void;
        /**
         * This method cancels refresh operation and stops the refresh
         * indicator on a GridView. You should call this method after
         * finishing event inside onPullRefresh otherwise refresh indicator
         * never stops.
         *
         * @method stopRefresh
         * @android
         * @ios
         * @since 3.0.2
         */
        stopRefresh(): void;
        /**
         * This event is called when a GridView is scrolling. To remove this evet, set null.
         * For better performance, don't set any callback if does not
         * necessary
         *
         * @event onScroll
         * @param {Object} params
         * @param {Object} params.contentOffset
         * @param {Number} params.contentOffset.x
         * @param {Number} params.contentOffset.y
         * @param {Object} params.android  Android specific properties
         * @param {Object} params.android.translation
         * @param {Number} params.android.translation.y The amount of vertical scroll
         * @param {Number} params.android.translation.x The amount of horizontal scroll
         * @android
         * @ios
         * @since 3.1.3
         */
        onScroll: undefined | ((e: {
            contentOffset: Point2D;
            android?: {
                translation?: Point2D;
            };
        }) => void);
        /**
         * This event is called when user pulls down and releases a GridView
         * when scroll position is on the top.
         *
         * @event onPullRefresh
         * @android
         * @ios
         * @since 3.0.2
         */
        onPullRefresh: () => void;
        /**
         * This method returns GridViewItem
         *
         * @android
         * @ios
         * @since 3.0.2
         * @example
         */
        itemByIndex(index: number): GridViewItem | undefined;
    }
    export abstract class AbstractGridView<TEvent extends string = GridViewEvents, TProps extends IGridView = IGridView> extends AbstractView<TEvent | GridViewEvents, any, IGridView> implements IGridView {
        constructor(params?: Partial<TProps>);
        onItemCreate: (type?: number) => GridViewItem;
        onItemBind: (item?: GridViewItem, index?: number) => void;
        onItemType: (index?: number) => number;
        onItemSelected: (gridViewItem: GridViewItem, index?: number) => void;
        scrollEnabled: boolean;
        contentOffset: Point2D;
        itemCount: number;
        layoutManager: LayoutManager;
        scrollBarEnabled: boolean;
        refreshEnabled: boolean;
        abstract getFirstVisibleIndex(): number;
        abstract getLastVisibleIndex(): number;
        abstract setPullRefreshColors(color: Color[]): void;
        abstract deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        abstract insertRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        abstract refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        abstract refreshData(): void;
        abstract scrollTo(index: number, animated?: boolean): void;
        abstract stopRefresh(): void;
        onScroll: undefined | ((e: {
            contentOffset: Point2D;
            android?: {
                translation?: Point2D;
            };
        }) => void);
        onPullRefresh: () => void;
        abstract itemByIndex(index: number): GridViewItem | undefined;
        static Android: {
            SnapAlignment: GridViewSnapAlignment;
        };
    }
    class GridViewImpl extends AbstractGridView {
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(color: Color[]): void;
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshData(): void;
        scrollTo(index: number, animated?: boolean): void;
        stopRefresh(): void;
        itemByIndex(index: number): GridViewItem | undefined;
    }
    const GridView: typeof GridViewImpl;
    type GridView = GridViewImpl;
    export default GridView;
}
declare module "ui/layoutmanager/layoutmanager.android" {
    import { AbstractLayoutManager, ILayoutManager } from "ui/layoutmanager/index";
    export default class LayoutManagerAndroid extends AbstractLayoutManager implements ILayoutManager {
        private _lineDecoration;
        private _itemDecoration;
        private _spanCount;
        private _lineSpacing;
        private _itemSpacing;
        private _scrollDirection;
        private _contentInset;
        private _onItemLength;
        private _nativeRecyclerView;
        private _spanSize;
        private _onFullSpanCallback;
        constructor(params?: Partial<ILayoutManager>);
        get spanCount(): ILayoutManager['spanCount'];
        set spanCount(value: ILayoutManager['spanCount']);
        get lineSpacing(): ILayoutManager['lineSpacing'];
        set lineSpacing(value: ILayoutManager['lineSpacing']);
        get itemSpacing(): ILayoutManager['itemSpacing'];
        set itemSpacing(value: ILayoutManager['itemSpacing']);
        get contentInset(): ILayoutManager['contentInset'];
        set contentInset(value: ILayoutManager['contentInset']);
        get scrollDirection(): ILayoutManager['scrollDirection'];
        set scrollDirection(scrollDirection: ILayoutManager['scrollDirection']);
        get nativeRecyclerView(): INativeInner | null;
        set nativeRecyclerView(nativeRecyclerView: INativeInner | null);
        get onItemLength(): ILayoutManager['onItemLength'];
        set onItemLength(value: ILayoutManager['onItemLength']);
        get onFullSpan(): ILayoutManager['onFullSpan'];
        set onFullSpan(value: ILayoutManager['onFullSpan']);
        get spanSize(): number;
        set spanSize(value: number);
        set viewWidth(value: number);
        set viewHeight(value: number);
        private _createAndAddItemSpacingDecoration;
        private _createAndAddLineSpacingDecoration;
        private setContentInset;
        private setLayoutChangeListener;
        private setSpanSizeForHorizontal;
        private setSpanSizeForVertical;
    }
}
declare module "ui/gridview/gridview.android" {
    import { GridViewSnapAlignment, IGridView } from "ui/gridview/index";
    import Color from "ui/color/index";
    import GridViewItem from "ui/gridviewitem/index";
    import LayoutManager from "ui/layoutmanager/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { GridViewEvents } from "ui/gridview/gridview-events";
    export default class GridViewAndroid<TEvent extends string = GridViewEvents> extends ViewAndroid<TEvent | GridViewEvents, any, IGridView> implements IGridView {
        nativeInner: INativeInner;
        nativeDataAdapter: any;
        private _onScroll;
        private _onScrollStateChanged;
        private _layoutManager;
        private _gridViewItems;
        private _itemCount;
        private isScrollListenerAdded;
        private _scrollBarEnabled;
        private _scrollEnabled;
        private _nativePagerSnapHelper;
        private _paginationEnabled;
        private _onScrollListener;
        private _snapToAlignment;
        private _nativeLinearSnapHelper;
        constructor(params?: Partial<IGridView>);
        onItemCreate: (type?: number) => GridViewItem;
        onItemBind: (item?: GridViewItem, index?: number) => void;
        onItemType: (index?: number) => number;
        onItemSelected: (gridViewItem: GridViewItem, index?: number) => void;
        onPullRefresh: () => void;
        private setNativeInner;
        private setNativeEvents;
        private setDataAdapter;
        private getAndroidProps;
        private getIOSProps;
        private applyFullSpan;
        private assignSizeBasedOnDirection;
        private createOnScrollListernerObject;
        private removeSnapHelper;
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(colors: Color[]): void;
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshData(): void;
        scrollTo(index: number, animated?: boolean): void;
        startRefresh(): void;
        stopRefresh(): void;
        itemByIndex(index: number): GridViewItem | undefined;
        toString(): string;
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get itemCount(): number;
        set itemCount(value: number);
        get scrollBarEnabled(): boolean;
        set scrollBarEnabled(value: boolean);
        get refreshEnabled(): boolean;
        set refreshEnabled(value: boolean);
        get layoutManager(): LayoutManager;
        set layoutManager(value: LayoutManager);
        get paginationEnabled(): boolean;
        set paginationEnabled(value: boolean);
        static Android: {
            SnapAlignment: typeof GridViewSnapAlignment;
        };
        get contentOffset(): {
            x: number;
            y: number;
        };
        get onScroll(): ((e: {
            contentOffset: import("primitive/point2d").Point2D;
            android?: {
                translation?: import("primitive/point2d").Point2D | undefined;
            } | undefined;
        }) => void) | undefined;
        set onScroll(value: ((e: {
            contentOffset: import("primitive/point2d").Point2D;
            android?: {
                translation?: import("primitive/point2d").Point2D | undefined;
            } | undefined;
        }) => void) | undefined);
    }
}
declare module "ui/layoutmanager/layoutmanager.ios" {
    import { AbstractLayoutManager, ILayoutManager, ScrollDirection } from "ui/layoutmanager/index";
    import GridViewIOS from "ui/gridview/gridview.ios";
    export default class LayoutManagerIOS extends AbstractLayoutManager<__SF_UICollectionViewFlowLayout> implements ILayoutManager {
        onFullSpan: (type: number) => number;
        private _spanCount;
        private _lineSpacing;
        private _itemSpacing;
        private _scrollDirection;
        private _contentInset;
        private _onItemLength;
        collectionView: __SF_UICollectionView | null;
        jsCollectionView: GridViewIOS;
        private _sectionInset;
        private _itemLength;
        constructor(params?: Partial<ILayoutManager>);
        get spanCount(): ILayoutManager['spanCount'];
        set spanCount(value: ILayoutManager['spanCount']);
        get lineSpacing(): ILayoutManager['lineSpacing'];
        set lineSpacing(value: ILayoutManager['lineSpacing']);
        get itemSpacing(): ILayoutManager['itemSpacing'];
        set itemSpacing(value: ILayoutManager['itemSpacing']);
        get contentInset(): ILayoutManager['contentInset'];
        set contentInset(value: ILayoutManager['contentInset']);
        get scrollDirection(): ILayoutManager['scrollDirection'];
        set scrollDirection(value: ILayoutManager['scrollDirection']);
        get onItemLength(): ILayoutManager['onItemLength'];
        set onItemLength(value: ILayoutManager['onItemLength']);
        private get itemLength();
        private set itemLength(value);
        private get sectionInset();
        private set sectionInset(value);
        private calculateItemSize;
        private calculateSize;
        private roundDown;
        private sizeForItemAtIndexPath;
        static ScrollDirection: typeof ScrollDirection;
    }
}
declare module "ui/gridview/gridview.ios" {
    import { GridViewSnapAlignment, IGridView } from "ui/gridview/index";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import GridViewItem from "ui/gridviewitem/index";
    import LayoutManager from "ui/layoutmanager/index";
    import ViewIOS from "ui/view/view.ios";
    import { GridViewEvents } from "ui/gridview/gridview-events";
    export default class GridViewIOS<TEvent extends string = GridViewEvents> extends ViewIOS<TEvent | GridViewEvents, any, IGridView> implements IGridView {
        onItemCreate: (type?: number) => GridViewItem;
        onItemBind: (item?: GridViewItem, index?: number) => void;
        onItemType: (index?: number) => number;
        onItemSelected: (gridViewItem: GridViewItem, index?: number) => void;
        onScroll: (e: {
            contentOffset: Point2D;
            android?: {
                translation?: Point2D;
            };
        }) => void;
        onPullRefresh: () => void;
        private _sectionCount;
        private registeredIndentifier;
        private defaultflowLayout;
        private smfcollectionView;
        private _itemCount;
        private _itemLength;
        private collectionViewItems;
        private _scrollBarEnabled;
        private refreshControl;
        private _refreshEnabled;
        constructor(params?: Partial<IGridView>);
        private getAndroidProps;
        private getIOSProps;
        private setScrollEvents;
        private setNativeParams;
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(color: Color[] | Color): void;
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
        }): void;
        refreshData(): void;
        scrollTo(index: number, animated?: boolean): void;
        stopRefresh(): void;
        itemByIndex(index: number): GridViewItem;
        get itemCount(): number;
        set itemCount(value: number);
        get itemLength(): number;
        set itemLength(value: number);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get layoutManager(): LayoutManager;
        get scrollBarEnabled(): boolean;
        set scrollBarEnabled(value: boolean);
        get refreshEnabled(): boolean;
        set refreshEnabled(value: boolean);
        get paginationEnabled(): boolean;
        set paginationEnabled(value: boolean);
        get contentOffset(): __SF_NSRect;
        static Android: {
            SnapToAligment: typeof GridViewSnapAlignment;
        };
    }
}
declare module "ui/gridviewitem/gridviewitem.android" {
    import { IGridViewItem } from "ui/gridviewitem/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import FlexLayoutAndroid from "ui/flexlayout/flexlayout.android";
    export default class GridViewIOSAndroid<TEvent extends string = FlexLayoutEvents, TNative = any, TProps extends IGridViewItem = IGridViewItem> extends FlexLayoutAndroid<TEvent | FlexLayoutEvents, TNative, TProps> implements IGridViewItem {
        nativeInner: any;
        constructor(params?: Partial<TProps>);
        viewType: number;
        updateRippleEffectIfNeeded?: () => void;
        requestDisallowInterceptTouchEvent?(disallow: boolean): void;
        toString(): string;
        get height(): number;
        set height(value: number);
        get width(): number;
        set width(value: number);
    }
}
declare module "ui/gridviewitem/gridviewitem.ios" {
    import { IGridViewItem } from "ui/gridviewitem/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import FlexLayoutIOS from "ui/flexlayout/flexlayout.ios";
    export default class GridViewItemIOS<TEvent extends string = FlexLayoutEvents, TNative = {}> extends FlexLayoutIOS<TEvent | FlexLayoutEvents, TNative, IGridViewItem> implements IGridViewItem {
        nativeInner: any;
        viewType: number;
        private __nativeCell;
        constructor(params?: Partial<IGridViewItem>);
    }
}
declare module "ui/menuitem/menuitem-events" {
    export const MenuItemEvents: {
        readonly Selected: "selected";
    };
    export type MenuItemEvents = ExtractValues<typeof MenuItemEvents>;
}
declare module "ui/menuitem/index" {
    import Color from "ui/color/index";
    import { MenuItemEvents } from "ui/menuitem/menuitem-events";
    /**
     * @enum {Number} UI.MenuItem.ios.Style
     * @since 0.1
     *
     * MenuItem's style is used to specify behaviour and appearance of the item. This enumeration
     * describes available styles for iOS.
     */
    export enum Style {
        /**
         * @property {Number} DEFAULT
         * @ios
         * Apply the default style to the menu items's.
         * @static
         * @readonly
         * @ios
         * @since 1.1.8
         */
        DEFAULT = 0,
        /**
         * @property {Number} CANCEL
         * @ios
         * Apply a style that indicates the menu item cancels the operation and leaves things unchanged.
         * @static
         * @readonly
         * @ios
         * @since 1.1.8
         */
        CANCEL = 1,
        /**
         * @property {Number} DESTRUCTIVE
         * @ios
         * Apply a style that indicates the menu item might change or delete data.
         * @static
         * @readonly
         * @ios
         * @since 1.1.8
         */
        DESTRUCTIVE = 2
    }
    /**
     * @class UI.MenuItem
     * @since 0.1
     *
     * MenuItem is used to add row and action to the UI.Menu
     *
     */
    export interface IMenuItem {
        getActionView: any;
        /**
         * Gets/sets the title of a menu item.
         *
         * @property {String} title
         * @android
         * @ios
         * @since 0.1
         */
        title: string;
        android: Partial<{
            /**
             * Gets/sets the color of a menu item title.
             *
             * @property {UI.Color} titleColor
             * @android
             * @since 1.1.8
             */
            titleColor: Color | undefined;
        }>;
        ios: Partial<{
            /**
             * Gets/sets the style of a menu item.
             *
             * @property {UI.MenuItem.ios.Style} style
             * @ios
             * @since 1.1.8
             */
            style: Style;
        }>;
        /**
         * This event is called when user selects a menu item.
         *
         * @since 0.1
         * @event onSelected
         * @android
         * @deprecated
         * @ios
         * @example
         * ````
         * import MenuItem from '@smartface/native/ui/menuitem';
         *
         * const menuItem = new MenuItem();
         * menuItem.on(MenuItem.Events.Selected, () => {
         * 	console.info('onSelected');
         * });
         * ````
         */
        onSelected: () => void;
    }
    export class AbstractMenuItem implements IMenuItem {
        static Styles: Style;
        static Events: MenuItemEvents;
        constructor(params?: Partial<AbstractMenuItem>);
        getActionView: any;
        title: string;
        android: Partial<{
            /**
             * Gets/sets the color of a menu item title.
             *
             * @property {UI.Color} titleColor
             * @android
             * @since 1.1.8
             */
            titleColor: Color;
        }>;
        ios: Partial<{
            /**
             * Gets/sets the style of a menu item.
             *
             * @property {UI.MenuItem.ios.Style} style
             * @ios
             * @since 1.1.8
             */
            style: Style;
        }>;
        onSelected: () => void;
        /**
         * Used privately by the framework.
         * @ios
         */
        onSelectedListener?: () => void;
    }
    const MenuItem: typeof AbstractMenuItem;
    type MenuItem = AbstractMenuItem;
    export default MenuItem;
}
declare module "ui/searchview/searchview-events" {
    export const SearchViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        /**
         * This event is called when user clicks the cancel button.
         *
         * @ios
         * @event onCancelButtonClicked
         * @since 0.1
         */
        readonly CancelButtonClicked: "cancelButtonClicked";
        /**
         * This event is called when user focus on the search view by selecting it.
         *
         * @event onSearchBegin
         * @android
         * @ios
         * @since 0.1
         */
        readonly SearchBegin: "searchBegin";
        /**
         * This event is called when user clicks search button on the keyboard. In Android, clicking on search action button does not {@link Application#hideKeyboard hide the keyboard}.
         *
         * @event onSearchButtonClicked
         * @android
         * @ios
         * @since 0.1
         */
        readonly SearchButtonClicked: "searchButtonClicked";
        /**
         * This event is called when searchview loses focus.
         *
         * @event onSearchEnd
         * @android
         * @ios
         * @since 0.1
         */
        readonly SearchEnd: "searchEnd";
        /**
         * This event is called when user changes the search text.
         *
         * @param {String} searchText The current text in the search text view.
         * @android
         * @ios
         * @event onTextChanged
         * @since 0.1
         */
        readonly TextChanged: "textChanged";
    };
    export type SearchViewEvents = ExtractValues<typeof SearchViewEvents>;
}
declare module "ui/searchview/index" {
    import View, { AbstractView, IView } from "ui/view/index";
    import type Color from "ui/color/index";
    import type Image from "ui/image/index";
    import type Page from "ui/page/index";
    import type FlexLayout from "ui/flexlayout/index";
    import type Font from "ui/font/index";
    import KeyboardAppearance from "ui/shared/keyboardappearance";
    import TextAlignment from "ui/shared/textalignment";
    import { SearchViewEvents } from "ui/searchview/searchview-events";
    import { MobileOSProps } from "core/native-mobile-component";
    import type KeyboardType from "ui/shared/keyboardtype";
    /**
     * Bar style that specifies the search bars appearance.
     * @class UI.SearchView.iOS.Style
     */
    export enum SearchViewStyle {
        /**
         * Default is prominent.
         * @memberof UI.SearchView.iOS.Style
         * @property DEFAULT
         * @ios
         * @readonly
         * @since 0.1
         */
        DEFAULT = 0,
        /**
         * The search bar has a transparent background.
         * @property PROMINENT
         * @ios
         * @readonly
         * @since 0.1
         */
        PROMINENT = 1,
        /**
         * The search bar has no background.
         * @property MINIMAL
         * @ios
         * @readonly
         * @since 0.1
         */
        MINIMAL = 2
    }
    export type SearchViewIOSProps = View['ios'] & {
        /**
         * This function show loading indicator.
         *
         * @method showLoading
         * @ios
         * @since 3.0.2
         */
        showLoading?(): void;
        /**
         * This function hide loading indicator.
         *
         * @method hideLoading
         * @ios
         * @since 3.0.2
         */
        hideLoading?(): void;
        /**
         * Gets/sets the search views style. This property works only for IOS.
         *
         * @property {UI.SearchView.iOS.Style} searchViewStyle
         * @ios
         * @since 0.1
         */
        searchViewStyle?: SearchViewStyle;
        /**
         * Gets/sets visibility of cancel button. This property works only for IOS.
         *
         * @property {boolean} showsCancelButton
         * @ios
         * @since 0.1
         */
        showsCancelButton?: boolean;
        /**
         * Gets/sets cursor color of searchview.
         *
         * @property {UI.Color} cursorColor
         * @ios
         * @android
         * @since 3.2.1
         */
        cursorColor?: Color;
        /**
         * Gets/sets cancel button color of searchview. This property works only for IOS.
         *
         * @property {UI.Color} cancelButtonColor
         * @ios
         * @since 1.1.12
         */
        cancelButtonColor?: Color;
        /**
         * Gets/sets cancel button text of searchview. This property works only for IOS.
         *
         * @property {String} cancelButtonText
         * @ios
         * @since 3.2.1
         */
        cancelButtonText?: string;
        /**
         * This event is called when user clicks the cancel button.
         *
         * @ios
         * @deprecated
         * @event onCancelButtonClicked
         * @since 0.1
         * @example
         * ````
         * import SearchView from '@smartface/native/ui/searchview';
         *
         * const searchView = new SearchView();
         * searchView.on(SearchView.Events.CancelButtonClicked, () => {
         * 	console.info('onCancelButtonClicked');
         * });
         * ````
         */
        onCancelButtonClicked?: () => void;
        /**
         * Gets/sets the color of the loading indicator.
         *
         * @property {UI.Color} loadingColor
         * @ios
         * @since 3.0.2
         */
        loadingColor?: Color;
        keyboardAppearance?: KeyboardAppearance;
    };
    export type SearchViewAndroidProps = View['android'] & {
        closeImage: Image;
        keyboardType: KeyboardType;
        /**
         * Gets/sets search button icon of searchview. While using this property, {@link UI.SearchView#iconifiedByDefault iconifiedByDefault }
         * property should be true.
         *
         * @property {UI.Image} searchButtonIcon
         * @android
         * @since 3.2.1
         */
        searchButtonIcon: Image;
        /**
         * This property makes the search view either iconified or expanded.
         *
         * @property {Boolean} [iconifiedByDefault = false ]
         * @android
         * @since 3.2.1
         */
        iconifiedByDefault: boolean;
        /**
         * Gets/sets clear icon of searchview.
         *
         * @property {UI.Image} clearIcon
         * @android
         * @since 3.2.1
         * @deprecated 3.2.2 Use {@link UI.SearchView#closeIcon} instead.
         */
        clearIcon: Image;
        /**
         * Gets/sets clear/close icon of searchview.
         *
         * @property {UI.Image} closeIcon
         * @android
         * @since 3.2.2
         */
        closeIcon: Image;
        /**
         * This property allows you to override search icon of searchview by given icon or custom layout.
         *
         * @property {UI.Image | UI.FlexLayout} leftItem
         * @android
         * @since 3.2.2
         */
        leftItem: Image | FlexLayout;
        /**
         * Sets/gets corner radius of text field of search view. textFieldBorderRadius maximum value must be half of the shortest edge.
         *
         * @property {Number} [textFieldBorderRadius = 15]
         * @android
         * @since 3.0.2
         */
        textFieldBorderRadius: number;
    };
    export interface ISearchView<TEvent extends string = SearchViewEvents> extends IView<TEvent | SearchViewEvents, any, MobileOSProps<SearchViewIOSProps, SearchViewAndroidProps>> {
        /**
         * Gets/sets text of SearchView.
         *
         * @property {String} text
         * @android
         * @ios
         * @since 0.1
         */
        text: string;
        /**
         * Gets/sets hint text of SearchView.
         *
         * @property {String} hint
         * @android
         * @ios
         * @since 0.1
         */
        hint: string;
        /**
         * Gets/sets text color of SearchView.
         *
         * @property {UI.Color} textColor
         * @android
         * @ios
         * @since 0.1
         */
        textColor: Color;
        /**
         * Gets/sets background image of SearchView.
         *
         * @property {UI.Image} backgroundImage
         * @android
         * @ios
         * @since 0.1
         */
        backgroundImage: Image;
        /**
         * Gets/sets search icon image of SearchView.
         *
         * @property {UI.Image} iconImage
         * @android
         * @ios
         * @since 0.1
         * @deprecated 3.2.2 Use {@link UI.SearchView#searchIcon} instead.
         */
        iconImage: Image;
        /**
         * Gets/sets search icon image of SearchView.
         *
         * @property {UI.Image} searchIcon
         * @android
         * @ios
         * @since 3.2.2
         */
        searchIcon: Image;
        /**
         * Adds SearchView to UI.Page's headerBar view. When SearchView is added to header bar,
         * {@link UI.SearchView#borderWidth borderWidth} of SearchView will be 0 on ios. In Android,
         * searchview always will be iconified. So to make apperance always expanded, combine searchview with {@link UI.HeaderBar#titleLayout titleLayout}
         *
         * @method addToHeaderBar
         * @param {UI.Page} page.
         * @android
         * @ios
         * @since 0.1
         */
        addToHeaderBar(page: Page): void;
        /**
         * Sets/gets border thickness of bounded view. Accepts unsigned
         * numbers, 0 means no border. When the searchview is added to header bar,
         * the border width of the search view will be 0 on ios.
         *
         * @property {Number} [borderWidth = 1]
         * @android
         * @ios
         * @since 0.1
         */
        borderWidth: number;
        /**
         * Removes SearchView from UI.Page's headerBar view.
         *
         * @method removeFromHeaderBar
         * @param {UI.Page} page.
         * @android
         * @ios
         * @since 0.1
         */
        removeFromHeaderBar(page: Page): void;
        /**
         * This function shows keyboard.
         *
         * @method showKeyboard
         * @android
         * @ios
         * @since 0.1
         * @deprecated 1.1.8 Use {@link UI.SearchView#requestFocus} instead.
         */
        showKeyboard(): void;
        /**
         * This function hides keyboard.
         *
         * @method hideKeyboard
         * @android
         * @ios
         * @since 0.1
         * @deprecated 1.1.8 Use {@link UI.SearchView#removeFocus} instead.
         */
        hideKeyboard(): void;
        /**
         * This function gives focus to the SearchView. When the SearchView gained focus, keyboard will appear.
         *
         * @method requestFocus
         * @android
         * @ios
         * @since 1.1.8
         */
        requestFocus(): void;
        /**
         * This function removes focus from the SearchView. When the SearchView lost its focus, keyboard will disappear.
         *
         * @method removeFocus
         * @android
         * @ios
         * @since 1.1.8
         */
        removeFocus(): void;
        /**
         * Gets/sets the font of the SearchView.
         *
         * @property {UI.Font} [font = null]
         * @android
         * @ios
         * @since 0.1
         */
        font: null | Font;
        /**
         * Gets/sets text alignment of the SearchView.
         *
         * @property {UI.TextAlignment} [textAlignment = UI.TextAlignment.MIDLEFT]
         * @android
         * @ios
         * @since 0.1
         */
        textAlignment: TextAlignment;
        /**
         * Gets/sets the color of the hint text.
         *
         * @property {UI.Color} [hintTextColor = UI.Color.LIGHTGRAY]
         * @ios
         * @android
         * @since 0.1
         */
        hintTextColor: Color;
        /**
         * Gets/sets the color of the textFieldBackgroundColor.
         *
         * @property {UI.Color} textFieldBackgroundColor
         * @ios
         * @android
         * @since 3.0.2
         */
        textFieldBackgroundColor: Color;
        /**
         * This event is called when user focus on the search view by selecting it.
         *
         * @event onSearchBegin
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SearchView from '@smartface/native/ui/searchview';
         *
         * const searchView = new SearchView();
         * searchView.on(SearchView.Events.SearchBegin, () => {
         * 	console.info('onSearchBegin');
         * });
         * ````
         */
        onSearchBegin: () => void;
        /**
         * This event is called when searchview loses focus.
         *
         * @event onSearchEnd
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SearchView from '@smartface/native/ui/searchview';
         *
         * const searchView = new SearchView();
         * searchView.on(SearchView.Events.SearchEnd, () => {
         * 	console.info('onSearchEnd');
         * });
         * ````
         */
        onSearchEnd: () => void;
        /**
         * This event is called when user changes the search text.
         *
         * @param {String} searchText The current text in the search text view.
         * @android
         * @ios
         * @deprecated
         * @event onTextChanged
         * @since 0.1
         * @example
         * ````
         * import SearchView from '@smartface/native/ui/searchview';
         *
         * const searchView = new SearchView();
         * searchView.on(SearchView.Events.TextChanged, (params) => {
         * 	console.info('onTextChanged', params);
         * });
         * ````
         */
        onTextChanged: (searchText: string) => void;
        /**
         * This event is called when user clicks search button on the keyboard. In Android, clicking on search action button does not {@link Application#hideKeyboard hide the keyboard}.
         *
         * @event onSearchButtonClicked
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import SearchView from '@smartface/native/ui/searchview';
         *
         * const searchView = new SearchView();
         * searchView.on(SearchView.Events.SearchButtonClicked, (params) => {
         * 	console.info('onSearchButtonClicked');
         * });
         * ````
         */
        onSearchButtonClicked: () => void;
    }
    export class AbstractSearchView<TEvent extends string = SearchViewEvents> extends AbstractView<TEvent, any, ISearchView> implements ISearchView<TEvent> {
        static iOS: {
            Style: typeof SearchViewStyle;
        };
        text: string;
        hint: string;
        textColor: Color;
        backgroundImage: Image;
        iconImage: Image;
        searchIcon: Image;
        addToHeaderBar(page: Page): void;
        removeFromHeaderBar(page: Page): void;
        showKeyboard(): void;
        hideKeyboard(): void;
        requestFocus(): void;
        removeFocus(): void;
        font: Font;
        textAlignment: TextAlignment;
        hintTextColor: Color;
        textFieldBackgroundColor: Color;
        onSearchBegin: () => void;
        onSearchEnd: () => void;
        onTextChanged: (searchText: string) => void;
        onSearchButtonClicked: () => void;
    }
    /**
     * @class UI.SearchView
     * @extends UI.View
     * @since 0.1
     *
     * SearchView is a UI which user can enter a search query and submit a request to search provider.
     *
     *     @example
     *     import SearchView from '@smartface/native/ui/searchview';
     *     const searchBar = new SearchView();
     *     searchBar.on(SearchView.Events.TextChanged, (searchText) => {
     *         console.log("searched text : " + searchText);
     *     };
     *
     */
    const SearchView: typeof AbstractSearchView;
    type SearchView = AbstractSearchView;
    export default SearchView;
}
declare module "ui/headerbaritem/headerbaritem.android" {
    import HeaderBarItem, { IHeaderBarItem } from "ui/headerbaritem/index";
    import { NativeMobileComponent } from "core/native-mobile-component";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import View from "ui/view/index";
    export default class HeaderBarItemAndroid extends NativeMobileComponent<any, IHeaderBarItem> implements IHeaderBarItem {
        iOS: {
            SystemItem: {};
        };
        private _title;
        private _image;
        private _customView?;
        private _enabled;
        private _onPress;
        private _color;
        private _badge?;
        private _accessibilityLabel;
        private isLeftItem;
        private isBadgeEnabled;
        private actionBar;
        private _imageButton;
        private _searchView;
        private _menuItem;
        private nativeBadgeContainer;
        private _itemColor;
        constructor(params?: Partial<HeaderBarItem>);
        get color(): Color | null;
        set color(value: Color | null);
        get title(): string;
        set title(value: string);
        get imageButton(): boolean;
        set imageButton(value: boolean);
        get menuItem(): import("ui/menuitem").AbstractMenuItem | null;
        set menuItem(value: import("ui/menuitem").AbstractMenuItem | null);
        get image(): Image | string | null;
        set image(value: Image | string | null);
        get searchView(): any;
        set searchView(searchView: any);
        get enabled(): boolean;
        set enabled(value: boolean);
        get onPress(): IHeaderBarItem['onPress'];
        set onPress(value: IHeaderBarItem['onPress']);
        get size(): {
            width: number;
            height: number;
        } | undefined;
        set size(value: {
            width: number;
            height: number;
        } | undefined);
        get badge(): import("ui/badge").IBadge;
        get customView(): View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<import("ui/view").IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>> | undefined;
        set customView(view: View<"touch" | "touchCancelled" | "touchEnded" | "touchMoved", {
            [key: string]: any;
        }, import("core/native-mobile-component").WithMobileOSProps<import("ui/view").IViewProps<import("core/native-mobile-component").MobileOSProps<import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>>, import("ui/view").ViewIOSProps, import("ui/view").ViewAndroidProps>> | undefined);
        get accessibilityLabel(): string;
        set accessibilityLabel(value: string);
        get itemColor(): Color;
        set itemColor(color: Color);
        setValues(): void;
        toString(): string;
        titleSetterHelper(title: string): void;
        updateAccessibilityLabel(accessibilityLabel: string): void;
        assignRules(badge: any): void;
        addToHeaderView(badge: any): void;
        getScreenLocation(): Point2D;
        createNativeImageButton(): any;
    }
}
declare module "ui/headerbaritem/headerbaritem.ios" {
    import HeaderBarItem, { IHeaderBarItem } from "ui/headerbaritem/index";
    import { NativeMobileComponent } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    export default class HeaderBarItemIOS extends NativeMobileComponent<any, IHeaderBarItem> implements IHeaderBarItem {
        iOS: {
            SystemItem: {
                DONE: number;
                CANCEL: number;
                EDIT: number;
                SAVE: number;
                ADD: number;
                FLEXIBLESPACE: number;
                FIXEDSPACE: number;
                COMPOSE: number;
                REPLY: number;
                ACTION: number;
                ORGANIZE: number;
                BOOKMARKS: number;
                SEARCH: number;
                REFRESH: number;
                STOP: number;
                CAMERA: number;
                TRASH: number;
                PLAY: number;
                PAUSE: number;
                REWIND: number;
                FASTFORWARD: number;
                UNDO: number;
                REDO: number;
            };
        };
        private _systemItem;
        private _badge;
        private _nativeView;
        private _font;
        private _customView;
        private _onPress;
        constructor(params?: Partial<HeaderBarItem>);
        get layout(): any;
        get title(): string;
        set title(value: string);
        get customView(): any;
        set customView(value: any);
        get image(): string | Image;
        set image(value: string | Image);
        get color(): Color;
        set color(value: Color);
        get enabled(): boolean;
        set enabled(value: boolean);
        get onPress(): (() => void) | null;
        set onPress(value: (() => void) | null);
        get badge(): import("ui/badge").IBadge;
        get size(): {
            width: any;
            height: any;
        } | undefined;
        get accessibilityLabel(): string;
        set accessibilityLabel(value: string);
        getScreenLocation(): any;
    }
}
declare module "ui/swipeitem/swipeitem-events" {
    export const SwipeItemEvents: {
        readonly Press: "press";
    };
    export type SwipeItemEvents = ExtractValues<typeof SwipeItemEvents>;
}
declare module "ui/swipeitem/index" {
    import { ConstructorOf } from "core/constructorof";
    import { IEventEmitter } from "core/eventemitter/index";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import Image from "ui/image/index";
    import { SwipeItemEvents } from "ui/swipeitem/swipeitem-events";
    /**
     * Swipe Direction enums used to define allowed direction of swipe.
     * @readonly
     * @ios
     * @android
     * @since 4.1.4
     */
    export enum SwipeDirection {
        /**
         * Left direction, used for swipe control.
         *
         * @property {Number} LEFTTORIGHT
         * @ios
         * @android
         * @static
         * @readonly
         * @since 4.1.4
         */
        LEFTTORIGHT = 0,
        /**
         * Right direction, used for swipe control.
         * @property {Number} RIGHTTOLEFT
         * @ios
         * @android
         * @static
         * @readonly
         * @since 4.1.4
         */
        RIGHTTOLEFT = 1
    }
    export interface ISwipeItemAndroidParams {
        borderBottomLeftRadius: number;
        borderBottomRightRadius: number;
        borderTopLeftRadius: number;
        borderTopRightRadius: number;
        paddingTop: number;
        paddingBottom: number;
        paddingLeft: number;
        paddingRight: number;
        threshold: number;
    }
    export interface ISwipeItemIOSParams {
        padding: number;
        iconTextSpacing: number;
        isAutoHide: boolean;
    }
    export interface ISwipeItem extends IEventEmitter<SwipeItemEvents>, MobileOSProps<ISwipeItemIOSParams, ISwipeItemAndroidParams> {
        text: string;
        backgroundColor: Color;
        textColor: Color;
        icon?: Image;
        font: Font | null;
        onPress: (params: {
            index: number;
        }) => void;
    }
    const SwipeItem: ConstructorOf<ISwipeItem, Partial<ISwipeItem>>;
    type SwipeItem = ISwipeItem;
    export default SwipeItem;
}
declare module "ui/listviewitem/index" {
    import { ConstructorOf } from "core/constructorof";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import { FlexLayoutIOSProps, IFlexLayout } from "ui/flexlayout/index";
    import { SwipeDirection } from "ui/swipeitem/index";
    import { MobileOSProps } from "core/native-mobile-component";
    export interface ListViewItemIOSProperties extends FlexLayoutIOSProps {
        expandSwipe?(direction?: SwipeDirection): void;
    }
    /**
     * @since 0.1
     *
     * ListViewItem class can used for a row layout of the ListView.
     * For a better performance, you should give id for all child views of ListViewItem.
     *
     * For example usage you can look {@link UI.ListView}.
     *
     */
    export interface IListViewItem<TEvent extends string = FlexLayoutEvents, TMobile extends MobileOSProps<ListViewItemIOSProperties, IFlexLayout['android']> = MobileOSProps<ListViewItemIOSProperties, IFlexLayout['android']>> extends IFlexLayout<TEvent | FlexLayoutEvents, TMobile> {
        /**
         * Inner nativeObject. This property is only available for Android.
         * @android
         */
        nativeInner: any;
    }
    const ListViewItem: ConstructorOf<IListViewItem, Partial<IListViewItem>>;
    type ListViewItem = IListViewItem;
    export default ListViewItem;
}
declare module "ui/listview/listview-events" {
    export const ListViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly AttachedToWindow: "attachedToWindow";
        readonly DetachedFromWindow: "detachedFromWindow";
        readonly Gesture: "gesture";
        readonly PullRefresh: "pullRefresh";
        readonly RowCanMove: "rowCanMove";
        readonly RowCanSwipe: "rowCanSwipe";
        readonly RowLongSelected: "rowLongSelected";
        readonly RowMove: "rowMove";
        readonly RowMoved: "rowMoved";
        readonly RowSelected: "rowSelected";
        readonly RowSwipe: "rowSwipe";
        readonly Scroll: "scroll";
        readonly ScrollBeginDecelerating: "scrollBeginDecelerating";
        readonly ScrollBeginDragging: "scrollBeginDragging";
        readonly ScrollEndDecelerating: "scrollEndDecelerating";
        readonly ScrollEndDraggingWillDecelerate: "scrollEndDraggingWillDecelerate";
        readonly ScrollEndDraggingWithVelocityTargetContentOffset: "scrollEndDraggingWithVelocityTargetContentOffset";
        readonly ScrollStateChanged: "scrollStateChanged";
    };
    export type ListViewEvents = ExtractValues<typeof ListViewEvents>;
}
declare module "ui/listview/index" {
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import ListViewItem from "ui/listviewitem/index";
    import Color from "ui/color/index";
    import ScrollState from "ui/shared/android/scrollstate";
    import { AbstractView, IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import { Point2D } from "primitive/point2d";
    import { ListViewEvents } from "ui/listview/listview-events";
    import SwipeItem, { ISwipeItem, SwipeDirection } from "ui/swipeitem/index";
    import { MobileOSProps } from "core/native-mobile-component";
    /**
     * The type of animation to use when rows are inserted or deleted or reloaded.
     * @enum UI.ListView.iOS.RowAnimation
     * @readonly
     * @ios
     * @since 4.1.4
     */
    export enum RowAnimation {
        /**
         * @property {Number} FADE
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        FADE = 0,
        /**
         * @property {Number} RIGHT
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        RIGHT = 1,
        /**
         * @property {Number} LEFT
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        LEFT = 2,
        /**
         * @property {Number} TOP
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        TOP = 3,
        /**
         * @property {Number} BOTTOM
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        BOTTOM = 4,
        /**
         * @property {Number} NONE
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        NONE = 5,
        /**
         * @property {Number} MIDDLE
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        MIDDLE = 6,
        /**
         * @property {Number} AUTOMATIC
         * @ios
         * @static
         * @readonly
         * @since 4.1.4
         */
        AUTOMATIC = 7
    }
    export interface IListViewIOS extends ViewIOSProps {
        /**
         * Animates multiple insert, delete and refresh operations as a group.
         * Use this method in cases where you want to make multiple changes to the table view in one single animated operation, as opposed to several separate animations.
         * Use the block passed in the updates parameter to specify all of the operations you want to perform.
         * Deletes are processed before inserts in batch operations.
         * This means the indexes for the deletions are processed relative to the indexes of the table views state before the batch operation, and the indexes for the insertions are processed relative to the indexes of the state after all the deletions in the batch operation.
         *
         * @param {Function} updates
         * @param {Function} completion A completion handler block to execute when all of the operations are finished.
         * @param {Object} completion.e
         * @param {Boolean} completion.e.finished
         * @method performBatchUpdates
         * @ios
         * @since 4.1.4
         */
        performBatchUpdates(updates: () => void, completion: {
            e: {
                finished: boolean;
            };
        }): void;
        /**
         * Gets/sets leftToRightSwipeEnabled
         *
         * @property {Boolean} [leftToRightSwipeEnabled = false]
         * @ios
         * @since 0.1
         */
        leftToRightSwipeEnabled: boolean;
        /**
         * Gets/sets rightToLeftSwipeEnabled
         *
         * @property {Boolean} [rightToLeftSwipeEnabled = false]
         * @ios
         * @since 0.1
         */
        rightToLeftSwipeEnabled: boolean;
        /**
         * This event is called when the list view is about to start scrolling the content.
         *
         * @deprecated
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDragging
         * @ios
         * @since 3.2.1
         */
        onScrollBeginDragging: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when the list view is starting to decelerate the scrolling movement.
         *
         * @deprecated
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollBeginDecelerating
         * @ios
         * @since 3.2.1
         */
        onScrollBeginDecelerating: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when the list view has ended decelerating the scrolling movement.
         *
         * @deprecated
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @event onScrollEndDecelerating
         * @ios
         * @since 3.2.1
         */
        onScrollEndDecelerating: (contentOffset: __SF_NSRect) => void;
        /**
         * This event is called when dragging ended in the list view.
         *
         * @deprecated
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @param {Boolean} decelerate
         * @event onScrollEndDraggingWillDecelerate
         * @ios
         * @since 3.2.1
         */
        onScrollEndDraggingWillDecelerate: (contentOffset: __SF_NSRect, decelerate: boolean) => void;
        /**
         * This event is called when the user finishes scrolling the content.
         *
         * @deprecated
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @param {Object} velocity
         * @param {Number} velocity.x
         * @param {Number} velocity.y
         * @param {Object} targetContentOffset
         * @param {Number} targetContentOffset.x
         * @param {Number} targetContentOffset.y
         * @event onScrollEndDraggingWithVelocityTargetContentOffset
         * @ios
         * @since 3.2.1
         */
        onScrollEndDraggingWithVelocityTargetContentOffset: (contentOffset: __SF_NSRect, velocity: Point2D, targetContentOffset: __SF_NSRect) => void;
    }
    export interface IListViewAndroid extends ViewAndroidProps {
        /**
         * Starts dragging the provided ListViewItem. By default, ListView starts a drag when a ListViewItem is long pressed.
         * You can disable that behavior by setting longPressDragEnabled.
         *
         * @method startDrag
         * @param {UI.ListViewItem} listViewItem
         * @android
         * @since 4.1.3
         */
        startDrag(item: ListViewItem): void;
        /**
         * This event is called when a scroll occurs.
         *
         * @deprecated
         * @param {Object} params
         * @param {Number} distanceX The distance along the X axis that has been scrolled since the last scroll
         * @param {Number} distanceY The distance along the Y axis that has been scrolled since the last scroll
         * @return {Boolean} Return true if the event is consumed.
         * @event onGesture
         * @android
         * @since 4.0.0
         */
        onGesture: (params: {
            distanceX: number;
            distanceY: number;
        }) => boolean;
        /**
         * Called when the ListView should save its layout state. This is a good time to save your scroll position,
         * configuration and anything else that may be required to restore the same layout state if the ListView is recreated.
         *
         * @method saveInstanceState
         * @android
         * @return {Object}
         * @since 4.0.2
         */
        saveInstanceState(): any;
        /**
         * Called when the ListView should restore its layout state. This is a good time to restore your scroll position,
         * configuration and anything else that may be required to restore the same layout state if the ListView is recreated.
         *
         * @param {Object} state
         * @method restoreInstanceState
         * @android
         * @since 4.0.2
         */
        restoreInstanceState(state: any): void;
        /**
         * This event is called when a ListView's scroll state is changed. To remove this evet, set null.
         * For better performance, don't set any callback if does not
         * necessary
         *
         * @deprecated
         * @event onScrollStateChanged
         * @param {UI.Android.ScrollState} newState
         * @param {Object} contentOffset
         * @param {Number} contentOffset.x
         * @param {Number} contentOffset.y
         * @android
         * @since 3.2.1
         */
        onScrollStateChanged: (newState?: ScrollState, contentOffset?: Point2D) => void;
        /**
         * This event is called when the view is attached to a window. At this point it has a Surface and will start drawing.
         *
         * @event onAttachedToWindow
         * @deprecated
         * @android
         * @since 4.0.2
         */
        onAttachedToWindow: () => void;
        /**
         * This event is called when the view is detached to a window. At this point it no longer has a surface for drawing.
         *
         * @event onDetachedFromWindow
         * @deprecated
         * @android
         * @since 4.0.2
         */
        onDetachedFromWindow: () => void;
        /**
         * This event is called when user long selects a row at specific index.
         *
         * @deprecated
         * @param {UI.ListViewItem} listViewItem
         * @param {Number} index
         * @event onRowLongSelected
         * @android
         * @since 2.0.4
         */
        onRowLongSelected: (item: ListViewItem, index: number) => void;
        /**
         * Gets/sets over-scroll mode for this view.
         *
         * @property {UI.Android.OverScrollMode} [overScrollMode = UI.Android.OverScrollMode.ALWAYS]
         * @android
         * @since 3.0.2
         */
        overScrollMode: OverScrollMode;
    }
    /**
     * @class UI.ListView
     * @since 0.1
     * @extends UI.View
     * ListView is a View that displays given items as a one-column vertical list.
     *
     *     @example
     *     const Color = require('@smartface/native/ui/color');
     *     const ListView = require('@smartface/native/ui/listview');
     *     const ListViewItem = require('@smartface/native/ui/listviewitem');
     *     const Label = require('@smartface/native/ui/label');
     *     const FlexLayout = require('@smartface/native/ui/flexlayout');
     *     const TextAlignment     = require("@smartface/native/ui/textalignment");
     *
     *     var myDataSet = [
     *         {
     *             title: 'Title 0',
     *             backgroundColor: Color.RED
     *         },
     *         {
     *             title: 'Title 1',
     *             backgroundColor: Color.CYAN
     *         },
     *         {
     *             title: 'Title 2',
     *             backgroundColor: Color.YELLOW
     *         },
     *         {
     *             title: 'Title 3',
     *             backgroundColor: Color.GRAY
     *         }
     *     ];
     *     var myListView = new ListView({
     *         flexGrow:1,
     *         rowHeight: 60,
     *         backgroundColor: Color.LIGHTGRAY,
     *         itemCount: myDataSet.length,
     *     });
     *     myListView.onRowCreate = function(){
     *         var myListViewItem = new ListViewItem();
     *         var myLabelTitle = new Label({
     *             height: 40,
     *             width: 100,
     *             alignSelf: FlexLayout.AlignSelf.CENTER,
     *             textAlignment : TextAlignment.MIDCENTER
     *         });
     *         myListViewItem.addChild(myLabelTitle);
     *         myListViewItem.myLabelTitle = myLabelTitle;
     *
     *         return myListViewItem;
     *     };
     *     myListView.onRowBind = function(listViewItem,index){
     *         listViewItem.myLabelTitle.text = myDataSet[index].title;
     *         listViewItem.myLabelTitle.backgroundColor = myDataSet[index].backgroundColor;
     *     };
     *     myListView.onRowSelected = function(listViewItem,index){
     *         console.log("selected index = " + index)
     *     };
     *     myListView.onPullRefresh = function(){
     *         myDataSet.push({
     *             title: 'Title '+ myDataSet.length,
     *             backgroundColor: Color.RED,
     *         })
     *         myListView.itemCount = myDataSet.length;
     *         myListView.refreshData();
     *         myListView.stopRefresh();
     *     };
     *
     *
     */
    export interface IListView<TEvent extends string = ListViewEvents, TMobile extends MobileOSProps<IListViewIOS, IListViewAndroid> = MobileOSProps<IListViewIOS, IListViewAndroid>> extends IView<TEvent | ListViewEvents, any, TMobile> {
        width: number;
        height: number;
        nativeInner: INativeInner;
        /**
         * This event is called before onRowCreate callback. Returns item type you should use based on position.
         *
         * @event onRowType
         * @param {Number} index
         * @android
         * @ios
         * @return {Number}
         * @since 3.0.2
         */
        onRowType: (index?: number) => number;
        /**
         * This event is called when a ListView starts to create a ListViewItem.
         * You can customize your UI(not data-binding) inside this callback.
         *
         * @event onRowCreate
         * @param {Number} rowType
         * @android
         * @ios
         * @return {UI.ListViewItem}
         * @since 0.1
         */
        onRowCreate: (type?: number) => ListViewItem;
        /**
         * This event is called when a ListView starts to create a ListViewItem.
         * You can set different height to rows. If row Height property is assigned, this callback doesn't fire
         *
         * @param {Number} index
         * @event onRowHeight
         * @android
         * @ios
         * @return {Number}
         * @since 1.1.18
         */
        onRowHeight: (index?: number) => number;
        /**
         * This event is called when a UI.ListViewItem created at specified row index.
         * You can bind your data to row items inside this callback.
         *
         * @param {UI.ListViewItem} listViewItem
         * @param {Number} index
         * @event onRowBind
         * @android
         * @ios
         * @since 0.1
         */
        onRowBind: (item: ListViewItem, index: number) => void;
        /**
         * This event is called when user selects a row at specific index.
         *
         * @deprecated
         * @param {UI.ListViewItem} listViewItem
         * @param {Number} index
         * @event onRowSelected
         * @android
         * @ios
         * @since 0.1
         */
        onRowSelected: (item: ListViewItem, index: number) => void;
        /**
         * Gets/sets the number of rows that will be shown in a ListView.
         * You should update this property after each data operation.
         *
         * @property {Number} [itemCount = 0]
         * @android
         * @ios
         * @since 0.1
         */
        itemCount: number;
        /**
         * Gets/sets height of a row in a ListView. Once you created the ListView,
         * you can't change row height.
         *
         *
         * @property {Number} rowHeight
         * @android
         * @ios
         * @since 0.1
         */
        rowHeight: number;
        /**
         * Gets/sets the visibility of vertical scroll bar of ListView.
         * If set to true, scroll bar will be shown otherwise
         * scroll bar will be hidden.
         *
         * @property {Boolean} [verticalScrollBarEnabled = false]
         * @android
         * @ios
         * @since 0.1
         */
        verticalScrollBarEnabled: boolean;
        /**
         * If the value of this property is YES , scrolling is enabled, and if it is NO , scrolling is disabled. The default is YES.
         *
         * @property {Boolean} [scrollEnabled = true]
         * @ios
         * @android
         * @since 3.2.0
         */
        scrollEnabled: boolean;
        /**
         * Enables/disables the refresh function of ListView. If set to false
         * onPullRefresh events will not be called.
         *
         * @property {Boolean} [refreshEnabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        refreshEnabled: boolean;
        /**
         * Enables/disables drag & drop behavior. When rowMoveEnabled property is true, onRowSelected callback is not triggered for iOS.
         *
         * @property {Boolean} [rowMoveEnabled = false]
         * @android
         * @ios
         * @since 4.1.4
         */
        rowMoveEnabled: boolean;
        /**
         * When {@link UI.ListView#rowMoveEnabled rowMoveEnabled} is true, default value is true but you may want to disable this
         * if you want to start dragging on a custom view touch using {@link UI.ListView#startDrag startDrag}.
         *
         * @property {Boolean} [longPressDragEnabled = false]
         * @android
         * @since 4.1.4
         */
        longPressDragEnabled: boolean;
        /**
         * This method returns the index of row which is visible at
         * the top of a ListView at a given time.
         *
         * @return {Number}
         * @method getFirstVisibleIndex
         * @android
         * @ios
         * @since 0.1
         */
        getFirstVisibleIndex(): number;
        /**
         * This method returns the index of row which is visible at
         * the bottom of a ListView at a given time.
         *
         * @return {Number}
         * @method getLastVisibleIndex
         * @android
         * @ios
         * @since 0.1
         */
        getLastVisibleIndex(): number;
        /**
         * Sets the colors used in the refresh animation. On Android the first color
         * will also be the color of the bar that grows in response to a
         * user swipe gesture. iOS uses only the first color of the array.
         *
         * @method setPullRefreshColors
         * @param {UI.Color[]} colors
         * @android
         * @ios
         * @since 0.1
         */
        setPullRefreshColors(colors: Color[] | Color): void;
        /**
         * This method notify ListView for data changes. After this method is called
         * ListView refreshes itself and recreates the rows. Do not forget to
         * update itemCount property after data changes.
         *
         * @method refreshData
         * @android
         * @ios
         * @since 0.1
         */
        refreshData(): void;
        /**
         * This method notify the ListView  that given range of items deleted. Must set the itemCount value to a changed number before calling this function.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.ListView#performBatchUpdates performBatchUpdates}.
         *
         * @method deleteRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be removed from the data set
         * @param {Number} params.ios iOS specific property
         * @param {UI.ListView.iOS.RowAnimation} [params.ios.animation = UI.ListView.iOS.RowAnimation.AUTOMATIC]  A constant that indicates how the deletion is to be animated, for example, fade out or slide out from the bottom.
         * @android
         * @ios
         * @since 4.1.4
         */
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        /**
         * This method notify the ListView  that given range of items inserted. Must set the itemCount value to a changed number before calling this function.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.ListView#performBatchUpdates performBatchUpdates}.
         *
         * @method insertRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be inserted from the data set
         * @param {Number} params.ios iOS specific property
         * @param {UI.ListView.iOS.RowAnimation} [params.ios.animation = UI.ListView.iOS.RowAnimation.AUTOMATIC]  A constant that either specifies the kind of animation to perform when inserting the row or requests no animation.
         * @android
         * @ios
         * @since 4.1.4
         */
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        /**
         * This method notify the ListView  that given range of items changed.
         * For iOS, If you want to make multiple changes (insert, delete, refresh) as a single animation, you should use {UI.ListView#performBatchUpdates performBatchUpdates}.
         *
         * @method refreshRowRange
         * @param {Object} params
         * @param {Number} params.positionStart Position of start item
         * @param {Number} params.itemCount  Number of items to be changed from the data set
         * @param {Number} params.ios iOS specific property
         * @param {UI.ListView.iOS.RowAnimation} [params.ios.animation = UI.ListView.iOS.RowAnimation.AUTOMATIC]  A constant that indicates how the reloading is to be animated, for example, fade out or slide out from the bottom.
         * @android
         * @ios
         * @since 4.1.4
         */
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios?: {
                animation: RowAnimation;
            };
        }): void;
        /**
         * Enables the swiping behavior. For iOS, this property changes leftToRightSwipeEnabled and rightToLeftSwipeEnabled properties.
         *
         * @property {Boolean} [swipeEnabled = false]
         * @ios
         * @android
         * @since 4.1.4
         */
        swipeEnabled: boolean;
        /**
         * This method scrolls ListView to a specific index.
         *
         * @param {Number} index
         * @param {Boolean} [animated = true]
         * @method scrollTo
         * @android
         * @ios
         * @since 0.1
         */
        scrollTo(index: number, animated?: boolean): void;
        /**
         * This method cancels refresh operation and stops the refresh
         * indicator on a ListView. You should call this method after
         * finishing event inside onPullRefresh otherwise refresh indicator
         * never stops.
         *
         * @method stopRefresh
         * @android
         * @ios
         * @since 0.1
         */
        stopRefresh(): void;
        /**
         * This method start refresh operation and pops up refresh indicator on a ListView.
         * You should be using onPullRefresh on normal circumstances.
         *
         * @method startRefresh
         * @android
         * @ios
         * @since 0.1
         */
        startRefresh(): void;
        /**
         * Gets contentOffset of the ListView.
         *
         * @property contentOffset
         * @android
         * @ios
         * @readonly
         * @return {Object}
         * @return {Number} return.x
         * @return {Number} return.y
         * @since 3.1.3
         */
        readonly contentOffset: {
            readonly x: number;
            readonly y: number;
        };
        /**
         * This event is called when a ListView is scrolling. To remove this evet, set null.
         * For better performance, don't set any callback if does not
         * necessary
         *
         * @deprecated
         * @event onScroll
         * @param {Object} params
         * @param {Object} params.translation
         * @param {Number} params.translation.x
         * @param {Number} params.translation.y
         * @param {Object} params.contentOffset
         * @param {Number} params.contentOffset.x
         * @param {Number} params.contentOffset.y
         * @android
         * @ios
         * @since 0.1
         */
        onScroll: ((params?: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void) | null;
        /**
         * This event is called when user pulls down and releases a ListView
         * when scroll position is on the top.
         *
         * @deprecated
         * @event onPullRefresh
         * @android
         * @ios
         * @since 0.1
         */
        onPullRefresh: () => void;
        /**
         * Gets/Sets contentInset of the ListView.
         *
         * @property {Object} [contentInset = {top: 0,bottom: 0}]
         * @property {Number} contentInset.top
         * @property {Number} contentInset.bottom
         * @android
         * @ios
         * @since 3.0.2
         */
        contentInset: {
            top: number;
            bottom: number;
        };
        /**
         * This method returns ListViewItem
         *
         * @return {UI.ListViewItem}
         * @method listViewItemByIndex
         * @param {Number} index
         * @android
         * @ios
         * @since 0.1
         */
        listViewItemByIndex(index: number): ListViewItem | undefined;
        /**
         * This method returns ListViewItem's index.
         *
         * @return {Number} Returns the index of given {@link UI.ListViewItem listviewitem}.
         * @method indexByListViewItem
         * @param {UI.ListViewItem}
         * @android
         * @ios
         * @since 4.1.4
         */
        indexByListViewItem(item: ListViewItem): number;
        /**
         * This event is called when dragged item reordered in the list view.
         *
         * @deprecated
         * @param {Number} source
         * @param {Number} destination
         * @event onRowMoved
         * @ios
         * @android
         * @since 4.1.4
         */
        onRowMoved: (source: number, destination: number) => void;
        /**
         * This event is called when ListViewItem about to swipe. For iOS, this callback is triggered twice consecutively.
         *
         *     @example
         *     myListView.onRowSwipe = function (e) {
         *      if (e.direction == ListView.SwipeDirection.LEFTTORIGHT) {
         *          e.ios.expansionSettings.buttonIndex = -1;
         *          var archiveItem = new ListView.SwipeItem();
         *          archiveItem.text = "ARCHIVE " + e.index;
         *          archiveItem.backgroundColor = Color.GREEN;
         *          archiveItem.textColor = Color.BLACK;
         *          archiveItem.font = Font.create("Arial-ItalicMT", 8);
         *          archiveItem.ios.padding = 40;
         *
         *          archiveItem.ios.isAutoHide = false;
         *          archiveItem.onPress = function (e) {
         *              console.log("Archive : " + e.index);
         *          };
         *          return [archiveItem];
         *      }
         *      else if (e.direction == ListView.SwipeDirection.RIGHTTOLEFT) {
         *          e.ios.expansionSettings.buttonIndex = 0;
         *          e.ios.expansionSettings.threshold = 1.5;
         *          var deleteItem = new ListView.SwipeItem();
         *          deleteItem.text = "DELETE " + e.index;
         *          deleteItem.backgroundColor = Color.RED;
         *          deleteItem.textColor = Color.YELLOW;
         *          deleteItem.icon = Image.createFromFile("images://smartface.png");
         *          deleteItem.ios.iconTextSpacing = 10;
         *          deleteItem.onPress = function (e) {
         *              console.log("Delete Index : " + e.index);
         *          };
         *          var moreItem = new ListView.SwipeItem();
         *          moreItem.text = "MORE";
         *          moreItem.onPress = function (e) {
         *              console.log("More : " + e.index);
         *          };
         *          return [deleteItem, moreItem];
         *      }
         *     }
         *
         * @param {Object} params
         * @param {Number} params.index
         * @param {UI.ListView.SwipeDirection} params.direction
         * @param {Object} params.ios iOS specific
         * @param {Object} params.ios.expansionSettings
         * @param {Number} params.ios.expansionSettings.buttonIndex Index of the expandable button (If you do not want any buttons to be expandable, set buttonIndex to -1.)
         * @param {Boolean} params.ios.expansionSettings.fillOnTrigger if true the button fills the cell on trigger, else it bounces back to its initial position
         * @param {Number} params.ios.expansionSettings.threshold Size proportional threshold to trigger the expansion button. Default value 1.5
         * @event onRowSwipe
         * @return {UI.ListView.SwipeItem[]} Return set of swipe items. Android always just consider first index.
         * @ios
         * @android
         * @since 4.1.4
         *
         *
         */
        onRowSwipe: (e: {
            index: number;
            direction: SwipeDirection;
            ios: Partial<{
                expansionSettings: Partial<{
                    buttonIndex: number;
                    fillOnTrigger: boolean;
                    threshold: number;
                }>;
            }>;
        }) => SwipeItem[];
        /**
         * This event is called when dragged item before reordered in the list view.
         *
         * @deprecated
         * @param {Number} source
         * @param {Number} destination
         * @event onRowMove
         * @return {Boolean} Return true if source index can be reordered by destination index.
         * @ios
         * @android
         * @since 4.1.4
         */
        onRowMove: (source: number, destination: number) => boolean;
        /**
         * By default all the items are draggable if {@link UI.ListView#rowMoveEnabled rowMoveEnabled} is true, to restrict some rows set this method and change return value
         * by specific condition.
         *
         * @deprecated
         * @param {Number} index
         * @event onRowCanMove
         * @return {Boolean} Return true if index can be draggable
         * @ios
         * @android
         * @since 4.1.4
         */
        onRowCanMove: (index: number) => boolean;
        /**
         * By default all the items are swipeable if {@link UI.ListView#swipeEnabled swipeEnabled} is true, to restrict some rows set this method and change return value
         * by specific condition. For iOS, this callback is triggered twice consecutively.
         *
         * @deprecated
         * @param {Number} index
         * @event onRowCanSwipe
         * @return {UI.ListView.SwipeDirection[]} Return allowed swipe direction in array.
         * @ios
         * @android
         * @since 4.1.4
         */
        onRowCanSwipe: (index: number) => [SwipeDirection];
    }
    export class AbstractListView<TEvent extends string = ListViewEvents, TProps extends IListView = IListView> extends AbstractView<TEvent | ListViewEvents, any, TProps> implements IListView<TEvent | ListViewEvents> {
        constructor(params?: Partial<TProps>);
        onRowSwipe: (e: {
            index: number;
            direction: SwipeDirection;
            ios: Partial<{
                expansionSettings: Partial<{
                    buttonIndex: number;
                    fillOnTrigger: boolean;
                    threshold: number;
                }>;
            }>;
        }) => ISwipeItem[];
        onRowType: (index?: number) => number;
        onRowCreate: (type?: number) => ListViewItem;
        onRowHeight: (index?: number) => number;
        nativeInner: INativeInner;
        performBatchUpdates(updates: () => void, completion: {
            e: {
                finished: boolean;
            };
        }): void;
        onRowBind: (item: ListViewItem, index: number) => void;
        onRowSelected: (item: ListViewItem, index: number) => void;
        itemCount: number;
        rowHeight: number;
        verticalScrollBarEnabled: boolean;
        scrollEnabled: boolean;
        refreshEnabled: boolean;
        rowMoveEnabled: boolean;
        longPressDragEnabled: boolean;
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(colors: Color[] | Color): void;
        refreshData(): void;
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios?: {
                animation: RowAnimation;
            };
        }): void;
        swipeEnabled: boolean;
        scrollTo(index: number, animated?: boolean): void;
        startRefresh(): void;
        stopRefresh(): void;
        contentOffset: {
            readonly x: number;
            readonly y: number;
        };
        onScroll: ((params?: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void) | null;
        onPullRefresh: () => void;
        contentInset: {
            top: number;
            bottom: number;
        };
        listViewItemByIndex(index: number): ListViewItem | undefined;
        indexByListViewItem(item: ListViewItem): number;
        onAttachedToWindow: () => void;
        onDetachedFromWindow: () => void;
        onRowMoved: (source: number, destination: number) => void;
        onRowMove: (source: number, destination: number) => boolean;
        onRowCanMove: (index: number) => boolean;
        onRowCanSwipe: (index: number) => [SwipeDirection];
        static SwipeItem: SwipeItem;
        static iOS: {
            RowAnimation: RowAnimation;
        };
        static SwipeDirection: SwipeDirection;
    }
    const ListView: typeof AbstractListView;
    type ListView = AbstractListView;
    export default ListView;
}
declare module "ui/listview/listview.android" {
    import { IListView, RowAnimation } from "ui/listview/index";
    import Color from "ui/color/index";
    import ListViewItem from "ui/listviewitem/index";
    import { SwipeDirection } from "ui/swipeitem/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { ListViewEvents } from "ui/listview/listview-events";
    export default class ListViewAndroid<TEvent extends string = ListViewEvents> extends ViewAndroid<TEvent | ListViewEvents, any, IListView> implements IListView {
        private _layoutManager;
        private nativeDataAdapter;
        private _rowHeight;
        private _onScroll;
        private _onScrollListener;
        private _onScrollStateChanged;
        private _itemCount;
        private _contentInset;
        private _scrollEnabled;
        private _rowMoveEnabled;
        private _longPressDragEnabled;
        private _swipeEnabled;
        private _listViewItems;
        private nItemTouchHelper;
        private sfItemTouchHelperCallback;
        private sfSwipeItem;
        constructor(params?: IListView);
        nativeInner: INativeInner;
        onPullRefresh: IListView['onPullRefresh'];
        onRowType: IListView['onRowType'];
        onRowCreate: IListView['onRowCreate'];
        onRowHeight: IListView['onRowHeight'];
        onRowBind: IListView['onRowBind'];
        onRowSelected: IListView['onRowSelected'];
        onRowMoved: IListView['onRowMoved'];
        onRowSwipe: IListView['onRowSwipe'];
        onRowMove: IListView['onRowMove'];
        onRowCanMove: IListView['onRowCanMove'];
        onRowCanSwipe: IListView['onRowCanSwipe'];
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(colors: Color[] | Color): void;
        refreshData(): void;
        scrollTo(index: number, animated?: boolean): void;
        listViewItemByIndex(index: number): ListViewItem | undefined;
        startRefresh(): void;
        stopRefresh(): void;
        toString(): string;
        indexByListViewItem: (listViewItem: ListViewItem) => number;
        deleteRowRange: (params: Record<string, any>) => void;
        insertRowRange: (params: Record<string, any>) => void;
        refreshRowRange: (params: Record<string, any>) => void;
        private setContentInset;
        private createScrollListener;
        private setDataAdapter;
        private setNativeInner;
        private getAndroidParams;
        private getIOSParams;
        private setItemTouchHelper;
        get rowHeight(): number;
        set rowHeight(value: number);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get itemCount(): number;
        set itemCount(value: number);
        get swipeEnabled(): boolean;
        set swipeEnabled(value: boolean);
        get verticalScrollBarEnabled(): IListView['verticalScrollBarEnabled'];
        set verticalScrollBarEnabled(value: IListView['verticalScrollBarEnabled']);
        get refreshEnabled(): IListView['refreshEnabled'];
        set refreshEnabled(value: IListView['refreshEnabled']);
        get rowMoveEnabled(): boolean;
        set rowMoveEnabled(value: boolean);
        get longPressDragEnabled(): boolean;
        set longPressDragEnabled(value: boolean);
        get contentInset(): {
            top: number;
            bottom: number;
        };
        set contentInset(value: {
            top: number;
            bottom: number;
        });
        get onScroll(): ((params?: {
            translation: import("primitive/point2d").Point2D;
            contentOffset: import("primitive/point2d").Point2D;
        } | undefined) => void) | null;
        set onScroll(value: ((params?: {
            translation: import("primitive/point2d").Point2D;
            contentOffset: import("primitive/point2d").Point2D;
        } | undefined) => void) | null);
        get layoutManager(): {
            nativeObject: any;
        };
        get contentOffset(): {
            x: number;
            y: number;
        };
        static SwipeItem: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
        static SwipeDirection: typeof SwipeDirection;
        static iOS: {
            SemanticContentAttribute: typeof import("ui/view").SemanticContentAttribute;
            RowAnimation: typeof RowAnimation;
        };
    }
}
declare module "ui/listviewitem/listviewitem.ios" {
    import { IListViewItem, ListViewItemIOSProperties } from "ui/listviewitem/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import FlexLayoutIOS from "ui/flexlayout/flexlayout.ios";
    export default class ListViewItemIOS<TEvent extends string = FlexLayoutEvents, TNative = ListViewItemIOSProperties> extends FlexLayoutIOS<TEvent | FlexLayoutEvents, TNative, IListViewItem> implements IListViewItem {
        __nativeCell: __SF_UICollectionViewCell;
        nativeInner: any;
        constructor(params: IListViewItem);
    }
}
declare module "ui/listview/listview.ios" {
    import { IListView, RowAnimation } from "ui/listview/index";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import ListViewItem from "ui/listviewitem/index";
    import SwipeItem, { SwipeDirection, ISwipeItem } from "ui/swipeitem/index";
    import ViewIOS from "ui/view/view.ios";
    import { ListViewEvents } from "ui/listview/listview-events";
    import ListViewItemIOS from "ui/listviewitem/listviewitem.ios";
    export default class ListViewIOS<TEvent extends string = ListViewEvents> extends ViewIOS<TEvent | ListViewEvents, __SF_UITableView, IListView> implements IListView {
        nativeInner: INativeInner;
        private refreshControl;
        private _refreshEnabled;
        private _onPullRefresh;
        private _listItemArray;
        private _contentInset;
        constructor(params?: IListView);
        getFirstVisibleIndex(): number;
        getLastVisibleIndex(): number;
        setPullRefreshColors(value: Color[] | Color): void;
        refreshData(): void;
        deleteRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        insertRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios: Partial<{
                animation: RowAnimation;
            }>;
        }): void;
        refreshRowRange(params: {
            positionStart: number;
            itemCount: number;
            ios?: {
                animation: RowAnimation;
            };
        }): void;
        scrollTo(index: number, animated?: boolean): void;
        stopRefresh(): void;
        startRefresh(): void;
        listViewItemByIndex(index: number): ListViewItem;
        indexByListViewItem(item: ListViewItemIOS): number;
        onScroll: (params?: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void;
        get onPullRefresh(): () => void;
        set onPullRefresh(value: () => void);
        onRowType: (index?: number) => number;
        onRowCreate: (type?: number) => ListViewItemIOS;
        onRowHeight: (index?: number) => number;
        onRowBind: (item: ListViewItem, index: number) => void;
        onRowSelected: (item: ListViewItem, index: number) => void;
        onRowMoved: (source: number, destination: number) => void;
        onRowSwipe: (e: {
            index: number;
            direction: SwipeDirection;
            ios: Partial<{
                expansionSettings: Partial<{
                    buttonIndex: number;
                    fillOnTrigger: boolean;
                    threshold: number;
                }>;
            }>;
        }) => ISwipeItem[];
        onRowMove: (source: number, destination: number) => boolean;
        onRowCanMove: (index: number) => boolean;
        onRowCanSwipe: (index: number) => [SwipeDirection];
        private __onRowSwipeWrapper;
        private getIOSParams;
        private getAndroidParams;
        private setScrollEvents;
        private setNativeObjectParams;
        private deleteRow;
        protected _nativeObject: __SF_UITableView;
        get nativeObject(): __SF_UITableView;
        get paginationEnabled(): boolean;
        set paginationEnabled(value: boolean);
        get contentOffset(): __SF_NSRect;
        get swipeEnabled(): IListView['swipeEnabled'];
        set swipeEnabled(value: IListView['swipeEnabled']);
        get itemCount(): number;
        set itemCount(value: number);
        get rowHeight(): number;
        set rowHeight(value: number);
        get verticalScrollBarEnabled(): boolean;
        set verticalScrollBarEnabled(value: boolean);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get refreshEnabled(): boolean;
        set refreshEnabled(value: boolean);
        get contentInset(): {
            top: number;
            bottom: number;
        };
        set contentInset(value: {
            top: number;
            bottom: number;
        });
        get rowMoveEnabled(): boolean;
        set rowMoveEnabled(value: boolean);
        longPressDragEnabled: boolean;
        static iOS: {
            SemanticContentAttribute: {
                readonly AUTO: 0;
                readonly FORCELEFTTORIGHT: 3;
                readonly FORCERIGHTTOLEFT: 4;
            };
            RowAnimation: typeof RowAnimation;
        };
        static SwipeDirection: SwipeDirection;
        static SwipeItem: typeof SwipeItem;
    }
}
declare module "ui/listviewitem/listviewitem.android" {
    import { IListViewItem } from "ui/listviewitem/index";
    import { FlexLayoutEvents } from "ui/flexlayout/flexlayout-events";
    import FlexLayoutAndroid from "ui/flexlayout/flexlayout.android";
    export default class ListViewItemAndroid<TEvent extends string = FlexLayoutEvents, TNative = {}> extends FlexLayoutAndroid<TEvent | FlexLayoutEvents, TNative, IListViewItem> implements IListViewItem {
        nativeInner: any;
        constructor(params?: IListViewItem);
        get height(): number;
        set height(value: number);
        get width(): number;
        set width(value: number);
    }
}
declare module "ui/livemediaplayer/livemediaplayer-events" {
    export const LiveMediaPlayerEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly Change: "change";
    };
    export type LiveMediaPlayerEvents = ExtractValues<typeof LiveMediaPlayerEvents>;
}
declare module "ui/livemediaplayer/index" {
    import { AbstractView, IView } from "ui/view/index";
    import { ViewEvents } from "ui/view/view-event";
    import { LiveMediaPlayerEvents } from "ui/livemediaplayer/livemediaplayer-events";
    export enum ScaleType {
        /**
         * @property {Number} STRETCH
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        STRETCH = 0,
        /**
         * @property {Number} ASPECTFIT
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        ASPECTFIT = 1,
        /**
         * @property {Number} ASPECTFILL
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        ASPECTFILL = 2
    }
    /**
     * @class UI.LiveMediaPlayer
     * @since 4.2.2
     *
     * LiveMediaPublisher is a live streaming player. It is used for audio and video playback in RTMP/RTMPT/RTSP/HTTP/TCP/UDP/FILE format.
     *
     *     @example
     *     const LiveMediaPlayer = require('@smartface/native/ui/livemediaplayer');
     *
     *     let liveMediaPlayer = new LiveMediaPlayer({
     *         flexGrow: 1,
     *         backgroundColor: Color.GRAY,
     *         scaleType: LiveMediaPlayer.ScaleType.ASPECTFIT,
     *         inputUrl: "https://..."
     *     });
     *     liveMediaPlayer.start();
     *
     */
    export interface ILiveMediaPlayer<TEvent extends string = LiveMediaPlayerEvents> extends IView<TEvent | LiveMediaPlayerEvents> {
        /**
         * Set whether video is enabled
         *
         * @property {Boolean} videoEnabled
         * @android
         * @ios
         * @since 4.2.2
         */
        videoEnabled: boolean;
        /**
         * Set input stream adress. Supported protocols: RTMP/RTMPT/RTSP/HTTP/TCP/UDP/FILE
         *
         * @property {String} inputUrl
         * @android
         * @ios
         * @since 4.2.2
         */
        inputUrl: string;
        /**
         * Set whether audio is enabled
         *
         * @property {Boolean} audioEnabled
         * @android
         * @ios
         * @since 4.2.2
         */
        audioEnabled: boolean;
        /**
         * Set video zoom mode.
         *
         * @property {UI.LiveMediaPlayer.ScaleType} scaleType
         * @android
         * @ios
         * @since 4.2.2
         */
        scaleType: ScaleType;
        /**
         * Start playing.
         *
         * @method play
         * @android
         * @ios
         * @deprecated
         * @since 4.2.2
         */
        play(): void;
        /**
         * Pause playback.
         *
         * @method pause
         * @android
         * @ios
         * @since 4.2.2
         */
        pause(): void;
        /**
         * Returns whether it is currently playing.
         *
         * @method isPlaying
         * @android
         * @ios
         * @since 4.2.2
         */
        isPlaying(): boolean;
        /**
         * Release the underlying resources.
         *
         * @method release
         * @android
         * @ios
         * @since 4.2.2
         */
        release(): void;
        /**
         * Stop playing.
         *
         * @method stop
         * @android
         * @ios
         * @since 4.2.2
         */
        stop(): void;
        /**
         * Set the event callback.
         *
         * @event onChange
         * @deprecated
         * @param {Object} params
         * @param {Number} params.event See more: https://github.com/NodeMedia/NodeMediaClient-Android/blob/2.x/docs/NodePlayer_API_CN.md#%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83
         * @param {String} params.message
         * @android
         * @ios
         * @since 4.2.2
         * @example
         * ````
         * import LiveMediaPlayer from '@smartface/native/ui/livemediaplayer';
         *
         * const liveMediaPlayer = new LiveMediaPlayer();
         * liveMediaPlayer.on(LiveMediaPlayer.Events.Change, (params) => {
         *  console.info('onChange', params);
         * });
         * ````
         */
        onChange: (params: {
            event: number;
            message: string;
        }) => void;
    }
    export class AbstractLiveMediaPlayer<TEvent extends string = LiveMediaPlayerEvents> extends AbstractView<TEvent> implements ILiveMediaPlayer<TEvent> {
        static Events: LiveMediaPlayerEvents & ViewEvents;
        static ScaleType: ScaleType;
        videoEnabled: boolean;
        inputUrl: string;
        audioEnabled: boolean;
        scaleType: ScaleType;
        play(): void;
        pause(): void;
        isPlaying(): boolean;
        release(): void;
        stop(): void;
        onChange: (params: {
            event: number;
            message: string;
        }) => void;
    }
    const LiveMediaPlayer: typeof AbstractLiveMediaPlayer;
    type LiveMediaPlayer = AbstractLiveMediaPlayer;
    export default LiveMediaPlayer;
}
declare module "ui/livemediaplayer/livemediaplayer.android" {
    import LiveMediaPlayer, { ILiveMediaPlayer, ScaleType } from "ui/livemediaplayer/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { LiveMediaPlayerEvents } from "ui/livemediaplayer/livemediaplayer-events";
    export default class LiveMediaPlayerAndroid<TEvent extends string = LiveMediaPlayerEvents> extends ViewAndroid<TEvent | LiveMediaPlayerEvents, any> implements ILiveMediaPlayer {
        static ScaleType: {
            STRETCH: any;
            ASPECTFIT: any;
            ASPECTFILL: any;
        };
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
            readonly Change: "change";
        };
        private nodePlayer;
        private _inputUrl;
        private _scaleType;
        private _audioEnabled;
        private _videoEnabled;
        private _onChange;
        constructor(params?: Partial<LiveMediaPlayer>);
        get onChange(): (params: {
            event: number;
            message: string;
        }) => void;
        set onChange(callback: (params: {
            event: number;
            message: string;
        }) => void);
        get inputUrl(): string;
        set inputUrl(url: string);
        get audioEnabled(): boolean;
        set audioEnabled(isEnabled: boolean);
        get videoEnabled(): boolean;
        set videoEnabled(isEnabled: boolean);
        get scaleType(): ScaleType;
        set scaleType(mode: ScaleType);
        pause(): void;
        play(): void;
        stop(): void;
        release(): void;
        isPlaying(): any;
    }
}
declare module "ui/livemediaplayer/livemediaplayer.ios" {
    import LiveMediaPlayer, { ILiveMediaPlayer, ScaleType } from "ui/livemediaplayer/index";
    import ViewIOS from "ui/view/view.ios";
    import { LiveMediaPlayerEvents } from "ui/livemediaplayer/livemediaplayer-events";
    export default class LiveMediaPlayerIOS<TEvent extends string = LiveMediaPlayerEvents> extends ViewIOS<TEvent | LiveMediaPlayerEvents, {}> implements ILiveMediaPlayer {
        static ScaleType: {
            STRETCH: number;
            ASPECTFIT: number;
            ASPECTFILL: number;
        };
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
            readonly Change: "change";
        };
        private nodePlayer;
        private playerDelegate;
        private _inputUrl;
        private _scaleType;
        private _audioEnabled;
        private _videoEnabled;
        private _onChange;
        constructor(params?: Partial<LiveMediaPlayer>);
        get onChange(): (params: {
            event: number;
            message: string;
        }) => void;
        set onChange(callback: (params: {
            event: number;
            message: string;
        }) => void);
        get inputUrl(): string;
        set inputUrl(url: string);
        get audioEnabled(): boolean;
        set audioEnabled(isEnabled: boolean);
        get videoEnabled(): boolean;
        set videoEnabled(isEnabled: boolean);
        get scaleType(): ScaleType;
        set scaleType(mode: ScaleType);
        pause(): void;
        play(): void;
        stop(): void;
        release(): void;
        isPlaying(): any;
    }
}
declare module "ui/livemediapublisher/livemediapublisher-events" {
    export const LiveMediaPublisherEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly Change: "change";
    };
    export type LiveMediaPublisherEvents = ExtractValues<typeof LiveMediaPublisherEvents>;
}
declare module "ui/livemediapublisher/index" {
    import { AbstractView, IView } from "ui/view/index";
    import { LiveMediaPublisherEvents } from "ui/livemediapublisher/livemediapublisher-events";
    /**
     * //TODO Add definition
     * @enum {Number} UI.LiveMediaPublisher.Camera
     * @since 4.2.2
     * @android
     * @ios
     */
    export enum Camera {
        /**
         * Front camera id
         * @property {Number} FRONT
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        FRONT = 1,
        /**
         * Back camera id
         * @property {Number} BACK
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        BACK = 0
    }
    /**
     * //TODO Add definition
     * @enum {Number} UI.LiveMediaPublisher.VideoPreset
     * @since 4.2.2
     * @android
     * @ios
     */
    export enum VideoPreset {
        /**
         * @property {Number} PRESET_16X9_270
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_270 = 0,
        /**
         * @property {Number} PRESET_16X9_360
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_360 = 1,
        /**
         * @property {Number} PRESET_16X9_480
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_480 = 2,
        /**
         * @property {Number} PRESET_16X9_540
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_540 = 3,
        /**
         * @property {Number} PRESET_16X9_720
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_720 = 4,
        /**
         * @property {Number} PRESET_16X9_1080
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_16X9_1080 = 5,
        /**
         * @property {Number} PRESET_4X3_270
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_4X3_270 = 10,
        /**
         * @property {Number} PRESET_4X3_360
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_4X3_360 = 11,
        /**
         * @property {Number} PRESET_4X3_480
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_4X3_480 = 12,
        /**
         * @property {Number} PRESET_4X3_540
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_4X3_540 = 13,
        /**
         * @property {Number} PRESET_4X3_720
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_4X3_720 = 14,
        /**
         * @property {Number} PRESET_1X1_270
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_1X1_270 = 20,
        /**
         * @property {Number} PRESET_1X1_360
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_1X1_360 = 21,
        /**
         * @property {Number} PRESET_1X1_480
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_1X1_480 = 22,
        /**
         * @property {Number} PRESET_1X1_540
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_1X1_540 = 23,
        /**
         * @property {Number} PRESET_1X1_720
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        PRESET_1X1_720 = 23
    }
    /**
     * //TODO Add definition
     * @enum {Number} UI.LiveMediaPublisher.VideoProfile
     * @since 4.2.2
     * @android
     * @ios
     */
    export enum VideoProfile {
        /**
         * @property {Number} BASELINE
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        BASELINE = 0,
        /**
         * @property {Number} MAIN
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        MAIN = 1,
        /**
         * @property {Number} HIGH
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        HIGH = 1
    }
    /**
     * //TODO Add definition
     * @enum {Number} UI.LiveMediaPublisher.AudioProfile
     * @since 4.2.2
     * @android
     * @ios
     */
    export enum AudioProfile {
        /**
         * @property {Number} LCAAC
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        LCAAC = 0,
        /**
         * @property {Number} HEAAC
         * @android
         * @ios
         * @static
         * @readonly
         * @android
         * @ios
         * @since 4.2.2
         */
        HEAAC = 1
    }
    /**
     * @class UI.LiveMediaPublisher
     * @since 4.2.2
     *
     * LiveMediaPublisher is a live streaming publisher. It is used for audio and video playback in RTMP/RTMPT/RTSP/HTTP/TCP/UDP/FILE format.
     *
     *     @example
     *     const LiveMediaPublisher = require('@smartface/native/ui/livemediapublisher');
     *
     *     let liveMediaPublisher = new LiveMediaPublisher({
     *         flexGrow: 1,
     *         backgroundColor: Color.GRAY,
     *         outputUrl: "rtmp://..."
     *     });
     *     liveMediaPublisher.startPreview();
     *     liveMediaPublisher.start(); // Start streaming
     */
    export interface ILiveMediaPublisher<TEvent extends string = LiveMediaPublisherEvents> extends IView<TEvent | LiveMediaPublisherEvents, any> {
        /**
         * The camera starts to preview.
         *
         * @method startPreview
         * @android
         * @ios
         * @since 4.2.2
         */
        startPreview(): void;
        /**
         * The camera stops to preview.
         *
         * @method stopPreview
         * @android
         * @ios
         * @since 4.2.2
         */
        stopPreview(): void;
        /**
         * Switch between rear and front camera.
         *
         * @method switchCamera
         * @android
         * @ios
         * @since 4.2.2
         */
        switchCamera(): void;
        /**
         * Set whether to keep audio is turned on.
         *
         * @property {Boolean} audioEnabled
         * @android
         * @ios
         * @since 4.2.2
         */
        audioEnabled: boolean;
        /**
         * Set whether to keep audio is turned on.
         *
         * @property {Boolean} videoEnabled
         * @android
         * @ios
         * @since 4.2.2
         */
        videoEnabled: boolean;
        /**
         * Set whether to keep flash is turned on.
         *
         * @property {Boolean} flashEnabled
         * @android
         * @ios
         * @since 4.2.2
         */
        flashEnabled: boolean;
        /**
         * Set output adress. Supported protocols: RTMP/RTMPT/HTTP/FLV
         *
         * @property {String} outputUrl
         * @android
         * @ios
         * @since 4.2.2
         */
        outputUrl: string;
        /**
         * Set camera preview parameters.
         * @property {Object} camera
         * @property {UI.LiveMediaPublisher.Camera} camera.cameraId Camera id
         * @property {Boolean} camera.cameraFrontMirror Camera front mirror
         * @android
         * @ios
         * @since 4.2.2
         */
        camera: Partial<{
            cameraId: Camera;
            cameraFrontMirror: Boolean;
        }>;
        /**
         * Set audio encoding parameters.
         * @property {Object} audio
         * @property {Number} audio.bitrate Audio bitrate
         * @property {UI.LiveMediaPublisher.AudioProfile} audio.profile Audio encoding format
         * @property {Number} audio.samplerate Audio sample rate
         * @android
         * @ios
         * @since 4.2.2
         */
        audio: Partial<{
            bitrate: number;
            profile: AudioProfile;
            samplerate: number;
        }>;
        /**
         * Set video encoding parameters.
         * @property {Object} video
         * @property {UI.LiveMediaPublisher.Preset} video.preset Video resolution preset.
         * @property {Number} video.bitrate Video bitrate
         * @property {UI.LiveMediaPublisher.VideoProfile} video.profile Video encoding specifications
         * @property {Number} video.fps Video frame rate
         * @property {Boolean} video.videoFrontMirror The video output screen is mirror-inverted or not
         * @android
         * @ios
         * @since 4.2.2
         */
        video: Partial<{
            preset: VideoPreset;
            bitrate: number;
            profile: VideoProfile;
            fps: number;
            videoFrontMirror: Boolean;
        }>;
        /**
         * Start stream to output address.
         *
         * @method start
         * @android
         * @ios
         * @since 4.2.2
         */
        start(): void;
        /**
         * Release the underlying resources.
         *
         * @method release
         * @android
         * @since 4.2.2
         */
        release(): void;
        /**
         * Stop stream.
         *
         * @method stop
         * @android
         * @ios
         * @since 4.2.2
         */
        stop(): void;
        /**
         * Set the event callback.
         *
         * @event onChange
         * @deprecated
         * @param {Object} params
         * @param {Number} params.event See more: https://github.com/NodeMedia/NodeMediaClient-Android/blob/2.x/docs/NodePlayer_API_CN.md#%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83
         * @param {String} params.message
         * @android
         * @ios
         * @since 4.2.2
         * @example
         * ````
         * import LiveMediaPublisher from '@smartface/native/ui/livemediapublisher';
         *
         * const liveMediaPublisher = new LiveMediaPublisher();
         * liveMediaPublisher.on(LiveMediaPublisher.Events.Change, (params) => {
         *  console.info('onChange', params);
         * });
         * ````
         */
        onChange: (params: {
            event: number;
            message: string;
        }) => void;
    }
    export class AbstractLiveMediaPublisher<TEvent extends string = LiveMediaPublisherEvents> extends AbstractView<TEvent> implements ILiveMediaPublisher<TEvent | LiveMediaPublisherEvents> {
        startPreview(): void;
        stopPreview(): void;
        switchCamera(): void;
        audioEnabled: boolean;
        videoEnabled: boolean;
        flashEnabled: boolean;
        outputUrl: string;
        camera: {
            cameraId: Camera;
            cameraFrontMirror: Boolean;
        };
        audio: {
            bitrate: number;
            profile: AudioProfile;
            samplerate: number;
        };
        video: Partial<{
            preset: VideoPreset;
            bitrate: number;
            profile: VideoProfile;
            fps: number;
            videoFrontMirror: Boolean;
        }>;
        start(): void;
        release(): void;
        stop(): void;
        onChange: (params: {
            event: number;
            message: string;
        }) => void;
        static Events: typeof LiveMediaPublisherEvents;
        static Camera: typeof Camera;
        static VideoPreset: typeof VideoPreset;
        static VideoProfile: typeof VideoProfile;
        static AudioProfile: typeof AudioProfile;
    }
    const LiveMediaPublisher: typeof AbstractLiveMediaPublisher;
    type LiveMediaPublisher = AbstractLiveMediaPublisher;
    export default LiveMediaPublisher;
}
declare module "ui/livemediapublisher/livemediapublisher.android" {
    import LiveMediaPublisher, { AudioProfile, Camera, ILiveMediaPublisher, VideoPreset, VideoProfile } from "ui/livemediapublisher/index";
    import ViewIOS from "ui/view/view.ios";
    import { LiveMediaPublisherEvents } from "ui/livemediapublisher/livemediapublisher-events";
    export default class LiveMediaPublisherAndroid<TEvent extends string = LiveMediaPublisherEvents> extends ViewIOS<TEvent | LiveMediaPublisherEvents, {}> implements ILiveMediaPublisher {
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
            readonly Change: "change";
        };
        static Camera: typeof Camera;
        static VideoPreset: typeof VideoPreset;
        static VideoProfile: typeof VideoProfile;
        static AudioProfile: typeof AudioProfile;
        private _outputUrl;
        private _flashEnabled;
        private _audioEnabled;
        private _videoEnabled;
        private _videoOptions;
        private _cameraOptions;
        private _audioOptions;
        private _onChange;
        private nodePublisher;
        constructor(params?: Partial<LiveMediaPublisher>);
        get onChange(): (params: {
            event: number;
            message: string;
        }) => void;
        set onChange(callback: (params: {
            event: number;
            message: string;
        }) => void);
        get audioEnabled(): boolean;
        set audioEnabled(value: boolean);
        get videoEnabled(): boolean;
        set videoEnabled(value: boolean);
        get video(): Partial<{
            preset: number;
            bitrate: number;
            profile: number;
            fps: number;
            videoFrontMirror: boolean;
        }>;
        set video(options: Partial<{
            preset: number;
            bitrate: number;
            profile: number;
            fps: number;
            videoFrontMirror: boolean;
        }>);
        get camera(): Partial<{
            cameraId: number;
            cameraFrontMirror: boolean;
        }>;
        set camera(options: Partial<{
            cameraId: number;
            cameraFrontMirror: boolean;
        }>);
        get audio(): Partial<{
            bitrate: number;
            profile: number;
            samplerate: number;
        }>;
        set audio(options: Partial<{
            bitrate: number;
            profile: number;
            samplerate: number;
        }>);
        get outputUrl(): string;
        set outputUrl(url: string);
        get flashEnabled(): boolean;
        set flashEnabled(value: boolean);
        start(): void;
        stop(): void;
        startPreview(): void;
        stopPreview(): void;
        switchCamera(): void;
        release(): void;
    }
}
declare module "ui/livemediapublisher/livemediapublisher.ios" {
    import LiveMediaPublisher, { AudioProfile, Camera, ILiveMediaPublisher, VideoPreset, VideoProfile } from "ui/livemediapublisher/index";
    import ViewIOS from "ui/view/view.ios";
    import { LiveMediaPublisherEvents } from "ui/livemediapublisher/livemediapublisher-events";
    export default class LiveMediaPublisherIOS<TEvent extends string = LiveMediaPublisherEvents> extends ViewIOS<TEvent | LiveMediaPublisherEvents, {}> implements ILiveMediaPublisher {
        static Events: {
            readonly Touch: "touch";
            readonly TouchCancelled: "touchCancelled";
            readonly TouchEnded: "touchEnded";
            readonly TouchMoved: "touchMoved";
            readonly Change: "change";
        };
        static Camera: typeof Camera;
        static VideoPreset: typeof VideoPreset;
        static VideoProfile: typeof VideoProfile;
        static AudioProfile: typeof AudioProfile;
        private nodePublisher;
        private publisherDelegate;
        private _outputUrl;
        private _flashEnabled;
        private _audioEnabled;
        private _videoEnabled;
        private _videoOptions;
        private _cameraOptions;
        private _audioOptions;
        private _onChange;
        constructor(params?: Partial<LiveMediaPublisher>);
        get onChange(): (params: {
            event: number;
            message: string;
        }) => void;
        set onChange(callback: (params: {
            event: number;
            message: string;
        }) => void);
        get audioEnabled(): boolean;
        set audioEnabled(value: boolean);
        get videoEnabled(): boolean;
        set videoEnabled(value: boolean);
        get video(): Partial<{
            preset: number;
            bitrate: number;
            profile: number;
            fps: number;
            videoFrontMirror: boolean;
        }>;
        set video(options: Partial<{
            preset: number;
            bitrate: number;
            profile: number;
            fps: number;
            videoFrontMirror: boolean;
        }>);
        get camera(): Partial<{
            cameraId: number;
            cameraFrontMirror: boolean;
        }>;
        set camera(options: Partial<{
            cameraId: number;
            cameraFrontMirror: boolean;
        }>);
        get audio(): Partial<{
            bitrate: number;
            profile: number;
            samplerate: number;
        }>;
        set audio(options: Partial<{
            bitrate: number;
            profile: number;
            samplerate: number;
        }>);
        get outputUrl(): string;
        set outputUrl(url: string);
        get flashEnabled(): boolean;
        set flashEnabled(value: boolean);
        start(): void;
        stop(): void;
        startPreview(): void;
        stopPreview(): void;
        switchCamera(): void;
        release(): void;
    }
}
declare module "ui/mapview/pin/pin-events" {
    export const PinEvents: {
        readonly InfoWindowPress: "infoWindowPress";
        readonly Press: "press";
    };
    export type PinEvents = ExtractValues<typeof PinEvents>;
}
declare module "ui/mapview/pin/index" {
    import { ConstructorOf } from "core/constructorof";
    import { IEventEmitter } from "core/eventemitter/index";
    import { INativeComponent } from "core/inative-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import { PinEvents } from "ui/mapview/pin/pin-events";
    type IPinIOS = {
        enableInfoWindow: boolean;
    };
    export interface IPin<TEvent extends string = PinEvents, TMobile extends MobileOSProps<IPinIOS, {}> = MobileOSProps<IPinIOS, {}>> extends INativeComponent, IEventEmitter<TEvent | PinEvents> {
        location: {
            latitude: number;
            longitude: number;
        };
        android: TMobile['android'];
        ios: TMobile['ios'];
        title: string;
        subtitle: string;
        color: Color;
        id: number;
        image: Image | null;
        visible: boolean;
        isClusterEnabled: boolean;
        /**
         * This event will be fired when the pin is touched.
         *
         * @event onPress
         * @deprecated
         * @android
         * @ios
         * @since 1.1.2
         * @example
         * ````
         * import Pin from '@smartface/native/ui/mapview/pin';
         *
         * const pin = new Pin();
         * pin.on(Pin.Events.Press, () => {
         *  console.info('onPress');
         * });
         * ````
         */
        onPress: () => void;
        /**
         * @deprecated
         * @example
         * ````
         * import Pin from '@smartface/native/ui/mapview/pin';
         *
         * const pin = new Pin();
         * pin.on(Pin.Events.InfoWindowPress, () => {
         *  console.info('onInfoWindowPress');
         * });
         * ````
         */
        onInfoWindowPress: () => void;
    }
    const Pin: ConstructorOf<IPin, Partial<IPin>>;
    type Pin = IPin;
    export default Pin;
}
declare module "ui/mapview/mapview-events" {
    export const MapViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly CameraMoveEnded: "cameraMoveEnded";
        readonly CameraMoveStarted: "cameraMoveStarted";
        readonly ClusterPress: "clusterPress";
        readonly Create: "create";
        readonly LongPress: "longPress";
        readonly Press: "press";
    };
    export type MapViewEvents = ExtractValues<typeof MapViewEvents>;
}
declare module "ui/mapview/cluster/index" {
    import MapView from "ui/mapview/index";
    import { ConstructorOf } from "core/constructorof";
    import { INativeComponent } from "core/inative-component";
    export interface ICluster extends INativeComponent {
        title: string;
        subtitle: string;
        canShowCallout: boolean;
        count: number;
        setDefaultClusterRenderer(mapView: MapView, nativeGoogleMap: any, nativeClusterManager: any): any;
    }
    const Cluster: ConstructorOf<ICluster, Partial<ICluster>>;
    type Cluster = ICluster;
    export default Cluster;
}
declare module "ui/mapview/index" {
    import { AbstractView, IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import Pin from "ui/mapview/pin/index";
    import { MapViewEvents } from "ui/mapview/mapview-events";
    import { MobileOSProps } from "core/native-mobile-component";
    import { AbstractFont } from "ui/font/font";
    import Cluster from "ui/mapview/cluster/index";
    /**
     * @enum UI.MapView.Type
     * @static
     * @readonly
     * @since 0.1
     *
     * This property indicates how map will be displayed.
     *
     */
    export enum MapViewType {
        /**
         * @property {Number} NORMAL
         * @android
         * @ios
         * @static
         * @readonly
         * @since 0.1
         */
        NORMAL = 0,
        /**
         * @property {Number} SATELLITE
         * @android
         * @ios
         * @static
         * @readonly
         * @since 0.1
         */
        SATELLITE = 1,
        /**
         * @property {Number} HYBRID
         * @android
         * @ios
         * @static
         * @readonly
         * @since 0.1
         */
        HYBRID = 2
    }
    export type IMapViewAdroid = ViewAndroidProps & {
        /**
         * This property sets visibility of my location button.
         * @property {Boolean} [locationButtonVisible = false]
         * @android
         * @since 3.0.1
         */
        locationButtonVisible: boolean;
        /**
         * Prepare the map asynchronously. You must call this method manually. Use this method after page onShow callback.
         *
         * @android
         * @method prepareMap
         * @since 3.1.0
         */
        prepareMap(): void;
    };
    export type IMapViewIOS = ViewIOSProps & {
        /**
         * This property sets cluster borderWidth. Only works on ios.
         *
         * @property {Number} [clusterBorderWidth = 2]
         * @ios
         * @since 3.0.1
         */
        clusterBorderWidth?: number;
        /**
         * This property sets cluster size. Only works on ios. If cluster size is 0, wraps the content according to font properties. In Android, wraps the content according to font properties.
         *
         * @property {Number} [clusterSize = 0]
         * @ios
         * @since 3.0.1
         */
        clusterSize?: number;
        /**
         * This property sets cluster padding. Work when cluster size is 0. Only works on ios.
         *
         * @property {Number} [clusterPadding = 15]
         * @ios
         * @since 3.0.1
         */
        clusterPadding?: number;
    };
    /**
     * @class UI.MapView
     * @since 0.1
     * @extends UI.View
     * MapView is a view that shows Apple Maps on iOS and Google Maps on Android.
     *
     *     @example
     *     const MapView = require('@smartface/native/ui/mapview');
     *     var myMapView = new MapView({
     *         flexGrow: 1,
     *         alignSelf: FlexLayout.AlignSelf.STRETCH,
     *         onCreate: function() {
     *             var centerLocation = {
     *                 latitude: 37.4488259,
     *                 longitude: -122.1600047
     *             };
     *             myMapView.setCenterLocationWithZoomLevel(centerLocation,11,false);
     *             var myPin = new MapView.Pin({
     *                 location: {
     *                     latitude: 37.4488259,
     *                     longitude: -122.1600047
     *                 },
     *                 title: 'Smartface Inc.',
     *                 subtitle: '2nd Floor, 530 Lytton Ave, Palo Alto, CA 94301',
     *                 color: Color.RED,
     *                 onPress: function() {
     *                     const Application = require('@smartface/native/application');
     *                     Application.call("geo:" + myPin.location.latitude + ',' + myPin.location.longitude, {
     *                         'hl': 'en',
     *                     });
     *                 }
     *             });
     *             myMapView.addPin(myPin);
     *        }
     *     });
     *     myPage.layout.addChild(myMapView);
     *
     */
    export interface IMapView<TEvent extends string = MapViewEvents, TMobile extends MobileOSProps<IMapViewIOS, IMapViewAdroid> = MobileOSProps<IMapViewIOS, IMapViewAdroid>> extends IView<TEvent | MapViewEvents, any, TMobile> {
        /**
         * Enables/Disables scroll gestures so that map can be dragged.
         *
         * @property {Boolean} [scrollEnabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        scrollEnabled: boolean;
        /**
         * Enables/Disables rotate gestures so that map can be rotated.
         *
         * @property {Boolean} [rotateEnabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        rotateEnabled: boolean;
        /**
         * Enables/Disables compass on map.
         *
         * @property {Boolean} [compassEnabled = true]
         * @android
         * @ios
         * @since 0.1
         */
        compassEnabled: boolean;
        /**
         * Enables/Disables user location indicator on map.
         *
         * @property {Boolean} [userLocationEnabled = false]
         * @android
         * @ios
         * @since 1.1.10
         */
        userLocationEnabled: boolean;
        /**
         * Enables/Disables clusterEnabled on map. Cluster works on Android & iOS 11.0+.
         *
         * @property {Boolean} [clusterEnabled = false]
         * @android
         * @ios
         * @since 3.0.1
         */
        clusterEnabled: boolean;
        /**
         * This property sets cluster fillColor. Cluster works on Android & iOS 11.0+.
         *
         * @property {UI.Color} clusterFillColor
         * @android
         * @ios
         * @since 3.0.1
         */
        clusterFillColor: Color;
        /**
         * This property sets cluster borderColor. Cluster works on Android & iOS 11.0+.
         *
         * @property {UI.Color} clusterBorderColor
         * @ios
         * @android
         * @since 3.0.1
         */
        clusterBorderColor: Color;
        /**
         * This property sets cluster textColor. Cluster works on Android & iOS 11.0+.
         *
         * @property {UI.Color} clusterTextColor
         * @android
         * @ios
         * @since 3.0.1
         */
        clusterTextColor: Color;
        /**
         * This property sets cluster font. Cluster works on Android & iOS 11.0+.
         *
         * @property {UI.Font} clusterFont
         * @android
         * @ios
         * @since 3.0.1
         */
        clusterFont: Font;
        /**
         * Triggered when pressed on the cluster. Cluster works on Android & iOS 11.0+.
         *
         * @event onClusterPress
         * @deprecated
         * @param {Array<UI.MapView.Pin>} pins
         * @android
         * @ios
         * @since 3.0.1
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.ClusterPress, (params) => {
         * 	console.info('onClusterPress', params);
         * });
         * ````
         */
        onClusterPress: (pins: Pin[]) => void;
        /**
         * This property sets center location of the map to the given latitude & longitude.
         *
         * @method setCenterLocationWithZoomLevel
         * @param {Object} centerLocation
         * @param {Number} centerLocation.latitude
         * @param {Number} centerLocation.longitude
         * @param {Number} zoomLevel
         * @param {Boolean} animated
         * @android
         * @ios
         * @since 3.2.1
         */
        setCenterLocationWithZoomLevel(centerLocation: {
            latitude: number;
            longitude: number;
        }, zoomLevel: number, animated: boolean): void;
        /**
         * This property gets zoom level of the map to the given level. if user changed zoom level via pinching you will get different value than you set. Default of this property is 3 on iOS and 8 on Android.
         *
         * @property {Number} zoomLevel
         * @readonly
         * @android
         * @ios
         * @since 1.1.10
         */
        readonly zoomLevel: number | undefined;
        /**
         * Gets/sets minimum zoom level.
         * @property {Number} [minZoomLevel = 0]
         * @android
         * @ios
         * @since 2.0.9
         */
        minZoomLevel: number;
        /**
         * Gets/sets minimum zoom level.
         * @property {Number} [maxZoomLevel = 19]
         * @android
         * @ios
         * @since 2.0.9
         */
        maxZoomLevel: number;
        /**
         * This property gets center location of the map to the given latitude & longitude. Getting this property must be
         * in onCreate event or after.
         *
         * @property {Object} centerLocation
         * @android
         * @ios
         * @readonly
         * @since 0.1
         */
        readonly centerLocation: {
            latitude: number;
            longitude: number;
        };
        zoomEnabled: boolean;
        /**
         * Contains the four points defining the four-sided polygon that is visible in a map's camera. This polygon can be a trapezoid instead of a rectangle, because a camera can have tilt. If the camera is directly over the center of the camera, the shape is rectangular, but if the camera is tilted, the shape will appear to be a trapezoid whose smallest side is closest to the point of view.
         *
         * @property {Object} visibleRegion
         * @property {Object} visibleRegion.topLeft that defines the top left corner of the camera.
         * @property {Number} visibleRegion.topLeft.latitude
         * @property {Number} visibleRegion.topLeft.longitude
         * @property {Object} visibleRegion.topRight that defines the top right corner of the camera.
         * @property {Number} visibleRegion.topRight.latitude
         * @property {Number} visibleRegion.topRight.longitude
         * @property {Object} visibleRegion.bottomLeft that defines the bottom left corner of the camera.
         * @property {Number} visibleRegion.bottomLeft.latitude
         * @property {Number} visibleRegion.bottomLeft.longitude
         * @property {Object} visibleRegion.bottomRight that defines the bottom right corner of the camera.
         * @property {Number} visibleRegion.bottomRight.latitude
         * @property {Number} visibleRegion.bottomRight.longitude
         * @android
         * @ios
         * @readonly
         * @since 4.3.2
         */
        readonly visibleRegion: {
            topLeft: {
                latitude: number;
                longitude: number;
            };
            topRight: {
                latitude: number;
                longitude: number;
            };
            bottomLeft: {
                latitude: number;
                longitude: number;
            };
            bottomRight: {
                latitude: number;
                longitude: number;
            };
        } | undefined;
        /**
         * Get visible pins on MapView.
         *
         * @return {UI.MapView.Pin[]} Visible pin array.
         * @android
         * @ios
         * @method getVisiblePins
         * @since 2.0.7
         */
        getVisiblePins(): Pin[];
        /**
         * Adds a UI.MapView.Pin on the map.
         *
         * @param {UI.MapView.Pin} pin
         * @android
         * @ios
         * @method addPin
         * @since 0.1
         */
        addPin(pin: Pin): void;
        /**
         * Removes the UI.MapView.Pin from the map.
         *
         * @param {UI.MapView.Pin} pin
         * @method removePin
         * @android
         * @ios
         * @since 0.1
         */
        removePin(pin: Pin): void;
        /**
         * Removes all pins from the map.
         *
         * @method removeAllPins
         * @android
         * @ios
         * @since 3.1.1
         */
        removeAllPins(): void;
        /**
         * Triggered when pressed on the map and sends the location pressed on the map.
         *
         * @event onPress
         * @deprecated
         * @param {Object} location
         * @param {Number} location.latitude
         * @param {Number} location.longitude
         * @android
         * @ios
         * @since 1.1.3
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.Press, (params) => {
         * 	console.info('onPress', params);
         * });
         * ````
         */
        onPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        /**
         * Gets/sets callback for dragging start.
         *
         * @event onCameraMoveStarted
         * @deprecated
         * @android
         * @ios
         * @since 2.0.9
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.CameraMoveStarted, () => {
         * 	console.info('onCameraMoveStarted');
         * });
         * ````
         */
        onCameraMoveStarted: () => void;
        /**
         * Gets/sets callback for dragging end.
         *
         * @event onCameraMoveEnded
         * @deprecated
         * @android
         * @ios
         * @since 2.0.9
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.CameraMoveEnded, () => {
         * 	console.info('onCameraMoveEnded');
         * });
         * ````
         */
        onCameraMoveEnded: () => void;
        /**
         * Triggered when long pressed on the map and sends the location pressed on the map.
         *
         * @event onLongPress
         * @param {Object} location
         * @param {Number} location.latitude
         * @param {Number} location.longitude
         * @deprecated
         * @android
         * @ios
         * @since 1.1.3
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.LongPress, (params) => {
         * 	console.info('onLongPress', params);
         * });
         * ````
         */
        onLongPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        /**
         * This event is called when map is ready to be used.
         *
         * @deprecated
         * @since 0.1
         * @event onCreate
         * @android
         * @ios
         * @example
         * ````
         * import MapView from '@smartface/native/ui/mapview';
         *
         * const mapView = new MapView();
         * mapView.on(MapView.Events.Create, () => {
         * 	console.info('onCreate');
         * });
         * ````
         */
        onCreate: () => void;
        /**
         * Gets/Sets map type
         *
         * @deprecated
         * @property {UI.MapView.Type} [type = UI.MapView.Type.NORMAL]
         * @android
         * @ios
         * @since 0.1
         */
        type: MapViewType;
    }
    export class AbstractMapView<TEvent extends string = MapViewEvents> extends AbstractView<TEvent | MapViewEvents, any, IMapView> implements IMapView<TEvent | MapViewEvents> {
        constructor(params?: Partial<IMapView>);
        zoomEnabled: boolean;
        scrollEnabled: boolean;
        rotateEnabled: boolean;
        compassEnabled: boolean;
        userLocationEnabled: boolean;
        clusterEnabled: boolean;
        clusterFillColor: Color;
        clusterBorderColor: Color;
        clusterTextColor: Color;
        clusterFont: AbstractFont;
        onClusterPress: (pins: Pin[]) => void;
        setCenterLocationWithZoomLevel(centerLocation: {
            latitude: number;
            longitude: number;
        }, zoomLevel: number, animated: boolean): void;
        zoomLevel: number | undefined;
        minZoomLevel: number;
        maxZoomLevel: number;
        centerLocation: {
            latitude: number;
            longitude: number;
        };
        visibleRegion: {
            topLeft: {
                latitude: number;
                longitude: number;
            };
            topRight: {
                latitude: number;
                longitude: number;
            };
            bottomLeft: {
                latitude: number;
                longitude: number;
            };
            bottomRight: {
                latitude: number;
                longitude: number;
            };
        } | undefined;
        getVisiblePins(): Pin[];
        addPin(pin: Pin): void;
        removePin(pin: Pin): void;
        removeAllPins(): void;
        onPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onCameraMoveStarted: () => void;
        onCameraMoveEnded: () => void;
        onLongPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onCreate: () => void;
        type: MapViewType;
        static Type: MapViewType;
        static Pin: typeof Pin;
        static Cluster: typeof Cluster;
    }
    const MapView: typeof AbstractMapView;
    type MapView = AbstractMapView;
    export default MapView;
}
declare module "ui/mapview/pin/pin.android" {
    import { IPin } from "ui/mapview/pin/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import ColorAndroid from "ui/color/color.android";
    import ImageAndroid from "ui/image/image.android";
    import { PinEvents } from "ui/mapview/pin/pin-events";
    export default class PinAndroid<TEvent extends string = PinEvents> extends NativeEventEmitterComponent<TEvent | PinEvents, any> implements IPin {
        private _color;
        private _image;
        private _location;
        private _clusterColor;
        private _subtitle;
        private _title;
        private _visible;
        private _id;
        /**
         * nativeObject will be taken from constructor as parameter since pin is created on mapview.
         */
        constructor(params?: IPin);
        get color(): ColorAndroid;
        set color(value: ColorAndroid);
        get id(): number;
        set id(value: number);
        get image(): ImageAndroid | null;
        set image(value: ImageAndroid | null);
        isClusterEnabled: boolean;
        get location(): {
            latitude: number;
            longitude: number;
        };
        set location(value: {
            latitude: number;
            longitude: number;
        });
        get title(): string;
        set title(value: string);
        get subtitle(): string;
        set subtitle(value: string);
        get visible(): boolean;
        set visible(value: boolean);
        get clusterColor(): ColorAndroid | null;
        set clustercolor(value: ColorAndroid | null);
        onPress: () => void;
        onInfoWindowPress: () => void;
    }
}
declare module "ui/mapview/mapview.android" {
    import { IMapView, MapViewType } from "ui/mapview/index";
    import Color from "ui/color/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { MapViewEvents } from "ui/mapview/mapview-events";
    import PinAndroid from "ui/mapview/pin/pin.android";
    import FontAndroid from "ui/font/font.android";
    export default class MapViewAndroid<TEvent extends string = MapViewEvents> extends ViewAndroid<TEvent | MapViewEvents, any, IMapView> implements IMapView {
        onClusterPress: (pins: PinAndroid[]) => void;
        onPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onCameraMoveStarted: () => void;
        onCameraMoveEnded: () => void;
        onLongPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onCreate: () => void;
        protected savedBundles: any;
        protected activityIntent: any;
        protected _borderColor: Color;
        private lazyLoading;
        private _font;
        private _fillColor;
        private _textColor;
        private _nativeCustomMarkerRenderer;
        private _nativeGoogleMap;
        private _clusterEnabled;
        private _pins;
        private _pendingPins;
        private _isMoveStarted;
        private _nativeClusterManager;
        private _zoomLevel;
        private _centerLocation;
        private _compassEnabled;
        private _rotateEnabled;
        private _scrollEnabled;
        private _zoomEnabled;
        private _userLocationEnabled;
        private _type;
        private _maxZoomLevel;
        private _minZoomLevel;
        private _locationButtonVisible;
        private _pinArray;
        constructor(params?: IMapView);
        getVisiblePins(): PinAndroid[];
        addPin(pin: PinAndroid): void;
        removePin(pin: PinAndroid): void;
        removeAllPins(): void;
        setCenterLocationWithZoomLevel(centerLocation: {
            latitude: number;
            longitude: number;
        }, zoomLevel: number, animated: boolean): void;
        private createItem;
        private asyncMap;
        private getandroidProps;
        private startCluster;
        get centerLocation(): {
            latitude: any;
            longitude: any;
        };
        get visibleRegion(): IMapView['visibleRegion'];
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get rotateEnabled(): boolean;
        set rotateEnabled(value: boolean);
        get compassEnabled(): boolean;
        set compassEnabled(value: boolean);
        get clusterEnabled(): boolean;
        set clusterEnabled(value: boolean);
        get zoomEnabled(): boolean;
        set zoomEnabled(value: boolean);
        get maxZoomLevel(): number;
        set maxZoomLevel(value: number);
        get minZoomLevel(): number;
        set minZoomLevel(value: number);
        get zoomLevel(): number | undefined;
        set zoomLevel(value: number | undefined);
        get userLocationEnabled(): boolean;
        set userLocationEnabled(value: boolean);
        get cluster(): import("ui/mapview/cluster").ICluster;
        get clusterFillColor(): any;
        set clusterFillColor(value: any);
        get clusterBorderColor(): any;
        set clusterBorderColor(value: any);
        get clusterTextColor(): any;
        set clusterTextColor(value: any);
        get clusterFont(): FontAndroid;
        set clusterFont(value: FontAndroid);
        get type(): MapViewType;
        set type(value: MapViewType);
        toString(): string;
        static Type: typeof MapViewType;
        static Pin: typeof PinAndroid;
        static Cluster: import("core/constructorof").ConstructorOf<import("ui/mapview/cluster").ICluster, Partial<import("ui/mapview/cluster").ICluster>>;
    }
}
declare module "ui/mapview/cluster/cluster.ios" {
    import { ICluster } from "ui/mapview/cluster/index";
    import MapView from "ui/mapview/index";
    import NativeComponent from "core/native-component";
    export default class ClusterIOS extends NativeComponent<__SF_Cluster> implements ICluster {
        constructor(params?: Partial<ICluster>, nativeObject?: __SF_Cluster);
        get title(): string;
        set title(value: string);
        get subtitle(): string;
        set subtitle(value: string);
        get canShowCallout(): boolean;
        set canShowCallout(value: boolean);
        get count(): number;
        set count(value: number);
        setDefaultClusterRenderer(mapView: MapView, nativeGoogleMap: any, nativeClusterManager: any): void;
    }
}
declare module "ui/mapview/mapview.ios" {
    import { IMapView, MapViewType } from "ui/mapview/index";
    import ViewIOS from "ui/view/view.ios";
    import ClusterIOS from "ui/mapview/cluster/cluster.ios";
    import { MapViewEvents } from "ui/mapview/mapview-events";
    import Pin from "ui/mapview/pin/index";
    export default class MapViewIOS<TEvent extends string = MapViewEvents> extends ViewIOS<TEvent | MapViewEvents, any, IMapView> implements IMapView {
        private tapGesture;
        private longGesture;
        private _isFirstRender;
        private _pinArray;
        private _minZoomLevel;
        private _maxZoomLevel;
        private _zoomLevel;
        private _cluster;
        constructor(params?: Partial<IMapView>);
        getVisiblePins(): Pin[];
        addPin(pin: Pin): void;
        removePin(pin: Pin): void;
        removeAllPins(): void;
        setCenterLocationWithZoomLevel(centerLocation: {
            latitude: number;
            longitude: number;
        }, zoomLevel: number, animated: boolean): void;
        onPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onCameraMoveStarted: () => void;
        onCameraMoveEnded: () => void;
        onLongPress: (location: {
            latitude: number;
            longitude: number;
        }) => void;
        onClusterPress: (pins: Pin[]) => void;
        onCreate: () => void;
        private getAndroidProps;
        private getIOSProps;
        private setGestureHandlers;
        private coordinateSpanWithCenterCoordinate;
        private longitudeToPixelSpaceX;
        private latitudeToPixelSpaceY;
        private pixelSpaceXToLongitude;
        private pixelSpaceYToLatitude;
        private setZoomLevelWithAnimated;
        private setNativeEvents;
        get scrollEnabled(): IMapView['scrollEnabled'];
        set scrollEnabled(value: IMapView['scrollEnabled']);
        get rotateEnabled(): IMapView['rotateEnabled'];
        set rotateEnabled(value: IMapView['rotateEnabled']);
        get compassEnabled(): IMapView['compassEnabled'];
        set compassEnabled(value: IMapView['compassEnabled']);
        get userLocationEnabled(): IMapView['userLocationEnabled'];
        set userLocationEnabled(value: IMapView['userLocationEnabled']);
        get clusterEnabled(): IMapView['clusterEnabled'];
        set clusterEnabled(value: IMapView['clusterEnabled']);
        get cluster(): ClusterIOS;
        get clusterFillColor(): IMapView['clusterFillColor'];
        set clusterFillColor(value: IMapView['clusterFillColor']);
        get clusterBorderColor(): IMapView['clusterBorderColor'];
        set clusterBorderColor(value: IMapView['clusterBorderColor']);
        get clusterTextColor(): IMapView['clusterTextColor'];
        set clusterTextColor(value: IMapView['clusterTextColor']);
        get clusterFont(): IMapView['clusterFont'];
        set clusterFont(value: IMapView['clusterFont']);
        get zoomLevel(): number | undefined;
        set zoomLevel(value: number | undefined);
        get minZoomLevel(): number;
        set minZoomLevel(value: number);
        get maxZoomLevel(): number;
        set maxZoomLevel(value: number);
        get centerLocation(): IMapView['centerLocation'];
        get zoomEnabled(): IMapView['zoomEnabled'];
        set zoomEnabled(value: IMapView['zoomEnabled']);
        get visibleRegion(): IMapView['visibleRegion'];
        get type(): MapViewType;
        set type(value: MapViewType);
        static Pin: import("core/constructorof").ConstructorOf<import("ui/mapview/pin").IPin<"press" | "infoWindowPress", import("core/native-mobile-component").MobileOSProps<{
            enableInfoWindow: boolean;
        }, {}>>, Partial<import("ui/mapview/pin").IPin<"press" | "infoWindowPress", import("core/native-mobile-component").MobileOSProps<{
            enableInfoWindow: boolean;
        }, {}>>>>;
        static Cluster: typeof ClusterIOS;
        static Type: typeof MapViewType;
    }
}
declare module "ui/mapview/cluster/cluster.android" {
    import { ICluster } from "ui/mapview/cluster/index";
    import MapView from "ui/mapview/index";
    import NativeComponent from "core/native-component";
    export default class ClusterAndroid extends NativeComponent<any> implements ICluster {
        constructor(params?: Partial<ICluster>, nativeObject?: __SF_Cluster);
        title: string;
        subtitle: string;
        canShowCallout: boolean;
        count: number;
        setDefaultClusterRenderer(mapView: MapView, nativeGoogleMap: any, nativeClusterManager: any): any;
    }
}
declare module "ui/mapview/pin/pin.ios" {
    import { IPin } from "ui/mapview/pin/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import ColorIOS from "ui/color/color.ios";
    import { IImage } from "ui/image/index";
    import { PinEvents } from "ui/mapview/pin/pin-events";
    export default class PinIOS<TEvent extends string = PinEvents> extends NativeEventEmitterComponent<TEvent | PinEvents, __SF_Annotation, IPin> implements IPin {
        constructor(params?: IPin);
        get color(): ColorIOS;
        set color(value: ColorIOS);
        get id(): number;
        set id(value: number);
        get image(): IImage | null;
        set image(value: IImage | null);
        isClusterEnabled: boolean;
        get location(): any;
        set location(value: any);
        get title(): string;
        set title(value: string);
        get subtitle(): string;
        set subtitle(value: string);
        get visible(): boolean;
        set visible(value: boolean);
        onPress: () => void;
        onInfoWindowPress: () => void;
        private getIOSProps;
    }
}
declare module "ui/materialtextbox/materialtextbox-events" {
    export const MaterialTextBoxEvents: any;
    export type MaterialTextBoxEvents = ExtractValues<typeof MaterialTextBoxEvents>;
}
declare module "ui/materialtextbox/index" {
    import { ITextBox } from "ui/textbox/index";
    import Font from "ui/font/index";
    import Color from "ui/color/index";
    import View from "ui/view/index";
    import { MaterialTextBoxEvents } from "ui/materialtextbox/materialtextbox-events";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    export type iOSProps = ITextBox['ios'] & Partial<{
        /**
         * This property used to assign a view left of MaterialTextBox. The given view's width & height must be specified. This property does not work when multiline is true.
         *
         * @property {Object} leftLayout
         * @property {UI.View} leftLayout.view
         * @property {Number} leftLayout.width
         * @property {Number} leftLayout.height
         * @android
         * @ios
         * @since 3.2.1
         */
        leftLayout: {
            view: View;
            width: number;
            height?: number;
        };
        /**
         * This event is called when positioning leftLayout. This event can be called multiple times.
         * @param {Object} bounds MaterialTextBox bounds.
         * @param {Number} bounds.x
         * @param {Number} bounds.y
         * @param {Number} bounds.width
         * @param {Number} bounds.height
         * @param {Object} defaultRect
         * @param {Number} defaultRect.x
         * @param {Number} defaultRect.y
         * @param {Number} defaultRect.width
         * @param {Number} defaultRect.height
         * @return {Object} Rect
         * @return {Number} return.x
         * @return {Number} return.y
         * @return {Number} return.width
         * @return {Number} return.height
         * @event onLeftLayoutRectForBounds
         * @deprecated
         * @ios
         * @since 4.3.0
         * @example
         * ````
         * import MaterialTextBox from '@smartface/native/ui/materialtextbox';
         *
         * const materialTextBox = new MaterialTextBox();
         * materialTextBox.on(MaterialTextBox.Events.LeftLayoutRectForBounds, (params) => {
         *  console.info('onLeftLayoutRectForBounds', params);
         * });
         * ````
         */
        onLeftLayoutRectForBounds: (bounds?: Object, defaultRect?: Object) => Object;
        /**
         * This event is called when positioning rightLayout. This event can be called multiple times.
         * @param {Object} bounds MaterialTextBox bounds.
         * @param {Number} bounds.x
         * @param {Number} bounds.y
         * @param {Number} bounds.width
         * @param {Number} bounds.height
         * @param {Object} defaultRect
         * @param {Number} defaultRect.x
         * @param {Number} defaultRect.y
         * @param {Number} defaultRect.width
         * @param {Number} defaultRect.height
         * @return {Object} Rect
         * @return {Number} return.x
         * @return {Number} return.y
         * @return {Number} return.width
         * @return {Number} return.height
         * @event onRightLayoutRectForBounds
         * @deprecated
         * @ios
         * @since 4.3.0
         * @example
         * ````
         * import MaterialTexBox from '@smartface/native/ui/materialtextbox';
         *
         * const materialTextBox = new MaterialTextBox();
         * materialTextBox.on(MaterialTextBox.Events.RightLayoutRectForBounds, (params) => {
         *  console.info('onRightLayoutRectForBounds', params);
         * });
         * ````
         */
        onRightLayoutRectForBounds: (bounds?: Object, defaultRect?: Object) => Object;
        /**
         * Gets/sets the rightLayoutLeftPadding of the MaterialTextBox.
         * @property {Number} rightLayoutLeftPadding
         * @ios
         * @since 4.3.0
         */
        rightLayoutLeftPadding: number;
        /**
         * Gets/sets the leftLayoutRightPadding of the MaterialTextBox.
         * @property {Number} leftLayoutRightPadding
         * @ios
         * @since 4.3.0
         */
        leftLayoutRightPadding: number;
        /**
         * Gets/sets the inlineHintFont of the MaterialTextBox. This property overrides the labelsFont property for characterRestriction.
         * @property {UI.Font} inlineHintFont
         * @ios
         * @since 4.3.0
         */
        inlineHintFont: Font;
        /**
         * Gets/sets the underlineLabelsFont of the MaterialTextBox. This property overrides the labelsFont property for error and characterRestriction font.
         * @property {UI.Font} underlineLabelsFont
         * @ios
         * @since 4.3.0
         */
        underlineLabelsFont: Font;
        /**
         * Gets/sets the clearButtonColor of the MaterialTextBox.
         * @property {UI.Color} clearButtonColor
         * @ios
         * @since 4.3.0
         */
        clearButtonColor: Color | null;
        /**
         * Gets/sets the lineHeight of the MaterialTextBox.
         * @property {Number} lineHeight
         * @ios
         * @since 3.1.2
         */
        lineHeight: number;
        /**
         * Gets/sets the selectedLineHeight of the MaterialTextBox.
         * @property {Number} selectedLineHeight
         * @ios
         * @since 3.1.2
         */
        selectedLineHeight: number;
        /**
         * Gets/sets the expandsOnOverflow of the MaterialTextBox.
         * @property {Boolean} expandsOnOverflow
         * @ios
         * @since 4.3.6
         */
        expandsOnOverflow: boolean;
    }>;
    export type AndroidProps = ITextBox['android'] & Partial<{
        /**
         * Gets/sets the textBoxMaxHeight of the MaterialTextBox.This property is necessary because it has same reason with textBoxHeight property.
         *
         * @property {Number} textBoxMaxHeight
         * @android
         * @since 3.1.2
         * @deprecated 3.2.1 TextBox grows as its wrapper
         */
        textBoxMaxHeight: number;
        /**
         * Gets/sets the enableErrorMessage of the MaterialTextBox. To change error dynamically, you should set this property at the creation moment.
         *
         * @property {Boolean} enableErrorMessage
         * @android
         * @since 3.1.2
         */
        enableErrorMessage: boolean;
        /**
         * Gets/sets the enableCharacterRestriction of the MaterialTextBox. To change counter dynamically at runtime, you should set this property at the creation moment.
         *
         * @property {Boolean} enableCharacterRestriction
         * @android
         * @since 3.1.2
         */
        enableCharacterRestriction: boolean;
        /**
         * Gets/sets the textBoxHeight of the MaterialTextBox. This property is necessary because of the textbox does not grow its height with wrapper container(MaterialTextBox actually is a wrapper of views in Android).
         *
         * @property {Number} textBoxHeight
         * @android
         * @since 3.1.2
         * @deprecated 3.2.1 TextBox grows as its wrapper
         */
        textBoxHeight: number;
        /**
         * Gets/sets the maxLines of the MaterialTextBox.
         * Setting this value overrides previous maximum height configurations.
         *
         * @property {Number} maxLines
         * @android
         * @since 4.3.6
         */
        maxLines: number;
    }>;
    export interface IMaterialTextBox<TEvent extends string = MaterialTextBoxEvents, TIOS = iOSProps, TAND = AndroidProps> extends ITextBox<TEvent | MaterialTextBoxEvents, MobileOSProps<iOSProps, AndroidProps>> {
        /**
         * Gets/sets the lineCount of the MaterialTextBox. You can use this property when multiline is true.
         * @property {Number} [lineCount = 1]
         * @ios
         * @android
         * @since 4.3.0
         */
        lineCount: number;
        /**
         * Gets/sets the multiline of the MaterialTextBox. You should set this property at constructor method.
         * @property {Boolean} [multiline = false]
         * @ios
         * @android
         * @since 4.3.0
         */
        multiline: boolean;
        /**
         * Gets/sets the selectedHintTextColor of the MaterialTextBox.
         * @property {UI.Color} selectedHintTextColor
         * @ios
         * @android
         * @since 3.1.2
         */
        selectedHintTextColor: Color | null;
        /**
         * This property used to assign a view right of MaterialTextBox. The given view's width & height must be specified.
         *
         * @property {Object} rightLayout
         * @property {UI.View} rightLayout.view
         * @property {Number} rightLayout.width
         * @property {Number} rightLayout.height
         * @android
         * @ios
         * @since 3.2.1
         */
        rightLayout: {
            view: View | null;
            width: number;
            height?: number;
        };
        /**
         * Gets/sets the lineColor of the MaterialTextBox. In Android, if error message appears then line color cannot be changed.
         * @property {Object} [lineColor = {}]
         * @property {UI.Color} lineColor.normal
         * @property {UI.Color} lineColor.selected
         * @android
         * @ios
         * @since 3.1.2
         */
        lineColor: {
            normal: Color | null;
            selected: Color | null;
        };
        /**
         * Gets/sets the errorColor of the MaterialTextBox. In Android, hint text color does not changed as iOS.
         * @property {UI.Color} errorColor
         * @android
         * @ios
         * @since 3.1.2
         */
        errorColor: Color | null;
        /**
         * Gets/sets the errorMessage of the MaterialTextBox.
         * @property {String} errorMessage
         * @android
         * @ios
         * @since 3.1.2
         */
        errorMessage: string;
        /**
         * Gets/sets the characterRestriction of the MaterialTextBox.
         * @property {Number} characterRestriction
         * @android
         * @ios
         * @since 3.1.2
         */
        characterRestriction: number | undefined;
        /**
         * Gets/sets the characterRestrictionColor of the MaterialTextBox.
         * @property {UI.Color} characterRestrictionColor
         * @android
         * @ios
         * @since 3.1.2
         */
        characterRestrictionColor: Color | null;
        /**
         * Gets/sets the labelsFont of the MaterialTextBox. In Android, sets the font to hint and any other labels (such as error and counter labels) but size of font does not take into account except for hint text size.
         * Before using this property you should enable counter, error and give hint text. For iOS, this property overrides the underlineLabelsFont property for error and characterRestriction font.
         *
         * @property {UI.Font} labelsFont
         * @android
         * @ios
         * @since 3.1.3
         */
        labelsFont: Font;
        /**
         * Gets/sets font of a Label.
         * In Android, to make hint text size as your given text size assign the font property in constructor.
         *
         *     @example
         *     import Label from '@smartface/native/ui/label';
         *     import Font from '@smartface/native/ui/font';
         *     const myLabel = new Label({
         *         text: "This is my label",
         *         visible: true
         *     });
         *     myLabel.font = Font.create("Arial", 16, Font.BOLD);
         *
         * @property {UI.Font} font
         * @android
         * @ios
         * @since 0.1
         */
        font: Font;
    }
    /**
     * @class UI.MaterialTextBox
     * @since 3.1.2
     * @extends UI.TextBox
     * MaterialTextBox is a UI which users can edit the text.
     *
     *     @example
     *     import MaterialTextBox from '@smartface/native/ui/materialtextbox';
     *     const materialtextbox = new MaterialTextBox({
     *         height : 50,
     *         hint : "Hint"
     *     });
     *     myPage.layout.addChild(materialtextbox);
     *
     */
    const MaterialTexBox: ConstructorOf<IMaterialTextBox, Partial<IMaterialTextBox>>;
    type MaterialTexBox = IMaterialTextBox;
    export default MaterialTexBox;
}
declare module "ui/textview/textview-events" {
    export const TextViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        /**
         * This event is called when user click link string. onLinkClick just work with attributedText.
         *
         *     @example
         *     myTextView.on(Events.LinkClick, function(string) {
         *         console.log(string);
         *     });
         *
         * @param {String} string
         * @event onLinkClick
         * @android
         * @ios
         * @since 3.0.0
         */
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        /**
         * This event is called when user click link string. onLinkClick just work with attributedText.
         *
         *     @example
         *     myTextView.on(Events.LinkClick, function(string) {
         *         console.log(string);
         *     });
         *
         * @param {String} string
         * @event onLinkClick
         * @android
         * @ios
         * @since 3.0.0
         */
        readonly LinkClick: "linkClick";
    };
    export type TextViewEvents = ExtractValues<typeof TextViewEvents>;
}
declare module "ui/textview/index" {
    import { ILabel } from "ui/label/index";
    import { TextViewEvents } from "ui/textview/textview-events";
    import { ConstructorOf } from "core/constructorof";
    import { Size } from "primitive/size";
    import { MobileOSProps } from "core/native-mobile-component";
    import AttributedString from "global/attributedstring/index";
    import { Point2D } from "primitive/point2d";
    export type TextViewiOSProps = ILabel['ios'] & {
        /**
         * Sets/gets visibiliy of scroll bar when text is too long.
         *
         * @property {Boolean} [showScrollBar = false]
         * @ios
         * @since 3.0.0
         */
        showScrollBar: boolean;
        contentOffset: Point2D;
        paginationEnabled: boolean;
    };
    export type TextViewAndroidPRoperties = ILabel['android'];
    /**
     * @since 3.0.0
     * TextView is a view that displays read-only text on the screen.
     *
     *     @example
     *     import TextView from '@smartface/native/ui/textview';
     *     import Color from '@smartface/native/ui/color';
     *     const myTextview = new TextView({
     *         text: "This is my textview",
     *         visible: true
     *     });
     *     myTextview.width = 200,
     *     myTextview.height = 50,
     *     myTextview.top = 10,
     *     myTextview.left = 20,
     *     myTextview.backgroundColor = Color.GRAY;
     */
    export interface ITextView<TEvent extends string = TextViewEvents, TMobile extends MobileOSProps<TextViewiOSProps, TextViewAndroidPRoperties> = MobileOSProps<TextViewiOSProps, TextViewAndroidPRoperties>> extends ILabel<TEvent | TextViewEvents, TMobile> {
        /**
         * Gets/sets HTML text value of TextView. This property helps user showing HTML
         * texts on the screen. In Android, you must avoid to using selectable property to make the links clickable.
         *
         *     @example
         *     // In this example 'This link' text inside TextView will shown underlined.
         *     import TextView from '@smartface/native/ui/textview';
         *     var myTextView = new TextView();
         *     myTextView.htmlText = "<a href='http://www.smartface.io'>This link</a> will redirect you to Smartface website.";
         *
         * @android
         * @ios
         * @since 3.0.0
         */
        htmlText: string;
        /**
         * Enables/disables selectable status of the TextView. If set to true
         * the text inside the TextView will be selectable.
         *
         * @android
         * @ios
         * @since 3.0.0
         */
        selectable: boolean;
        /**
         * Enable/Disable scroll bar when text is too long. If this property is "false", text alignment mid & bottom doesn't work and in Android, it will lose ability of click in attributed string.
         *
         * @ios
         * @android
         * @since 4.0.2
         */
        scrollEnabled: boolean;
        /**
         * Gets/sets attributedText on TextView.
         *
         *     @example
         *     import System from '@smartface/native/device/system';
         *     import TextView from '@smartface/native/ui/textview';
         *     import Color from '@smartface/native/ui/color';
         *     import Font from '@smartface/native/ui/font';
         *     import AttributedString from '@smartface/native/ui/attributedstring';
         *
         *     const textView = new TextView({
         *         flexGrow: 1,
         *         lineSpacing : 20
         *     });
         *
         *     if (System.OS === System.OSType.IOS) {
         *         textView.letterSpacing = 5;
         *     } else{
         *         // letterSpacing working on ANDROID Lollipop (API-21) AND UPPER
         *         textView.letterSpacing = 0.3;
         *     }
         *
         *     textView.onClick = function(string){
         *         console.log("String " + string);
         *     };
         *
         *     const attributeString = new AttributedString();
         *     attributeString.string = "First\n";
         *     attributeString.foregroundColor = Color.GREEN;
         *
         *     const attributeString2 = new AttributedString();
         *     attributeString2.string = "Second";
         *     attributeString2.link = "Second Link ";
         *
         *     const attributeString3 = new AttributedString();
         *     attributeString3.string = " Third";
         *     attributeString3.link = "Third Link";
         *     attributeString3.backgroundColor = Color.RED;
         *     attributeString3.underline = true;
         *     attributeString3.font = Font.create("Times New Roman",30,Font.NORMAL);
         *     attributeString3.ios.underlineColor = Color.YELLOW;
         *
         *     textView.attributedText = [attributeString,attributeString2,attributeString3];
         *
         * @property {Array} [attributedText = []]
         * @android
         * @ios
         * @since 3.0.0
         */
        attributedText: AttributedString[];
        /**
         * This method returns height & width of given attributed text. This method should be
         * used after assigning all needed properties. If attributedText is not set, this method returns null.
         *
         * @android
         * @ios
         * @since 3.2.1
         */
        getAttributeTextSize(maxWidth: number): Size | null;
        /**
         * This event is called when user click link string. onLinkClick only works with attributedText.
         * Use this with EventEmitter
         * @param {String} string
         * @event onLinkClick
         * @android
         * @deprecated
         * @ios
         * @since 3.0.0
         * @example
         * ````
         * import TextView from '@smartface/native/ui/textview';
         *
         * const textView = new TextView();
         * textView.on(TextView.Events.LinkClick, (params) => {
         *  console.info('onLinkClick', params);
         * });
         * ````
         */
        onLinkClick: (e: string) => void;
        /**
         * Gets/sets letterSpacing on TextView. letterSpacing just work with attributedText.
         *
         * For iOS,
         * This value specifies the number of points by which to adjust kern-pair characters.
         * Kerning prevents unwanted space from occurring between specific characters and depends on the font.
         * The value 0 means kerning is disabled. The default value for this attribute is 0.
         *
         * For Android,
         * Sets text letterSpacing in em units. Typical values for slight expansion will be around 0.05. Negative values tighten text.
         * The em is simply the font size. In an element with a 2in font, 1em thus means 2in.
         * Expressing sizes, such as margins and paddings, in em means they are related to the font size, and if the user has a big font (e.g., on a big screen) or a small font (e.g., on a handheld device), the sizes will be in proportion.
         * Declarations such as 'text-indent: 1.5em' and 'margin: 1em' are extremely common in CSS.
         *
         * @android
         * @ios
         * @since 3.0.0
         */
        letterSpacing: number;
        /**
         * Gets/sets lineSpacing on TextView. lineSpacing just work with attributedText.
         *
         * @property {Number} [lineSpacing = 0]
         * @android
         * @ios
         * @since 3.0.0
         */
        lineSpacing: number;
    }
    const TextView: ConstructorOf<ITextView, Partial<ITextView>>;
    type TextView = ITextView;
    export default TextView;
}
declare module "ui/textbox/textbox.android" {
    import { ITextBox } from "ui/textbox/index";
    import ActionKeyType from "ui/shared/android/actionkeytype";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import KeyboardType from "ui/shared/keyboardtype";
    import TextAlignment from "ui/shared/textalignment";
    import { ViewAndroid } from "ui/view/view.android";
    import AutoCapitalize from "ui/textbox/autocapitalize";
    import { TextBoxEvents } from "ui/textbox/textbox-events";
    export default class TextBoxAndroid<TEvent extends string = TextBoxEvents, TNative = {}, TProps extends ITextBox = ITextBox> extends ViewAndroid<TEvent | TextBoxEvents, TNative, TProps> implements ITextBox {
        private __touchEnabled;
        private _isPassword;
        private _keyboardType;
        private _actionKeyType;
        private _onTextChanged;
        private _cursorColor;
        private _hintTextColor;
        private _textColor;
        private _font;
        private _textAlignment;
        private _onEditBegins;
        private _onEditEnds;
        private _onActionButtonPress;
        private _hasEventsLocked;
        private _autoCapitalize;
        private _didAddTextChangedListener;
        private _didSetOnEditorActionListener;
        private activity;
        constructor(params: Partial<TProps>);
        private get androidProps();
        get font(): Font;
        set font(value: Font);
        get text(): string;
        set text(value: string);
        get autoCapitalize(): AutoCapitalize;
        set autoCapitalize(value: AutoCapitalize);
        get textAlignment(): TextAlignment;
        set textAlignment(value: TextAlignment);
        get textColor(): Color;
        set textColor(value: Color);
        get cursorPosition(): {
            start: number;
            end: number;
        };
        set cursorPosition(value: {
            start: number;
            end: number;
        });
        get touchEnabled(): boolean;
        set touchEnabled(value: boolean);
        get onEditBegins(): () => void;
        set onEditBegins(value: () => void);
        get cursorColor(): Color;
        set cursorColor(value: Color);
        get hint(): string;
        set hint(value: string);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get isPassword(): boolean;
        set isPassword(value: boolean);
        get keyboardType(): KeyboardType;
        set keyboardType(value: KeyboardType);
        get actionKeyType(): ActionKeyType;
        set actionKeyType(value: ActionKeyType);
        showKeyboard(): void;
        hideKeyboard(): void;
        requestFocus(): void;
        removeFocus(): void;
        get onTextChanged(): (e?: {
            insertedText: string;
            location: number;
        }) => void;
        set onTextChanged(value: (e?: {
            insertedText: string;
            location: number;
        }) => void);
        onClearButtonPress(): void;
        get onEditEnds(): () => void;
        set onEditEnds(value: () => void);
        get onActionButtonPress(): (e?: {
            actionKeyType: ActionKeyType;
        }) => void;
        set onActionButtonPress(value: (e?: {
            actionKeyType: ActionKeyType;
        }) => void);
        toString(): string;
        updateInputType(unsetFlags: number, setFlags: number): void;
    }
}
declare module "ui/materialtextbox/materialtextbox.android" {
    import { IMaterialTextBox } from "ui/materialtextbox/index";
    import { Point2D } from "primitive/point2d";
    import Color from "ui/color/index";
    import FlexLayout from "ui/flexlayout/index";
    import Font from "ui/font/index";
    import TextBoxAndroid from "ui/textbox/textbox.android";
    import { MaterialTextBoxEvents } from "ui/materialtextbox/materialtextbox-events";
    export default class MaterialTextBoxAndroid<TEvent extends string = MaterialTextBoxEvents> extends TextBoxAndroid<TEvent | MaterialTextBoxEvents, any, IMaterialTextBox> implements IMaterialTextBox {
        private sfTextBox;
        private textBoxNativeObject;
        private __hintTextColor;
        private _hintFocusedTextColor;
        private _errorText;
        private _lineColorObj;
        private _errorColor;
        private _characterRestrictionColor;
        private __font;
        private _rightLayout;
        private _rightLayoutWidth;
        private _enableCounterMaxLength;
        private _enableCounter;
        private _enableErrorMessage;
        private _enableCharacterRestriction;
        private _touchEnable;
        private nativeTextInputEditText;
        constructor(params?: Partial<IMaterialTextBox>);
        get hint(): string;
        set hint(value: string);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get selectedHintTextColor(): Color | null;
        set selectedHintTextColor(value: Color | null);
        get lineColor(): {
            normal: Color | null;
            selected: Color | null;
        };
        set lineColor(value: {
            normal: Color | null;
            selected: Color | null;
        });
        get lineCount(): number;
        set lineCount(value: number);
        get multiline(): boolean;
        set multiline(value: boolean);
        get errorColor(): Color | null;
        set errorColor(value: Color | null);
        get labelsFont(): Font;
        set labelsFont(value: Font);
        get testId(): any;
        set testId(value: any);
        get touchEnabled(): boolean;
        set touchEnabled(value: boolean);
        get rightLayout(): {
            view: FlexLayout | null;
            width: number;
            height?: number;
        };
        set rightLayout(value: {
            view: FlexLayout | null;
            width: number;
            height?: number;
        });
        get onTouch(): (e?: Point2D) => boolean | void;
        set onTouch(value: (e?: Point2D) => boolean | void);
        get onTouchEnded(): (isInside: boolean, point: Point2D) => boolean | void;
        set onTouchEnded(value: (isInside: boolean, point: Point2D) => boolean | void);
        get onTouchMoved(): (e: boolean | {
            isInside: boolean;
        }, point?: Point2D) => boolean | void;
        set onTouchMoved(value: (e: boolean | {
            isInside: boolean;
        }, point?: Point2D) => boolean | void);
        get onTouchCancelled(): (point: Point2D) => boolean | void;
        set onTouchCancelled(value: (point: Point2D) => boolean | void);
        get errorMessage(): string;
        set errorMessage(value: string);
        get characterRestriction(): number;
        set characterRestriction(value: number);
        get characterRestrictionColor(): Color;
        set characterRestrictionColor(value: Color);
        get enableCharacterRestriction(): boolean;
        set enableCharacterRestriction(value: boolean);
    }
}
declare module "ui/textbox/textbox.ios" {
    import { ITextBox } from "ui/textbox/index";
    import ActionKeyType from "ui/shared/android/actionkeytype";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import KeyboardType from "ui/shared/keyboardtype";
    import TextAlignment from "ui/shared/textalignment";
    import ViewIOS from "ui/view/view.ios";
    import AutoCapitalize from "ui/textbox/autocapitalize";
    import { TextBoxEvents } from "ui/textbox/textbox-events";
    export default class TextBoxIOS<TEvent extends string = TextBoxEvents, TNative = {}, TProps extends ITextBox = ITextBox> extends ViewIOS<TEvent | TextBoxEvents, TNative, TProps> implements ITextBox {
        private _textAligment;
        private _hint;
        private _hintTextColor;
        private _clearButtonEnabled;
        private _keyboardLayout;
        private keyboardanimationdelegate;
        private _inputView;
        private _inputViewMain;
        private _onTextChanged;
        private _onClearButtonPress;
        private _onEditEnds;
        private _onActionButtonPress;
        constructor(params?: Partial<TProps>);
        private get iOSProps();
        get font(): Font;
        set font(value: Font);
        get text(): string;
        set text(value: string);
        get autoCapitalize(): AutoCapitalize;
        set autoCapitalize(value: AutoCapitalize);
        get textAlignment(): TextAlignment;
        set textAlignment(value: TextAlignment);
        get textColor(): Color;
        set textColor(value: Color);
        get cursorPosition(): {
            start: number;
            end: number;
        };
        set cursorPosition(value: {
            start: number;
            end: number;
        });
        onEditBegins: () => void;
        get cursorColor(): Color;
        set cursorColor(value: Color);
        get hint(): string;
        set hint(value: string);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get isPassword(): boolean;
        set isPassword(value: boolean);
        get keyboardType(): KeyboardType;
        set keyboardType(value: KeyboardType);
        get actionKeyType(): ActionKeyType;
        set actionKeyType(value: ActionKeyType);
        showKeyboard(): void;
        hideKeyboard(): void;
        requestFocus(): void;
        removeFocus(): void;
        get onTextChanged(): (e?: {
            insertedText: string;
            location: number;
        }) => void;
        set onTextChanged(value: (e?: {
            insertedText: string;
            location: number;
        }) => void);
        get onClearButtonPress(): () => void;
        set onClearButtonPress(value: () => void);
        get onEditEnds(): () => void;
        set onEditEnds(value: () => void);
        get onActionButtonPress(): (e?: {
            actionKeyType: ActionKeyType;
        }) => void;
        set onActionButtonPress(value: (e?: {
            actionKeyType: ActionKeyType;
        }) => void);
    }
}
declare module "ui/materialtextbox/materialtextbox.ios" {
    import { IMaterialTextBox } from "ui/materialtextbox/index";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import TextBoxIOS from "ui/textbox/textbox.ios";
    import View from "ui/view/index";
    import { MaterialTextBoxEvents } from "ui/materialtextbox/materialtextbox-events";
    export default class MaterialTextBoxIOS<TEvent extends string = MaterialTextBoxEvents> extends TextBoxIOS<TEvent | MaterialTextBoxEvents, any, IMaterialTextBox> implements IMaterialTextBox {
        private mdcTextInputControllerUnderline;
        private _multiline;
        private _lineCount;
        private _rightLayout;
        private _rightLayoutMain;
        private _labelsFont;
        private _errorMessage;
        private __hint;
        private __hintTextColor;
        private _onLeftViewRightPadding;
        private _onRightViewLeftPadding;
        private _leftLayout;
        private _leftLayoutMain;
        private _onLeftViewRectForBounds;
        private _onRightViewRectForBounds;
        constructor(params?: Partial<IMaterialTextBox>);
        get testId(): any;
        set testId(value: any);
        get cursorPosition(): {
            start: number;
            end: number;
        };
        set cursorPosition(value: {
            start: number;
            end: number;
        });
        get multiline(): boolean;
        get lineCount(): number;
        get isPassword(): boolean;
        set isPassword(value: boolean);
        get characterRestriction(): number | undefined;
        set characterRestriction(value: number | undefined);
        get characterRestrictionColor(): Color | null;
        set characterRestrictionColor(value: Color | null);
        get rightLayout(): {
            view: View;
            width: number;
            height?: number;
        };
        set rightLayout(value: {
            view: View;
            width: number;
            height?: number;
        });
        get labelsFont(): Font;
        set labelsFont(value: Font);
        get font(): Font;
        set font(value: Font);
        get selectedHintTextColor(): Color | null;
        set selectedHintTextColor(value: Color | null);
        get lineColor(): {
            normal: Color | null;
            selected: Color | null;
        };
        set lineColor(value: {
            normal: Color | null;
            selected: Color | null;
        });
        get errorColor(): Color | null;
        set errorColor(value: Color | null);
        get errorMessage(): string;
        set errorMessage(value: string);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get hint(): string;
        set hint(value: string);
    }
}
declare module "ui/menu/index" {
    import MenuItem from "ui/menuitem/index";
    import Page from "ui/page/index";
    /**
     * @class UI.Menu
     * @since 0.1
     * Menu is a dialog UI that presents a set of alternatives to the user for how to
     * proceed with a given task.
     *
     *
     *     @example
     *     const Menu = require('@smartface/native/ui/menu');
     *     const MenuItem = require('@smartface/native/ui/menuitem');
     *
     *     var menu = new Menu();
     *     menu.headerTitle = "My Menu Title";
     *     var menuItem1 = new MenuItem({ title: "Menu Item 1" });
     *     var menuItem2 = new MenuItem({ title: "Menu Item 2" });
     *
     *     menuItem1.ios.style = MenuItem.ios.Style.DEFAULT;
     *
     *     menuItem1.onSelected = function() {
     *         console.log("Menu item 1 selected");
     *     };
     *
     *     menuItem2.onSelected = function() {
     *         console.log("Menu item 2 selected");
     *     };
     *
     *     menu.items = [menuItem1, menuItem2];
     *     menu.show(myPage);
     */
    export class AbstractMenu {
        /**
         * Gets/sets header title of Menu
         *
         * @property {String} headerTitle
         * @android
         * @ios
         * @since 0.1
         */
        headerTitle: string;
        /**
         * Gets/sets array of UI.MenuItem of the menu.
         *
         * @property {UI.MenuItem[]} items
         * @android
         * @ios
         * @since 0.1
         */
        items: MenuItem[];
        /**
         * This function shows menu on the given UI.Page.
         *
         * @param {UI.Page} page This is the page that menu will be shown.
         * @android
         * @ios
         * @method show
         * @since 0.1
         */
        show(page: Page): void;
    }
    const Menu: typeof AbstractMenu;
    type Menu = AbstractMenu;
    export default Menu;
}
declare module "ui/menu/menu.android" {
    import Menu, { AbstractMenu } from "ui/menu/index";
    import MenuItem from "ui/menuitem/index";
    import Page from "ui/page/index";
    export default class MenuAndroid implements AbstractMenu {
        private _items;
        private _headerTitle;
        constructor(params?: Partial<Menu>);
        get items(): MenuItem[];
        set items(value: MenuItem[]);
        get headerTitle(): string;
        set headerTitle(value: string);
        show(page: Page): void;
        toString(): string;
    }
}
declare module "ui/menu/menu.ios" {
    import Menu, { AbstractMenu } from "ui/menu/index";
    import NativeComponent from "core/native-component";
    import MenuItem from "ui/menuitem/index";
    import Page from "ui/page/index";
    export default class MenuIOS extends NativeComponent implements AbstractMenu {
        private _items;
        private _headerTitle;
        constructor(params?: Partial<Menu>);
        get items(): MenuItem[];
        set items(value: MenuItem[]);
        get headerTitle(): string;
        set headerTitle(value: string);
        show(page: Page): void;
    }
}
declare module "ui/menuitem/menuitem.android" {
    import MenuItem, { AbstractMenuItem, IMenuItem, Style } from "ui/menuitem/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MenuItemEvents } from "ui/menuitem/menuitem-events";
    export default class MenuItemAndroid extends NativeEventEmitterComponent<MenuItemEvents, any, IMenuItem> implements AbstractMenuItem {
        static Events: {
            readonly Selected: "selected";
        };
        static Styles: {
            DEFAULT: Style;
            CANCEL: Style;
            DESTRUCTIVE: Style;
        };
        private _title;
        private _onSelected;
        constructor(params?: Partial<MenuItem>);
        getActionView: any;
        onSelectedListener?: (() => void) | undefined;
        get title(): string;
        set title(value: string);
        get onSelected(): () => void;
        set onSelected(callback: () => void);
        toString(): string;
    }
}
declare module "ui/menuitem/menuitem.ios" {
    import MenuItem, { AbstractMenuItem, IMenuItem, Style } from "ui/menuitem/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MenuItemEvents } from "ui/menuitem/menuitem-events";
    export default class MenuItemIOS extends NativeEventEmitterComponent<MenuItemEvents, any, IMenuItem> implements AbstractMenuItem {
        static Events: {
            readonly Selected: "selected";
        };
        static Styles: {
            DEFAULT: Style;
            CANCEL: Style;
            DESTRUCTIVE: Style;
        };
        private style;
        private _title;
        private _onSelected;
        constructor(params?: Partial<MenuItem>);
        getActionView: any;
        get title(): string;
        set title(value: string);
        get onSelected(): () => void;
        set onSelected(callback: () => void);
        toString(): string;
        onSelectedListener(): void;
    }
}
declare module "ui/navigationcontroller/navigationcontroller.android" {
    import { AbstractNavigationController, Controller, IController, INavigationController, OperationType } from "ui/navigationcontroller/index";
    import { ControllerParams } from "util/Android/transition/viewcontroller";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import Page from "ui/page/index";
    export default class NavigationControllerAndroid extends AbstractNavigationController implements INavigationController {
        static NavCount: number;
        static OperationType: typeof OperationType;
        private pageIDCollectionInStack;
        private __navID;
        isInsideBottomTabBar: boolean;
        popupBackNavigator: any;
        popUpBackPage: Page;
        constructor(params?: Partial<INavigationController>);
        pageID: number;
        isActive: boolean;
        headerBar: HeaderBar;
        get childControllers(): IController[];
        set childControllers(childControllersArray: IController[]);
        get willShow(): (opts?: {
            controller: Controller;
            animated?: boolean;
        }) => void;
        set willShow(callback: (opts?: {
            controller: Controller;
            animated?: boolean;
        }) => void);
        get onTransition(): (opts?: {
            controller: Controller;
            operation: OperationType;
        }) => void;
        set onTransition(callback: (opts?: {
            controller: Controller;
            operation: OperationType;
        }) => void);
        toString(): string;
        show(params?: ControllerParams): void;
        push(params: Parameters<INavigationController['push']>['0']): void;
        showController(params: ControllerParams): void;
        present(params: Parameters<INavigationController['present']>['0']): void;
        dismiss(params: Parameters<INavigationController['dismiss']>['0']): void;
        pop(params: Parameters<INavigationController['pop']>['0']): void;
        popTo(params: any): void;
        getCurrentController(): IController | null;
        popFromHistoryController(currentController: Controller, params: {
            animated: boolean;
        }): void;
    }
}
declare module "ui/webview/webview-events" {
    export const WebViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly BackButtonPressed: "backButtonPressed";
        readonly ChangedURL: "changedURL";
        readonly ConsoleMessage: "consoleMessage";
        readonly Error: "error";
        readonly Load: "load";
        readonly OpenNewWindow: "openNewWindow";
        readonly Show: "show";
    };
    export type WebViewEvents = ExtractValues<typeof WebViewEvents>;
}
declare module "ui/webview/index" {
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import Page from "ui/page/index";
    import File from "io/file/index";
    import ContentInsetAdjustment from "ui/shared/ios/contentinsetadjustment";
    import { Boundary } from "primitive/boundary";
    import { WebViewEvents } from "ui/webview/webview-events";
    import { IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    export type AndroidProps = ViewAndroidProps & {
        /**
         * Gets/sets over-scroll mode for this view.
         *
         * @property {UI.Android.OverScrollMode} [overScrollMode = UI.Android.OverScrollMode.ALWAYS]
         * @android
         * @since 3.2.1
         */
        overScrollMode: OverScrollMode;
        /**
         * Sets/Gets the current page which contains the webview.
         *
         * @property {UI.Page} page
         * @android
         * @since 2.0.10
         */
        page: Page;
        /**
         * Sets/Gets the visibility of zoom controls.
         *
         * @property {Boolean} displayZoomControls
         * @android
         * @since 4.3.4
         */
        displayZoomControls: boolean;
        /**
         * This event will be triggered when user clicks back button on the Device. WebView is focusable view. When it gains focus, this
         * event begin to trigger. The purpose of using this event might be
         * navigating back to pervious web pages.
         *
         * @event onBackButtonPressed
         * @deprecated
         * @android
         * @since 3.2.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.BackButtonPressed, () => {
         * 	console.info('onBackButtonPressed');
         * });
         * ````
         */
        onBackButtonPressed?: () => void;
        /**
         * Report a JavaScript console message to the host application.
         *
         * @event onConsoleMessage
         * @deprecated
         * @param {Object} params
         * @param {Number} params.sourceId     The name of the source file that caused the error.
         * @param {String} params.message      The error message to report.
         * @param {String} params.lineNumber   The line number of the error.
         * @param {String} params.messageLevel The message level of the report
         * @android
         * @since 4.0.4
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.ConsoleMessage, (params) => {
         * 	console.info('onConsoleMessage', params);
         * });
         * ````
         */
        onConsoleMessage?: (params: {
            sourceId: number;
            message: string;
            lineNumber: number;
            messageLevel: string;
        }) => boolean;
        /**
         * Removes the autocomplete popup from the currently focused form field, if present.
         *
         * @method clearFormData
         * @android
         * @since 2.0.7
         */
        clearFormData(): void;
        /**
         * Tells this WebView to clear its internal back/forward list.
         *
         * @method clearHistory
         * @android
         * @since 2.0.7
         */
        clearHistory(): void;
        /**
         * Enables debugging of WebView contents.
         *
         * @method setWebContentsDebuggingEnabled
         * @android
         * @param {Boolean} [enabled=false]
         * @static
         * @since 4.0.6
         */
        setWebContentsDebuggingEnabled(enabled: boolean): void;
    };
    export type iOSProps = ViewIOSProps & {
        /**
         * Sets/Gets the bounce effect when scrolling.
         *
         * @property {Boolean} bounces
         * @ios
         * @since 3.2.1
         */
        bounces: boolean;
        /**
         * This event is triggered more than once to get safeAreaInsets.
         *
         * @event safeAreaInsets
         * @param {Object} systemSafeAreaInsets
         * @param {Number} systemSafeAreaInsets.top
         * @param {Number} systemSafeAreaInsets.bottom
         * @param {Number} systemSafeAreaInsets.right
         * @param {Number} systemSafeAreaInsets.left
         * @return {Object} safeAreaInsets
         * @return {Number} return.top
         * @return {Number} return.bottom
         * @return {Number} return.right
         * @return {Number} return.left
         * @ios
         * @since 3.2.1
         */
        safeAreaInsets?: (e: Boundary) => Boundary;
        /**
         * The behavior for determining the adjusted content offsets.
         *
         * @property {UI.iOS.ContentInsetAdjustment} [contentInsetAdjustmentBehavior = UI.iOS.ContentInsetAdjustment.NEVER]
         * @ios
         * @since 4.0.0
         */
        contentInsetAdjustmentBehavior: ContentInsetAdjustment;
        onOpenNewWindow: (e?: {
            url: string;
        }) => void;
        /**
         * Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.
         * By validating both the certificate chain and host, certificate pinning provides a very secure form of server trust validation mitigating most, if not all, MITM attacks.
         * Applications are encouraged to always validate the host and require a valid certificate chain in production environments.
         *
         * @property {Array}    sslPinning.certificates Only DER format accepted.
         * @ios
         * @since 4.3.4
         */
        sslPinning: {
            host: string;
            certificates: any[];
            validateCertificateChain: boolean;
            validateHost: boolean;
        }[];
    };
    /**
     * @class UI.WebView
     * @since 0.1
     * @extends UI.View
     *
     * WebView shows web pages and displays custom html code.
     * It also holds some of the common functionalities of browsers like refresh, go back and etc.
     *
     *     @example
     *     const WebView = require('@smartface/native/ui/webview');
     *     const Flex = require('@smartface/native/ui/flexlayout')
     *
     *     var myWebView = new WebView({
     *         left:10, top:10, right:10, bottom:10,
     *         positionType: Flex.PositionType.ABSOLUTE,
     *         onChangedURL: function(event) {
     *             console.log("Event Change URL: " + event.url);
     *         },
     *         onError: function(event) {
     *             console.log("Event Error : " + event.message + ", URL: " + event.url);
     *         },
     *         onLoad: function(event) {
     *             console.log("Event Load: " + event.url);
     *         },
     *         onShow: function(event) {
     *             console.log("Event Show: " + event.url);
     *         }
     *     });
     *     page.layout.addChild(myWebView);
     *     myWebView.loadURL('https://www.google.com');
     *
     */
    export interface IWebView<TEvent extends string = WebViewEvents, TMobile extends MobileOSProps<iOSProps, AndroidProps> = MobileOSProps<iOSProps, AndroidProps>> extends IView<TEvent | WebViewEvents, any, TMobile> {
        /**
         * Indicates whether the links clicked on the webview will be rendered inside the webview or not.
         * Otherwise, the default browser of the device will handle that link.
         *
         * @property {Boolean} openLinkInside
         * @android
         * @ios
         * @since 0.1
         */
        openLinkInside: boolean;
        /**
         * If this property is false then scrolling ability is no longer exist.
         *
         * @property {Boolean} scrollEnabled
         * @android
         * @ios
         * @since 1.1.16
         */
        scrollEnabled: boolean;
        /**
         * Sets/Gets the userAgent. On Android, if the string is null or empty,
         * the system default value will be used. Changing the user-agent while
         * loading a web page causes WebView to initiate loading once again.
         * On iOS, default of userAgent property is empty string.
         *
         * @property {String} userAgent
         * @android
         * @ios
         * @since 4.1.1
         */
        userAgent: string;
        /**
         * Sets/Gets the visibility of scrollbar.
         *
         * @property {Boolean} scrollBarEnabled
         * @android
         * @ios
         * @since 1.1.12
         */
        scrollBarEnabled: boolean;
        /**
         * Sets/Gets the bounce effect when scrolling.
         *
         * @property {Boolean} bounceEnabled
         * @deprecated 3.2.1 Use {@link UI.WebView#bounces} for iOS or Use {@link UI.WebView#overScrollMode} for Android.
         * @android
         * @ios
         * @since 1.1.12
         */
        bounceEnabled: boolean;
        /**
         * Reloads the current page.
         *
         * @method refresh
         * @android
         * @ios
         * @since 0.1
         */
        refresh(): void;
        /**
         * Goes back to the previous web page.
         *
         * @method goBack
         * @android
         * @ios
         * @since 0.1
         */
        goBack(): void;
        /**
         * Goes back to the next web page if there is any.
         *
         * @method goForward
         * @android
         * @ios
         * @since 0.1
         */
        goForward(): void;
        /**
         * Enables zoom on the web page with gestures.
         *
         * @property {Boolean} zoomEnabled
         * @android
         * @ios
         * @since 0.1
         */
        zoomEnabled: boolean;
        /**
         * Loads the web page provided via the url.
         *
         * @method loadURL
         * @param {String} url
         * @android
         * @ios
         * @since 0.1
         */
        loadURL(url: string): void;
        /**
         * Loads the web page provided via html code.
         *
         * @method loadHTML
         * @param {String} htmlText
         * @android
         * @ios
         * @since 0.1
         */
        loadHTML(html: string): void;
        /**
         * Loads the web page provided via {@link IO.File}. You can load complete web page with
         * this method by passing index.html as a file.
         *
         * @method loadFile
         * @param {IO.File} file
         * @android
         * @ios
         * @since 1.1.16
         */
        loadFile(file: File): void;
        /**
         * Runs a javascript code. Return value must be inside a function.
         *
         *     @example
         *     const WebView = require('@smartface/native/ui/webview');
         *     const Flex = require('@smartface/native/ui/flexlayout');
         *
         *     var myScript = `
         *         function doSomething() {
         *             return "value";
         *         }
         *         doSomething();
         *     `;
         *
         *     var myWebView = new WebView({
         *         left:10, top:10, right:10, bottom:10,
         *         positionType: Flex.PositionType.ABSOLUTE
         *         onShow: function(event) {
         *             myWebView.evaluateJS(myScript, function(value) {
         *                 console.log("Result " + value);
         *             });
         *         }
         *     });
         *     page.layout.addChild(myWebView);
         *     myWebView.loadURL('https://www.google.com');
         *
         * @method evaluateJS
         * @param {String} javascript
         * @param {Function} onReceive
         * @param {String} onReceive.value
         * @android
         * @ios
         * @since 0.1
         */
        evaluateJS(javascript: string, onReceive: (value: string) => void): void;
        /**
         * Callback triggered when the url is changed. If it returns false, cannot navigate to the url.
         *
         * @event onChangedURL
         * @param {Object} event
         * @param {String} event.url
         * @return {Boolean}
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.ChangedURL, (params) => {
         * 	console.info('onChangedURL', params);
         * });
         * ````
         */
        onChangedURL?: (e: {
            url: string;
        }) => boolean;
        /**
         * Callback triggered when the web page has started loading. In Android, This method is called once for each main frame load so a page with iframes or
         * framesets will call onLoad one time for the main frame.
         *
         * @event onLoad
         * @param {Object} event
         * @param {String} event.url
         * @android
         * @deprecated
         * @ios
         * @since 0.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.Load, (params) => {
         * 	console.info('onLoad', params);
         * });
         * ````
         */
        onLoad?: (e: {
            url: string;
        }) => void;
        /**
         * Callback triggered when the target equals to _blank. That means open new window.
         *
         *     @example
         *     myWebView.ios.onOpenNewWindow = function(event) {
         *         myWebView.loadURL(event.url);
         *     };
         *
         * @event onOpenNewWindow
         * @deprecated
         * @param {Object} event
         * @param {String} event.url
         * @ios
         * @since 4.0.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.OpenNewWindow, (params) => {
         * 	console.info('onOpenNewWindow', params);
         * });
         * ````
         */
        onOpenNewWindow?: (e: {
            url: string;
        }) => void;
        /**
         * Callback triggered when an error occured while loading a web page.
         *
         * @event onError
         * @deprecated
         * @param {Object} event
         * @param {String} event.url
         * @param {Number} event.code
         * @param {String} event.message
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.Error, (params) => {
         * 	console.info('onError', params);
         * });
         * ````
         */
        onError?: (e: {
            url: string;
            code: number;
            message: string;
        }) => void;
        /**
         * Callback triggered when a web page has finished loading. In Android, this method is called only for main frame. Receiving an onShow callback
         * does not guarantee that the next frame drawn by WebView will reflect the state of the DOM at this point.
         *
         * @event onShow
         * @deprecated
         * @param {Object} event
         * @param {String} event.url
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import WebView from '@smartface/native/ui/webview';
         *
         * const webView = new WebView();
         * webView.on(WebView.Events.Show, (params) => {
         * 	console.info('onShow', params);
         * });
         * ````
         */
        onShow?: (e: {
            url: string;
        }) => void;
        /**
         * Clears the resource cache.
         *
         * @method clearCache
         * @param {Boolean} deleteDiskFiles
         * @android
         * @ios
         * @since 2.0.7
         */
        clearCache(deleteDiskFiles: boolean): void;
        /**
         * Tells this WebView to clear its Cookie.
         *
         * @method clearCookie
         * @android
         * @ios
         * @since 2.0.7
         */
        clearCookie(): void;
        /**
         * This method clear all data from webview.
         *
         * @method clearAllData
         * @android
         * @ios
         * @since 2.0.7
         */
        clearAllData(): void;
    }
    const WebView: ConstructorOf<IWebView, Partial<IWebView>>;
    type WebView = IWebView;
    export default WebView;
}
declare module "ui/webview/webview.android" {
    import { ViewAndroid } from "ui/view/view.android";
    import File from "io/file/index";
    import { WebViewEvents } from "ui/webview/webview-events";
    import WebView from "ui/webview/index";
    import IWebView from "ui/webview/index";
    export default class WebViewAndroid<TEvent extends string = WebViewEvents> extends ViewAndroid<TEvent | WebViewEvents, any, IWebView> implements IWebView {
        private _canOpenLinkInside;
        private _onError;
        private _onShow;
        private _onLoad;
        private _onChangedURL;
        private _onConsoleMessage;
        private _scrollBarEnabled;
        private _scrollEnabled;
        private _superTouchCallbacks;
        private webViewClientCallbacks;
        private webChromeClientCallbacks;
        private _onBackButtonPressedCallback;
        private _page;
        private static REQUEST_CODE_LOLIPOP;
        private static RESULT_CODE_ICE_CREAM;
        static onActivityResult: (requestCode: any, resultCode: any, data: any) => void;
        constructor(params?: Partial<WebView>);
        onOpenNewWindow?: (e: {
            url: string;
        }) => void;
        get scrollBarEnabled(): boolean;
        set scrollBarEnabled(value: boolean);
        get userAgent(): any;
        set userAgent(value: any);
        get bounceEnabled(): boolean;
        set bounceEnabled(value: boolean);
        get openLinkInside(): boolean;
        set openLinkInside(enabled: boolean);
        get zoomEnabled(): any;
        set zoomEnabled(enabled: any);
        get scrollEnabled(): boolean;
        set scrollEnabled(enabled: boolean);
        get onChangedURL(): ((e: {
            url: string;
        }) => boolean) | undefined;
        set onChangedURL(callback: ((e: {
            url: string;
        }) => boolean) | undefined);
        get onLoad(): ((e: {
            url: string;
        }) => void) | undefined;
        set onLoad(callback: ((e: {
            url: string;
        }) => void) | undefined);
        get onError(): ((e: {
            url: string;
            code: number;
            message: string;
        }) => void) | undefined;
        set onError(callback: ((e: {
            url: string;
            code: number;
            message: string;
        }) => void) | undefined);
        get onShow(): ((e: {
            url: string;
        }) => void) | undefined;
        set onShow(callback: ((e: {
            url: string;
        }) => void) | undefined);
        refresh(): void;
        goBack(): void;
        goForward(): void;
        loadURL(url: string): void;
        loadHTML(htmlText: string): void;
        loadFile(file: File): void;
        evaluateJS(javascript: any, callback: any): void;
        toString(): string;
        clearCache(deleteDiskFiles: any): void;
        clearAllData(): void;
        clearCookie(): void;
        private overrideURLChange;
        private createImageFile;
        private getAndroidParams;
        private setWebViewClientCallbacks;
        private setWebChromeClientCallbacks;
    }
}
declare module "ui/page/page.android" {
    import { AbstractPage, IPage, LargeTitleDisplayMode, Orientation, PageOrientation, PresentationStyle } from "ui/page/index";
    import { PageEvents } from "ui/page/page-events";
    import { StatusBar } from "application/statusbar/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import { IController } from "ui/navigationcontroller/index";
    export default class PageAndroid<TEvent extends string = PageEvents, TNative = __SF_UIViewController, TProps extends IPage = IPage> extends AbstractPage<TEvent | PageEvents, TNative, TProps> {
        getCurrentController(): IController;
        show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean | undefined;
            onCompleteCallback?: (() => void) | undefined;
        }): void;
        static iOS: {
            LargeTitleDisplayMode: typeof LargeTitleDisplayMode;
            PresentationStyle: typeof PresentationStyle;
        };
        static Orientation: typeof Orientation;
        headerBar: HeaderBar;
        private _isShown;
        private _transitionViews;
        private pageLayoutContainer;
        private toolbar;
        private isCreated;
        private optionsMenu;
        private actionBar;
        isSwipeViewPage: boolean;
        private _orientation;
        private rootLayout;
        private _headerBarItems;
        private popUpBackPage;
        private returnRevealAnimation;
        private _headerBarColor;
        private _headerBarImage;
        private _titleLayout?;
        private _onBackButtonPressed;
        private _transitionViewsCallback;
        private _borderVisibility;
        private _transparent;
        private _alpha;
        private _headerBarTitleColor;
        private _leftItemEnabled;
        private _leftItemColor;
        private _itemColor;
        private _headerBarLogo;
        private _headerBarElevation;
        private _headerBarSubtitleColor;
        private pageLayout;
        private _attributedTitle;
        private _attributedSubtitle;
        private _attributedTitleBuilder;
        private _attributedSubtitleBuilder;
        private _headerBarLogoEnabled;
        private _tag;
        private _headerBarLeftItem;
        /**TProps
         * This is a workaround solution for swipeView-Android. The source is:
         * _pageInstances[intPosition].__onShowCallback?.();
         */
        __onShowCallback: IPage['onShow'];
        onLoad: () => void;
        onHide: () => void;
        onShow: () => void;
        onOrientationChange: (e: {
            orientation: PageOrientation[];
        }) => void;
        constructor(params?: Partial<TProps>);
        statusBar: StatusBar;
        parentController: IPage['parentController'];
        get orientation(): PageOrientation;
        set orientation(value: PageOrientation);
        get layout(): IPage['layout'];
        get isShown(): boolean;
        set isShown(value: boolean);
        get transitionViews(): IPage['transitionViews'];
        set transitionViews(value: IPage['transitionViews']);
        present(params: Parameters<IPage['present']>['0']): void;
        dismiss(params: Parameters<IPage['dismiss']>['0']): void;
        private setCallbacks;
        private setHeaderBarDefaults;
        private nativeSpecificParams;
        /**
         * TODO: Consider moving this whole headerbar to its own class
         */
        private headerBarParams;
        private layoutAssignments;
    }
}
declare module "ui/page/page.ios" {
    import { AbstractPage, IPage, LargeTitleDisplayMode, Orientation, PageOrientation, PresentationStyle } from "ui/page/index";
    import FlexLayout from "ui/flexlayout/index";
    import { IController } from "ui/navigationcontroller/index";
    import { HeaderBar } from "ui/navigationcontroller/headerbar";
    import { PageEvents } from "ui/page/page-events";
    export default class PageIOS<TEvent extends string = PageEvents, TNative extends {
        [key: string]: any;
    } = __SF_UIViewController, TProps extends IPage = IPage> extends AbstractPage<TEvent | PageEvents, TNative, TProps> implements IPage<TEvent | PageEvents> {
        layout: FlexLayout;
        headerBar?: HeaderBar | undefined;
        getCurrentController(): IController;
        show(params: {
            controller: IController;
            animated: any;
            isComingFromPresent?: boolean | undefined;
            onCompleteCallback?: (() => void) | undefined;
        }): void;
        static iOS: {
            LargeTitleDisplayMode: typeof LargeTitleDisplayMode;
            PresentationStyle: typeof PresentationStyle;
        };
        static Orientation: typeof Orientation;
        private routerPath;
        private pageView;
        private _safeAreaLayoutMode;
        private _safeAreaPaddingObject;
        private _transitionViews;
        private _titleView;
        private _presentationStyle;
        private _largeTitleDisplayMode;
        private _leftItem;
        private _orientationNative;
        constructor(params?: Partial<TProps>);
        onLoad: () => void;
        onShow: () => void;
        onHide: () => void;
        onOrientationChange: (e: {
            orientation: PageOrientation[];
        }) => void;
        orientation: IPage['orientation'];
        parentController: IPage['parentController'];
        statusBar: IPage['statusBar'];
        get transitionViews(): IPage['transitionViews'];
        set transitionViews(value: IPage['transitionViews']);
        present(params?: Parameters<IPage['present']>['0']): void;
        dismiss(params?: Parameters<IPage['dismiss']>['0']): void;
        private checkOrientation;
        private calculateSafeAreaPaddings;
        private calculatePosition;
        private getParentViewController;
        private setNativeParams;
        private initPageNativeEvents;
        private initPageEvents;
        private checkIfSearchviewIsSubview;
        /**
         * TODO: Kind of messy code but couldn't find a better way.
         * It basically re-uses everything this.headerBar has in this.ios.navigationItem
         * Also iOS only properties are unified in this one.
         */
        private headerBarProperties;
    }
}
declare module "ui/picker/picker-events" {
    export const PickerEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled"; /**
         * This event is called when scroll ends & an item is selected on a picker.
         *
         * @param {Number} index
         * @event onSelected
         * @android
         * @ios
         * @since 0.1
         */
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        /**
         * This event is called when scroll ends & an item is selected on a picker.
         *
         * @param {Number} index
         * @event onSelected
         * @android
         * @ios
         * @since 0.1
         */
        readonly Selected: "selected";
    };
    export type PickerEvents = ExtractValues<typeof PickerEvents>;
}
declare module "ui/picker/index" {
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { IView, IViewState } from "ui/view/index";
    import { PickerEvents } from "ui/picker/picker-events";
    export interface PickerAndroidProperties {
        /**
         * Enables/disables the Picker.
         *
         * @since 1.1.8
         * @property {Boolean} [enabled = true]
         * @android
         */
        enabled?: boolean;
    }
    export interface PickerIOSProperties {
        /**
         * Gets/sets cancelHighlightedColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} cancelHighlightedColor
         * @ios
         * @since 3.1.1
         */
        cancelHighlightedColor?: Color;
        /**
         * Gets/sets okHighlightedColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} okHighlightedColor
         * @ios
         * @since 3.1.1
         */
        okHighlightedColor?: Color;
        /**
         * Gets/sets dialogLineColor of Picker.
         *
         * @property {UI.Color} dialogLineColor
         * @ios
         * @since 4.2.3
         */
        dialogLineColor?: Color;
        rowHeight?: number;
    }
    /**
     * @class UI.Picker
     * @since 0.1
     *
     * Picker is a UIView that allows you to create a list which you can pick only one of them.
     * You can add Picker as a View to your layout. If you want to show Picker as a dialog,
     * you can call UI.Picker.show method.
     *
     *     @example
     *     import Picker from "@smartface/native/ui/picker";
     *     const items = [
     *         "item 1",
     *         "item 2",
     *         "item 3",
     *         "item 4",
     *         "item 5"
     *     ];
     *     const myPicker = new Picker({
     *         items: items,
     *         currentIndex: 2
     *     });
     *
     *     const okCallback = function(params) {
     *         console.log('Selected index: ' + params.index);
     *     }
     *     const cancelCallback = function() {
     *         console.log('Canceled');
     *     }
     *     myPicker.show(okCallback,cancelCallback);
     */
    export interface IPicker<TEvent extends string = PickerEvents, TMobile extends MobileOSProps<IView['ios'] & PickerIOSProperties, IView['android'] & PickerAndroidProperties> = MobileOSProps<IView['ios'] & PickerIOSProperties, IView['android'] & PickerAndroidProperties>> extends IView<TEvent | PickerEvents, any, TMobile> {
        /**
         * Gets/sets items of the picker.
         *
         * @property {Array|String} items
         * @android
         * @ios
         * @since 0.1
         */
        items: string[];
        /**
         * Gets/sets current index of the picker.
         *
         * @property {Number} currentIndex
         * @android
         * @ios
         * @since 0.1
         */
        currentIndex: number;
        /**
         * Gets/sets textColor of Picker.
         *
         * @property {UI.Color} textColor
         * @android
         * @ios
         * @since 4.2.3
         */
        textColor?: Color;
        /**
         * Gets/sets dialogBackgroundColor of Picker.
         *
         * @property {UI.Color} dialogBackgroundColor
         * @android
         * @ios
         * @since 4.2.3
         */
        dialogBackgroundColor: Color | IViewState<Color>;
        /**
         * This event is called when scroll ends & an item is selected on a picker.
         *
         * @param {Number} index
         * @event onSelected
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import Picker from '@smartface/native/ui/picker';
         *
         * const picker = new Picker();
         * picker.on(Picker.Events.Selected, (params) => {
         *  console.info('onSelected', params);
         * });
         * ````
         */
        onSelected: (index: number) => void;
        /**
         * This function shows picker in a dialog.
         *
         * @param {Function} ok This event is called when user clicks ok button.
         * @param {Object} ok.param
         * @param {Number} ok.param.index
         * @param {Function} cancel This event is called when user clicks cancel button.
         * @method show
         * @android
         * @ios
         * @since 0.1
         */
        show(ok?: (param?: {
            index: number;
        }) => void, cancel?: () => void): void;
        /**
         * Gets/sets title of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} title
         * @android
         * @ios
         * @since 3.1.1
         */
        title: string;
        /**
         * Gets/sets titleColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} titleColor
         * @android
         * @ios
         * @since 3.1.1
         */
        titleColor: Color;
        /**
         * Gets/sets titleFont of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} titleFont
         * @android
         * @ios
         * @since 3.1.1
         */
        titleFont: Font;
        /**
         * Gets/sets cancelColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} cancelColor
         * @android
         * @ios
         * @since 3.1.1
         */
        cancelColor: Color;
        /**
         * Gets/sets cancelFont of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} cancelFont
         * @android
         * @ios
         * @since 3.1.1
         */
        cancelFont: Font;
        /**
         * Gets/sets cancelText of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} cancelText
         * @android
         * @ios
         * @since 3.1.3
         */
        cancelText: string;
        /**
         * Gets/sets okColor of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} okColor
         * @android
         * @ios
         * @since 3.1.1
         */
        okColor: Color;
        /**
         * Gets/sets okText of the picker. This property only works with show method. Must set before show method.
         *
         * @property {String} okText
         * @android
         * @ios
         * @since 3.1.3
         */
        okText: string;
        /**
         * Gets/sets okFont of the picker. This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} okFont
         * @android
         * @ios
         * @since 3.1.1
         */
        okFont: Font;
    }
    const Picker: ConstructorOf<IPicker, Partial<IPicker>>;
    type Picker = IPicker;
    export default Picker;
}
declare module "ui/picker/picker.android" {
    import { IPicker } from "ui/picker/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { PickerEvents } from "ui/picker/picker-events";
    export default class PickerAndroid<TEvent extends PickerEvents> extends ViewAndroid<TEvent | PickerEvents> implements IPicker<TEvent | PickerEvents> {
        protected _items: IPicker['items'];
        protected _onSelected: IPicker['onSelected'];
        protected _okColor: IPicker['okColor'];
        protected _cancelColor: IPicker['cancelColor'];
        protected _okFont: IPicker['okFont'];
        protected _cancelFont: IPicker['cancelFont'];
        protected _okText: IPicker['okText'];
        protected _cancelText: IPicker['cancelText'];
        protected _textColor: IPicker['textColor'];
        protected _titleFont: IPicker['titleFont'];
        protected _titleColor: IPicker['titleColor'];
        protected _title: IPicker['title'];
        private buttonCustomize;
        protected dialogInstance: any;
        constructor(params?: Partial<IPicker>);
        get items(): IPicker['items'];
        set items(value: IPicker['items']);
        get currentIndex(): IPicker['currentIndex'];
        set currentIndex(value: IPicker['currentIndex']);
        get onSelected(): IPicker['onSelected'];
        set onSelected(value: IPicker['onSelected']);
        get okColor(): IPicker['okColor'];
        set okColor(value: IPicker['okColor']);
        get textColor(): IPicker['textColor'];
        set textColor(value: IPicker['textColor']);
        get dialogBackgroundColor(): IPicker['dialogBackgroundColor'];
        set dialogBackgroundColor(value: IPicker['dialogBackgroundColor']);
        get cancelColor(): IPicker['cancelColor'];
        set cancelColor(value: IPicker['cancelColor']);
        get cancelText(): IPicker['cancelText'];
        set cancelText(value: IPicker['cancelText']);
        get okText(): IPicker['okText'];
        set okText(value: IPicker['okText']);
        get okFont(): IPicker['okFont'];
        set okFont(value: IPicker['okFont']);
        get cancelFont(): IPicker['cancelFont'];
        set cancelFont(value: IPicker['cancelFont']);
        get titleFont(): IPicker['titleFont'];
        set titleFont(value: IPicker['titleFont']);
        get title(): IPicker['title'];
        set title(value: IPicker['title']);
        get titleColor(): IPicker['titleColor'];
        set titleColor(value: IPicker['titleColor']);
        show(ok?: (param?: {
            index: number;
        }) => void, cancel?: () => void): void;
        toString(): string;
        private androidProperties;
        private __createTitleView;
        private setOnSelectedEvent;
        private setNumberPicker;
        private addViewToLayout;
    }
}
declare module "ui/picker/picker.ios" {
    import { IPicker, PickerIOSProperties } from "ui/picker/index";
    import ViewIOS from "ui/view/view.ios";
    import { PickerEvents } from "ui/picker/picker-events";
    export default class PickerIOS<TEvent extends PickerEvents> extends ViewIOS<TEvent | PickerEvents, PickerIOSProperties> implements IPicker<TEvent | PickerEvents> {
        protected _items: IPicker['items'];
        protected _onSelected: IPicker['onSelected'];
        protected _okColor: IPicker['okColor'];
        protected _cancelColor: IPicker['cancelColor'];
        protected _okFont: IPicker['okFont'];
        protected _cancelFont: IPicker['cancelFont'];
        protected _okText: IPicker['okText'];
        protected _cancelText: IPicker['cancelText'];
        protected _textColor: IPicker['textColor'];
        protected _titleFont: IPicker['titleFont'];
        protected _titleColor: IPicker['titleColor'];
        protected _title: IPicker['title'];
        protected _currentIndex: IPicker['currentIndex'];
        protected _onSelectedCallback: IPicker['onSelected'];
        private pickerDelegate;
        private pickerDataSource;
        private _cancelHighlightedColor?;
        private _okHighlightedColor?;
        get nativeObject(): __SF_UIPickerView;
        constructor(params?: Partial<IPicker>);
        show(ok?: (param?: {
            index: number;
        }) => void, cancel?: () => void): void;
        get items(): IPicker['items'];
        set items(value: IPicker['items']);
        get currentIndex(): IPicker['currentIndex'];
        set currentIndex(value: IPicker['currentIndex']);
        get onSelected(): IPicker['onSelected'];
        set onSelected(value: IPicker['onSelected']);
        get okColor(): IPicker['okColor'];
        set okColor(value: IPicker['okColor']);
        get textColor(): IPicker['textColor'];
        set textColor(value: IPicker['textColor']);
        get dialogBackgroundColor(): IPicker['dialogBackgroundColor'];
        set dialogBackgroundColor(value: IPicker['dialogBackgroundColor']);
        get cancelColor(): IPicker['cancelColor'];
        set cancelColor(value: IPicker['cancelColor']);
        get cancelText(): IPicker['cancelText'];
        set cancelText(value: IPicker['cancelText']);
        get okText(): IPicker['okText'];
        set okText(value: IPicker['okText']);
        get okFont(): IPicker['okFont'];
        set okFont(value: IPicker['okFont']);
        get cancelFont(): IPicker['cancelFont'];
        set cancelFont(value: IPicker['cancelFont']);
        get titleFont(): IPicker['titleFont'];
        set titleFont(value: IPicker['titleFont']);
        get title(): IPicker['title'];
        set title(value: IPicker['title']);
        get titleColor(): IPicker['titleColor'];
        set titleColor(value: IPicker['titleColor']);
        private setIOSProperties;
    }
}
declare module "ui/quicklook/index" {
    import { StatusBar } from "application/statusbar/index";
    import { INativeComponent } from "core/inative-component";
    import Color from "ui/color/index";
    import Page from "ui/page/index";
    export interface IQuickLook extends INativeComponent {
        /**
         * Gets/sets array of documents(paths) that will be shown on QuickLook.
         *     @example
         *     import QuickLook from '@smartface/native/ui/quicklook';
         *     const quicklook = new QuickLook();
         *     quicklook.document = ["images://.png","assests://.pdf"];
         * @ios
         * @since 0.1
         */
        document: string[];
        /**
         * Gets/sets headerBar color of QuickLook View.
         *     @example
         *     import QuickLook from '@smartface/native/ui/quicklook';
         *     const quicklook = new QuickLook();
         *     quicklook.barColor = UI.Color.BLACK;
         * @deprecated
         * @removed
         * @ios
         * @since 0.1
         */
        barColor: boolean;
        /**
         * Gets/sets title color of QuickLook View.
         *     @example
         *     import QuickLook from '@smartface/native/ui/quicklook';
         *     const quicklook = new QuickLook();
         *     quicklook.titleColor = UI.Color.GREEN;
         * @ios
         * @since 3.1.3
         */
        titleColor: Color;
        /**
         * Gets/sets color of items on header & footer of QuickLook view.
         *
         *     @example
         *     import QuickLook from '@smartface/native/ui/quicklook';
         *     const quicklook = new QuickLook();
         *     quicklook.itemColor = UI.Color.BLACK;
         *
         * @property {UI.Color} itemColor
         * @ios
         * @since 0.1
         */
        itemColor: Color | null;
        /**
         * Gets status bar object. This property is readonly, you can not set
         * status bar to a page but you can change properties of page's status bar.
         *
         * @property {UI.StatusBar} statusBar
         * @removed 4.0.0 Use {@link Application.statusBar} instead
         * @ios
         * @readonly
         * @since 0.1
         */
        statusBar: StatusBar | null;
        /**
         * This function shows QuickLook on the given UI.Page.
         * @ios
         * @method show
         * @since 0.1
         */
        show(page: Page): void;
    }
    export class QuickLookBase implements IQuickLook {
        constructor(params?: Partial<IQuickLook>);
        document: string[];
        barColor: boolean;
        titleColor: Color;
        itemColor: Color | null;
        statusBar: StatusBar | null;
        show(page: Page): void;
        nativeObject: any;
    }
    /**
     *
     * Quick Look lets people preview Keynote, Numbers, Pages, and PDF documents,
     * as well as images and other types of files, even if your app doesn't support those file formats.
     * For further information: https://developer.apple.com/ios/human-interface-guidelines/features/quick-look/
     * This class works only for IOS.
     *
     *     @example
     *     import QuickLook from '@smartface/native/ui/quicklook';
     *     const quickLook = new QuickLook();
     *     const testPDF = "assets://test.pdf";
     *     const testImage = "images://test.png";
     *     quickLook.document = [testPDF,testImage];
     *     quickLook.itemColor = Color.WHITE;
     *     quickLook.show(myPage);
     *
     * @since 0.1
     */
    const QuickLook: typeof QuickLookBase;
    type QuickLook = QuickLookBase;
    export default QuickLook;
}
declare module "ui/quicklook/quicklook.android" {
    import { IQuickLook } from "ui/quicklook/index";
    import { StatusBar } from "application/statusbar/index";
    import NativeComponent from "core/native-component";
    import Color from "ui/color/index";
    import Page from "ui/page/index";
    export default class QuickLookAndroid extends NativeComponent implements IQuickLook {
        document: string[];
        barColor: boolean;
        titleColor: Color;
        itemColor: Color | null;
        statusBar: StatusBar | null;
        constructor(params?: Partial<IQuickLook>);
        toString(): string;
        show(page: Page): void;
    }
}
declare module "ui/quicklook/quicklook.ios" {
    import Color from "ui/color/index";
    import { IQuickLook } from "ui/quicklook/index";
    import Page from "ui/page/index";
    import NativeComponent from "core/native-component";
    import { StatusBar } from "application/statusbar/index";
    export default class QuickLookIOS extends NativeComponent implements IQuickLook {
        private _document;
        barColor: boolean;
        statusBar: StatusBar | null;
        constructor(params?: Partial<IQuickLook>);
        get document(): string[];
        set document(value: string[]);
        get titleColor(): Color;
        set titleColor(value: Color);
        get itemColor(): Color;
        set itemColor(value: Color);
        show(page: Page): void;
    }
}
declare module "ui/rangeslider/rangeslider-events" {
    export const RangeSliderEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        readonly ValueChange: "valueChange";
    };
    export type RangeSliderEvents = ExtractValues<typeof RangeSliderEvents>;
}
declare module "ui/rangeslider/index" {
    import View, { AbstractView, IView } from "ui/view/index";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import { Point2D } from "primitive/point2d";
    import { RangeSliderEvents } from "ui/rangeslider/rangeslider-events";
    import { MobileOSProps } from "core/native-mobile-component";
    export type RangeSliderIOSProps = View['ios'] & Partial<{
        thumbShadowColor: Color;
        thumbShadowOpacity: number;
        thumbShadowRadius: number;
        thumbShadowOffset: Point2D;
        showsThumbImageShadow?: boolean;
        applyThumbViewChanges: () => void;
    }>;
    export type RangeSliderAndroidProps = View['android'] & Partial<{
        thumbSize: number;
        thumbColor: Color;
        thumbBorderColor: Color;
        thumbBorderWidth: number;
    }>;
    export interface IRangeSlider<TEvent extends string = RangeSliderEvents, TProps extends MobileOSProps<RangeSliderIOSProps, RangeSliderAndroidProps> = MobileOSProps<RangeSliderIOSProps, RangeSliderAndroidProps>> extends IView<TEvent | RangeSliderEvents, any, TProps> {
        trackColor?: Color;
        outerTrackColor?: Color;
        outerTrackWeight?: number;
        trackWeight?: number;
        rangeEnabled?: boolean;
        value?: number[];
        snapStepSize?: number;
        minValue?: number;
        maxValue?: number;
        thumbImage?: Image;
        isHapticSnap?: boolean;
        isTrackRounded?: boolean;
        /**
         * @deprecated
         * @example
         * ````
         * import RangeSlider from '@smartface/native/ui/rangeslider';
         *
         * const rangeSlider = new RangeSlider();
         * rangeSlider.on(RangeSlider.Events.ValueChange, params => {
         *  console.info('onValueChange', params);
         * });
         * ````
         */
        onValueChange?: (value: number[]) => void;
    }
    export class AbstractRangeSlider<TEvent extends string = RangeSliderEvents> extends AbstractView<TEvent | RangeSliderEvents, any, IRangeSlider> implements IRangeSlider<TEvent> {
        constructor(props?: Partial<RangeSliderEvents>);
        trackColor?: Color;
        outerTrackColor?: Color;
        outerTrackWeight?: number;
        trackWeight?: number;
        rangeEnabled?: boolean;
        value?: number[];
        snapStepSize?: number;
        minValue?: number;
        maxValue?: number;
        thumbImage?: Image;
        isHapticSnap?: boolean;
        isTrackRounded?: boolean;
        /**
         * @deprecated
         * @example
         * ````
         * import RangeSlider from '@smartface/native/ui/rangeslider';
         *
         * const rangeSlider = new RangeSlider();
         * rangeSlider.on(RangeSlider.Events.ValueChange, params => {
         *  console.info('onValueChange', params);
         * });
         * ````
         */
        onValueChange?: (value: number[]) => void;
    }
    const RangeSlider: typeof AbstractRangeSlider;
    type RangeSlider = AbstractRangeSlider;
    export default RangeSlider;
}
declare module "ui/rangeslider/rangeslider.android" {
    import { RangeSliderEvents } from "ui/rangeslider/rangeslider-events";
    import { ViewAndroid } from "ui/view/view.android";
    import { IRangeSlider } from "ui/rangeslider/index";
    import Color from "ui/color/index";
    export default class RangeSliderAndroid<TEvent extends string = RangeSliderEvents> extends ViewAndroid<TEvent | RangeSliderEvents, any, IRangeSlider> implements IRangeSlider {
        private _snapStepSize;
        private _minValue;
        private _maxValue;
        private _thumbBorderWidth;
        private _trackWeight;
        private _outerTrackWeight;
        private _trackColor;
        private _outerTrackColor;
        private _thumbColor;
        private _thumbBorderColor;
        private _thumbSize;
        private _isTrackRounded;
        private _rangeEnabled;
        private _maxValueChanged;
        private _onValueChange;
        constructor(params: Partial<IRangeSlider>);
        get value(): number[];
        set value(value: number[]);
        get snapStepSize(): number;
        set snapStepSize(value: number);
        get minValue(): number;
        set minValue(value: number);
        get maxValue(): number;
        set maxValue(value: number);
        get trackWeight(): number;
        set trackWeight(value: number);
        get isTrackRounded(): boolean;
        set isTrackRounded(value: boolean);
        get rangeEnabled(): boolean;
        set rangeEnabled(value: boolean);
        get trackColor(): Color;
        set trackColor(value: Color);
        get outerTrackColor(): Color;
        set outerTrackColor(value: Color);
        get onValueChange(): (value: number[]) => void;
        set onValueChange(value: (value: number[]) => void);
    }
}
declare module "ui/rangeslider/rangeslider.ios" {
    import { IRangeSlider } from "ui/rangeslider/index";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import ViewIOS from "ui/view/view.ios";
    import { RangeSliderEvents } from "ui/rangeslider/rangeslider-events";
    export default class RangeSliderIOS<TEvent extends string = RangeSliderEvents> extends ViewIOS<TEvent | RangeSliderEvents, any, IRangeSlider> implements IRangeSlider {
        private _rangeEnabled;
        private _thumbImage;
        private _onValueChange;
        constructor(params?: Partial<IRangeSlider>);
        get rangeEnabled(): boolean;
        set rangeEnabled(value: boolean);
        get trackColor(): Color;
        set trackColor(value: Color);
        get outerTrackColor(): Color;
        set outerTrackColor(value: Color);
        get trackWeight(): number;
        set trackWeight(value: number);
        get value(): number[];
        set value(value: number[]);
        get snapStepSize(): number;
        set snapStepSize(value: number);
        get minValue(): number;
        set minValue(value: number);
        get maxValue(): number;
        set maxValue(value: number);
        get thumbImage(): Image;
        set thumbImage(value: Image);
        get isHapticSnap(): boolean;
        set isHapticSnap(value: boolean);
        get isTrackRounded(): boolean;
        set isTrackRounded(value: boolean);
        get onValueChange(): (value: number[]) => void;
        set onValueChange(value: (value: number[]) => void);
    }
}
declare module "ui/scrollview/scrollview.android" {
    import { IScrollView, ScrollViewAlign, ScrollViewEdge } from "ui/scrollview/index";
    import { Point2D } from "primitive/point2d";
    import ViewGroupAndroid from "ui/viewgroup/viewgroup.android";
    import { ScrollViewEvents } from "ui/scrollview/scrollview-events";
    import FlexLayoutAndroid from "ui/flexlayout/flexlayout.android";
    import { ViewAndroid } from "ui/view/view.android";
    export default class ScrollViewAndroid<TEvent extends string = ScrollViewEvents> extends ViewGroupAndroid<TEvent | ScrollViewEvents, any, IScrollView> implements IScrollView {
        private _align;
        private prevY;
        private prevOldY;
        private prevX;
        private prevOldX;
        private _layout;
        private _autoSizeEnabled;
        scrollToEdge(edge: ScrollViewEdge): void;
        scrollToCoordinate(coordinate: number, animate: boolean): void;
        onScroll: (params: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void;
        constructor(params?: IScrollView);
        private getAndroidProps;
        private calculateScrollViewSize;
        addChild(view: ViewAndroid): void;
        applyLayout(): void;
        toString(): string;
        get align(): ScrollViewAlign;
        get layout(): FlexLayoutAndroid<"touch" | "touchCancelled" | "touchEnded" | "touchMoved" | "viewAdded" | "viewRemoved" | "interceptTouchEvent", any, import("ui/flexlayout").IFlexLayout<"touch" | "touchCancelled" | "touchEnded" | "touchMoved" | "viewAdded" | "viewRemoved" | "interceptTouchEvent", import("core/native-mobile-component").MobileOSProps<Partial<import("ui/view").ViewIOSProps>, import("ui/flexlayout").FlexLayoutAndroidProps>>>;
        get scrollBarEnabled(): IScrollView['scrollBarEnabled'];
        set scrollBarEnabled(value: IScrollView['scrollBarEnabled']);
        get autoSizeEnabled(): boolean;
        set autoSizeEnabled(value: boolean);
        get contentOffset(): {
            x: number;
            y: number;
        };
        static Align: typeof ScrollViewAlign;
        static Edge: typeof ScrollViewEdge;
    }
}
declare module "ui/scrollview/scrollview.ios" {
    import { IScrollView, ScrollViewAlign, ScrollViewEdge } from "ui/scrollview/index";
    import { Point2D } from "primitive/point2d";
    import FlexLayoutIOS from "ui/flexlayout/flexlayout.ios";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import ViewGroupIOS from "ui/viewgroup/viewgroup.ios";
    import { ScrollViewEvents } from "ui/scrollview/scrollview-events";
    export default class ScrollViewIOS<TEvent extends string = ScrollViewEvents> extends ViewGroupIOS<TEvent | ScrollViewEvents, any, IScrollView> implements IScrollView {
        scrollToEdge(edge: ScrollViewEdge): void;
        scrollToCoordinate(coordinate: number): void;
        onScroll: (params: {
            translation: Point2D;
            contentOffset: Point2D;
        }) => void;
        contentLayout: FlexLayoutIOS;
        private _frame;
        private _align;
        private _autoSizeEnabled;
        gradientColorFrameObserver?: (e: any) => void;
        constructor(params?: IScrollView);
        private changeContentSize;
        private setLayoutProps;
        private getIOSProps;
        get contentOffset(): __SF_NSRect;
        get layout(): FlexLayoutIOS<"touch" | "touchCancelled" | "touchEnded" | "touchMoved" | "viewAdded" | "viewRemoved" | "interceptTouchEvent", any, import("ui/flexlayout").IFlexLayout<"touch" | "touchCancelled" | "touchEnded" | "touchMoved" | "viewAdded" | "viewRemoved" | "interceptTouchEvent", import("core/native-mobile-component").MobileOSProps<Partial<import("ui/view").ViewIOSProps>, import("ui/flexlayout").FlexLayoutAndroidProps>>>;
        get paginationEnabled(): boolean;
        set paginationEnabled(value: boolean);
        get autoSizeEnabled(): boolean;
        set autoSizeEnabled(value: boolean);
        overScrollMode: OverScrollMode;
        get align(): ScrollViewAlign;
        set align(value: ScrollViewAlign);
        get scrollBarEnabled(): boolean;
        set scrollBarEnabled(value: boolean);
        static Align: typeof ScrollViewAlign;
        static Edge: typeof ScrollViewEdge;
    }
}
declare module "ui/searchview/searchview.android" {
    import { ISearchView } from "ui/searchview/index";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import KeyboardType from "ui/shared/keyboardtype";
    import { ViewAndroid } from "ui/view/view.android";
    import { SearchViewEvents } from "ui/searchview/searchview-events";
    import Font from "ui/font/index";
    import TextAlignment from "ui/shared/textalignment";
    import Page from "ui/page/index";
    export default class SearchViewAndroid<TEvent extends string = SearchViewEvents> extends ViewAndroid<TEvent | SearchViewEvents, any, ISearchView> implements ISearchView {
        private _hasEventsLocked;
        private _hint;
        private _textColor;
        private _defaultUnderlineColorNormal;
        private _defaultUnderlineColorFocus;
        private mSearchSrcTextView;
        private mCloseButton;
        private mSearchButton;
        private mUnderLine;
        private mSearchEditFrame;
        private mCompatImageView;
        private _hintTextColor;
        private _keyboardType;
        private _closeImage;
        private _backgroundImage;
        private _textFieldBackgroundColor;
        private _textFieldBorderRadius;
        private _searchButtonIcon;
        private _closeIcon;
        private _searchIcon;
        private _iconifiedByDefault;
        private _searchIconAssigned;
        private _isNotSetTextWatcher;
        private _isClicklistenerAdded;
        private _leftItem;
        private _underlineColor;
        private _font;
        private _textalignment;
        private textFieldBackgroundDrawable;
        private _onSearchBeginCallback;
        private _onSearchEndCallback;
        private _onTextChangedCallback;
        private _onSearchButtonClickedCallback;
        private skipDefaults;
        constructor(params?: Partial<ISearchView>);
        get keyboardType(): KeyboardType;
        set keyboardType(value: KeyboardType);
        get textalignment(): TextAlignment;
        set textalignment(value: TextAlignment);
        get text(): string;
        set text(value: string);
        get hint(): string;
        set hint(value: string);
        get textColor(): Color;
        set textColor(value: Color);
        get backgroundImage(): Image;
        set backgroundImage(value: Image);
        get iconImage(): Image;
        set iconImage(value: Image);
        get searchIcon(): Image;
        set searchIcon(value: Image);
        get font(): Font;
        set font(value: Font);
        get textAlignment(): TextAlignment;
        set textAlignment(value: TextAlignment);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get textFieldBackgroundColor(): Color;
        set textFieldBackgroundColor(value: Color);
        get onSearchBegin(): () => void;
        set onSearchBegin(value: () => void);
        get onSearchEnd(): () => void;
        set onSearchEnd(value: () => void);
        get onTextChanged(): (searchText: string) => void;
        set onTextChanged(value: (searchText: string) => void);
        get onSearchButtonClicked(): () => void;
        set onSearchButtonClicked(value: () => void);
        addToHeaderBar(page: Page): void;
        removeFromHeaderBar(page: Page): void;
        showKeyboard(): void;
        hideKeyboard(): void;
        requestFocus(): void;
        removeFocus(): void;
        updateQueryHint(mSearchSrcTextView: any, icon: Image | null, hint: string): void;
        setTextFieldBackgroundDrawable(): void;
        setTextWatcher(): void;
        setOnSearchButtonClickedListener(): void;
        toString(): string;
    }
}
declare module "ui/searchview/searchview.ios" {
    import { ISearchView } from "ui/searchview/index";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import Image from "ui/image/index";
    import TextAlignment from "ui/shared/textalignment";
    import ViewIOS from "ui/view/view.ios";
    import { SearchViewEvents } from "ui/searchview/searchview-events";
    import Page from 'ui/page';
    export default class SearchViewIOS<TEvent extends string = SearchViewEvents> extends ViewIOS<TEvent | SearchViewEvents, any, ISearchView> implements ISearchView {
        private _textAligment;
        private _constant;
        private _hint;
        private _hintTextColor;
        private _textColor;
        private _backgroundColor;
        private _backgroundImage;
        private _iconImage;
        private _searchIcon;
        private _borderWidth;
        private _searchContainerView;
        private _isAddedHeaderBar;
        private _showsCancelButton;
        private _onSearchBegin;
        private _onSearchEnd;
        private _onTextChanged;
        private _onSearchButtonClicked;
        private _onCancelButtonClicked;
        private _searchBarDelegate;
        private _searchViewStyle;
        private textfield;
        private keyboardanimationdelegate;
        constructor(params?: Partial<ISearchView>);
        get text(): string;
        set text(value: string);
        get hint(): string;
        set hint(value: string);
        get textColor(): Color;
        set textColor(value: Color);
        get backgroundColor(): Color;
        set backgroundColor(value: Color);
        get backgroundImage(): Image;
        set backgroundImage(value: Image);
        get iconImage(): Image;
        set iconImage(value: Image);
        get searchIcon(): Image;
        set searchIcon(value: Image);
        get borderWidth(): number;
        set borderWidth(value: number);
        addToHeaderBar(page: Page): void;
        removeFromHeaderBar(page: Page): void;
        showKeyboard(): void;
        hideKeyboard(): void;
        requestFocus(): void;
        removeFocus(): void;
        get font(): Font;
        set font(value: Font);
        get textAlignment(): TextAlignment;
        set textAlignment(value: TextAlignment);
        get hintTextColor(): Color;
        set hintTextColor(value: Color);
        get textFieldBackgroundColor(): Color;
        set textFieldBackgroundColor(value: Color);
        get onSearchBegin(): () => void;
        set onSearchBegin(value: () => void);
        get onSearchEnd(): () => void;
        set onSearchEnd(value: () => void);
        get onTextChanged(): (searchText: string) => void;
        set onTextChanged(value: (searchText: string) => void);
        get onSearchButtonClicked(): () => void;
        set onSearchButtonClicked(value: () => void);
    }
}
declare module "ui/selectablepicker/selectablepicker-events" {
    export const SelectablePickerEvents: {
        readonly Selected: "selected";
    };
    export type SelectablePickerEvents = ExtractValues<typeof SelectablePickerEvents>;
}
declare module "ui/selectablepicker/index" {
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { SelectablePickerEvents } from "ui/selectablepicker/selectablepicker-events";
    import { ConstructorOf } from "core/constructorof";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    export interface ISelectablePicker<TEvent extends string = SelectablePickerEvents> extends NativeEventEmitterComponent<TEvent> {
        /**
         * Gets/sets items of the SelectablePicker.
         *
         * @property {Array} items
         * @android
         * @since 4.0.5
         */
        items: string[];
        /**
         * This event is called when an item is selected/unselected on the SelectablePicker.
         * If multiSelectEnabled is false, selected will be always true.
         *
         * @param {Number} index
         * @param {Boolean} selected
         * @event onSelected
         * @deprecated
         * @android
         * @since 4.0.5
         * @example
         * ````
         * import SelectablePicker from '@smartface/native/ui/selectablepicker';
         *
         * const selectablePicker = new SelectablePicker();
         * selectablePicker.on(SelectablePicker.Events.Selected, (params) => {
         *  console.info('onSelected', params);
         * });
         * ````
         */
        onSelected: (index?: number, selected?: boolean) => void;
        /**
         * Gets/sets title of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {String} [title = Picker]
         * @android
         * @since 4.0.5
         */
        title: string;
        /**
         * Gets/sets titleColor of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} [titleColor = Color.BLACK]
         * @android
         * @since 4.0.5
         */
        titleColor: Color;
        /**
         * Gets/sets titleFont of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} titleFont
         * @android
         * @since 4.0.5
         */
        titleFont: Font;
        /**
         * Gets/sets multiSelectEnabled of the SelectablePicker. You must set this property in constructor
         * and can not change this property on run-time. Otherwise SelectablePicker may not work properly.
         * This property only works with show method. Must set before show method.
         *
         * @property {Boolean} [multiSelectEnabled = false]
         * @android
         * @since 4.0.5
         */
        multiSelectEnabled: boolean;
        /**
         * Gets/sets cancelable of the SelectablePicker. If click outside of dialog, it will be canceled.
         * This property only works with show method. Must set before show method.
         *
         * @property {Boolean} [cancelable = true]
         * @android
         * @since 4.0.5
         */
        cancelable: boolean;
        /**
         * Gets/sets checkedItems of the SelectablePicker.
         * If multiSelectEnabled is false, checkedItems must be a spesific index of the items array or array of index.
         * This property only works with show method. Must set before show method.
         *
         * @property {Number|Array} [checkedItems = -1]
         * @android
         * @since 4.0.5
         */
        checkedItems: number | number[];
        /**
         * Gets/sets backgroundColor of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} [backgroundColor = Color.WHITE]
         * @android
         * @since 4.0.5
         */
        backgroundColor: Color;
        /**
         * Gets/sets cancelButtonColor of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} cancelButtonColor
         * @android
         * @since 4.0.5
         */
        cancelButtonColor: Color;
        /**
         * Gets/sets cancelButtonFont of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} cancelButtonFont
         * @android
         * @since 4.0.5
         */
        cancelButtonFont: Font;
        /**
         * Gets/sets cancelButtonText of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {String} [cancelButtonText = Cancel]
         * @android
         * @since 4.0.5
         */
        cancelButtonText: string;
        /**
         * Gets/sets doneButtonColor of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Color} doneButtonColor
         * @android
         * @since 4.0.5
         */
        doneButtonColor: Color;
        /**
         * Gets/sets doneButtonText of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {String} [doneButtonText = Ok]
         * @android
         * @since 4.0.5
         */
        doneButtonText: string;
        /**
         * Gets/sets doneButtonFont of the SelectablePicker.
         * This property only works with show method. Must set before show method.
         *
         * @property {UI.Font} doneButtonFont
         * @android
         * @since 4.0.5
         */
        doneButtonFont: Font;
        /**
         * This function shows SelectablePicker in a dialog.
         *
         * @param {Function} done This event is called when user clicks done button.
         * @param {Object} done.param
         * @param {Number|Array} done.param.items If multiSelectEnabled is false, items will be index of selected item, otherwise array of selected items's indexs
         * @param {Function} cancel This event is called when user clicks cancel button.
         * @method show
         * @android
         * @since 4.0.5
         */
        show(done: (param: {
            items: number | number[];
        }) => void, cancel: () => void): void;
    }
    const SelectablePicker: ConstructorOf<ISelectablePicker, Partial<ISelectablePicker>>;
    type SelectablePicker = ISelectablePicker;
    export default SelectablePicker;
}
declare module "ui/selectablepicker/selectablepicker.android" {
    import { ISelectablePicker } from "ui/selectablepicker/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { SelectablePickerEvents } from "ui/selectablepicker/selectablepicker-events";
    export default class SelectablePickerAndroid<TEvent extends SelectablePickerEvents> extends NativeEventEmitterComponent<TEvent | SelectablePickerEvents> implements ISelectablePicker<TEvent | SelectablePickerEvents> {
        private _items;
        private _multiSelectEnabled;
        private _cancelable;
        private _checkedItem;
        private _checkedItems;
        private _backgroundColor;
        private _selectedItems;
        private _onSelected;
        private _listeners;
        private _isShowed;
        private _doneButtonText;
        private _doneButtonFont;
        private _doneButtonColor;
        private _cancelButtonText;
        private _cancelButtonFont;
        private _cancelButtonColor;
        private _titleFont;
        private _titleColor;
        private _title;
        constructor(params?: Partial<ISelectablePicker>);
        get items(): ISelectablePicker['items'];
        set items(value: ISelectablePicker['items']);
        get multiSelectEnabled(): ISelectablePicker['multiSelectEnabled'];
        set multiSelectEnabled(value: ISelectablePicker['multiSelectEnabled']);
        get cancelable(): ISelectablePicker['cancelable'];
        set cancelable(value: ISelectablePicker['cancelable']);
        get checkedItems(): ISelectablePicker['checkedItems'];
        set checkedItems(value: ISelectablePicker['checkedItems']);
        get backgroundColor(): ISelectablePicker['backgroundColor'];
        set backgroundColor(value: ISelectablePicker['backgroundColor']);
        get onSelected(): ISelectablePicker['onSelected'];
        set onSelected(value: ISelectablePicker['onSelected']);
        get titleFont(): ISelectablePicker['titleFont'];
        set titleFont(value: ISelectablePicker['titleFont']);
        get title(): ISelectablePicker['title'];
        set title(value: ISelectablePicker['title']);
        get titleColor(): ISelectablePicker['titleColor'];
        set titleColor(value: ISelectablePicker['titleColor']);
        get cancelButtonColor(): ISelectablePicker['cancelButtonColor'];
        set cancelButtonColor(value: ISelectablePicker['cancelButtonColor']);
        get cancelButtonFont(): ISelectablePicker['cancelButtonFont'];
        set cancelButtonFont(value: ISelectablePicker['cancelButtonFont']);
        get cancelButtonText(): ISelectablePicker['cancelButtonText'];
        set cancelButtonText(value: ISelectablePicker['cancelButtonText']);
        get doneButtonColor(): ISelectablePicker['doneButtonColor'];
        set doneButtonColor(value: ISelectablePicker['doneButtonColor']);
        get doneButtonText(): ISelectablePicker['doneButtonText'];
        set doneButtonText(value: ISelectablePicker['doneButtonText']);
        get doneButtonFont(): ISelectablePicker['doneButtonFont'];
        set doneButtonFont(value: ISelectablePicker['doneButtonFont']);
        show(done: (param: {
            items: number | number[];
        }) => void, cancel: () => void): void;
        toString(): string;
        private customizeDialog;
        private __makeCustomizeButton;
        private createSingleSelectListener;
        private createMultiSelectListener;
        private createCancelButtonListener;
        private createDoneButtonListener;
        private __createTitleView;
    }
}
declare module "ui/selectablepicker/selectablepicker.ios" {
    import { ISelectablePicker } from "ui/selectablepicker/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import Color from "ui/color/index";
    import { AbstractFont } from "ui/font/font";
    import { SelectablePickerEvents } from "ui/selectablepicker/selectablepicker-events";
    /**
     * This class doesn't exist on iOS side, therefore the class is left empty to not throw undefined errors on runtime and such.
     * This doesn't need any implementation.
     */
    export default class SelectablePickerIOS<TEvent extends string = SelectablePickerEvents> extends NativeEventEmitterComponent<TEvent | SelectablePickerEvents> implements ISelectablePicker {
        items: string[];
        onSelected: (index?: number, selected?: boolean) => void;
        title: string;
        titleColor: Color;
        titleFont: AbstractFont;
        multiSelectEnabled: boolean;
        cancelable: boolean;
        checkedItems: number | number[];
        backgroundColor: Color;
        cancelButtonColor: Color;
        cancelButtonFont: AbstractFont;
        cancelButtonText: string;
        doneButtonColor: Color;
        doneButtonText: string;
        doneButtonFont: AbstractFont;
        show(): void;
        toString(): string;
    }
}
declare module "ui/shared/ios/textcontenttype" {
    const TextContentType: {
        NAME: string;
        NAMEPREFIX: string;
        GIVENNAME: string;
        MIDDLENAME: string;
        FAMILYNAME: string;
        NAMESUFFIX: string;
        NICKNAME: string;
        JOBTITLE: string;
        ORGANIZATIONNAME: string;
        LOCATION: string;
        FULLSTREETADDRESS: string;
        STREETADDRESSLINE1: string;
        STREETADDRESSLINE2: string;
        ADDRESSCITY: string;
        ADDRESSSTATE: string;
        ADDRESSCITYANDSTATE: string;
        SUBLOCALITY: string;
        COUNTRYNAME: string;
        POSTALCODE: string;
        TELEPHONENUMBER: string;
        EMAILADDRESS: string;
        URL: string;
        CREDITCARDNUMBER: string;
        USERNAME: string;
        PASSWORD: string;
        NEWPASSWORD: string;
        ONETIMECODE: string;
    };
    export default TextContentType;
}
declare module "ui/shimmerflexlayout/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import FlexLayout from "ui/flexlayout/index";
    import { AbstractView, IView } from "ui/view/index";
    import { ViewEvents } from "ui/view/view-event";
    export enum ShimmeringDirection {
        /**
         * Highlight sweeps from  bottom to top.
         *
         * @property UP
         * @static
         * @android
         * @ios
         * @readonly
         * @since 3.1.3
         */
        UP = 0,
        /**
         * Highlight sweeps from right to left.
         *
         * @property LEFT
         * @static
         * @android
         * @ios
         * @readonly
         * @since 3.1.3
         */
        LEFT = 1,
        /**
         * Highlight sweeps from top to bottom.
         *
         * @property DOWN
         * @static
         * @android
         * @ios
         * @readonly
         * @since 3.1.3
         */
        DOWN = 2,
        /**
         * Highlight sweeps from left to right.
         *
         * @property RIGHT
         * @static
         * @android
         * @ios
         * @readonly
         * @since 3.1.3
         */
        RIGHT = 3
    }
    export enum ShimmerHighlight {
        /**
         * The shimmer will be specified alpha.
         *
         * @property AlphaHighlight
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        AlphaHighlight = 0,
        /**
         * The shimmer will be specified color.
         *
         * @property ColorHighlight
         * @static
         * @android
         * @readonly
         * @since 3.1.3
         */
        ColorHighlight = 1
    }
    export interface ShimmerFlexLayoutAndroidParams {
        /**
         * Builds the shimmer based on your assigned properties by given UI.ShimmerFlexLayout.Android.Shimmer. This method must be used after all other
         * propertis of ShimmerFlexLayout is assigned.
         *
         * @method build
         * @param {UI.ShimmerFlexLayout.Android.Shimmer} shimmerType
         * @android
         * @since 3.1.3
         */
        build(shimmerType: typeof AbstractShimmerFlexLayout.Android.Shimmer): void;
        /**
         * Sets the animation duration.
         *
         * @property {Number} duration
         * @android
         * @since 3.1.3
         */
        duration: number;
        /**
         * Controls the brightness of the highlight at the center.
         *
         * @property {Number} [intensity = 0]
         * @android
         * @since 3.1.3
         */
        intensity: number;
        /**
         * Set animation repeat count.
         *
         * @property {Number} repeatCount
         * @android
         * @since 3.1.3
         */
        repeatCount: number;
        /**
         * Angle at which the highlight is tilted, measured in degrees.
         *
         * @property {Number} [tilt = 20]
         * @android
         * @since 3.1.3
         */
        tilt: number;
        /**
         * Set the shimmer's highlight color. This property must be used if given shimmer type is UI.ShimmerFlexLayout.Android.Shimmer.ColorHighlight
         *
         * @property {UI.Color} highlightColor
         * @android
         * @since 3.1.3
         */
        highlightColor: Color;
        /**
         * Set base  color of content. This property must be used if given shimmer type is UI.ShimmerFlexLayout.Android.Shimmer.ColorHighlight
         *
         * @property {UI.Color} baseColor
         * @android
         * @since 3.1.3
         */
        baseColor: Color;
        /**
         * Set the alpha of the shimmer highlight.
         *
         * @property {UI.Color} highlightAlpha
         * @android
         * @since 3.1.3
         */
        highlightAlpha: Color;
    }
    export interface ShimmerFlexLayoutIOSParams {
        /**
         * The highlight length of shimmering. Range of [0,1], defaults to 1.0.
         *
         * @property {Number} [highlightLength = 1.0]
         * @ios
         * @since 3.1.3
         */
        highlightLength: number;
        /**
         * The alpha of the content while it is shimmering. Defaults to 0.5.
         *
         * @property {Number} [animationAlpha = 0.5]
         * @ios
         * @since 3.1.3
         */
        animationAlpha: number;
        /**
         * The speed of shimmering, in points per second. Defaults to 230.
         *
         * @property {Number} [speed = 230]
         * @ios
         * @since 3.1.3
         */
        speed: number;
        /**
         * The duration of the fade used when shimmer begins. Defaults to 100.
         *
         * @property {Number} [beginFadeDuration = 100]
         * @ios
         * @since 3.1.3
         */
        beginFadeDuration: number;
        /**
         * The duration of the fade used when shimmer ends. Defaults to 300.
         *
         * @property {Number} [endFadeDuration = 300]
         * @ios
         * @since 3.1.3
         */
        endFadeDuration: number;
    }
    export interface IShimmerFlexLayout<TEvent extends string = ViewEvents, TMobile extends MobileOSProps<IView['ios'] & ShimmerFlexLayoutIOSParams, IView['android'] & ShimmerFlexLayoutAndroidParams> = MobileOSProps<IView['ios'] & ShimmerFlexLayoutIOSParams, IView['android'] & ShimmerFlexLayoutAndroidParams>> extends IView<TEvent, any, TMobile> {
        /**
         * Starts the shimmer animation
         *
         * @method  startShimmer
         * @android
         * @ios
         * @since 3.1.3
         */
        startShimmering(): void;
        /**
         * Stops the shimmer animation
         *
         * @method  stopShimmer
         * @android
         * @ios
         * @since 3.1.3
         */
        stopShimmering(): void;
        /**
         * Assign the content flexlayout for shimmering.
         *
         * @property {UI.FlexLayout} contentLayout
         * @ios
         * @android
         * @since 3.1.3
         */
        contentLayout: FlexLayout;
        /**
         * Gives information about whether the shimmer animation started or not.
         *
         * @property {Boolean} isShimmering
         * @readonly
         * @ios
         * @android
         * @since 3.1.3
         */
        get isShimmering(): boolean;
        /**
         * Set alpha for unhighlighted view over which the highlight is drawn.
         *
         * @property {Number} [baseAlpha = 1]
         * @android
         * @ios
         * @since 3.1.3
         */
        baseAlpha: number;
        /**
         * Set animation repeat delay.
         *
         * @property {Number} [pauseDuration = 400]
         * @android
         * @ios
         * @since 3.1.3
         */
        pauseDuration: number;
        shimmeringDirection: ShimmeringDirection;
    }
    /**
     * @class UI.ShimmerFlexLayout
     * @extends UI.View
     * @since 3.1.3
     *
     * This class provides an easy way to add a shimmer effect to  any view. It is useful as an unobtrusive loading indicator.
     *
     *
     *     @example
     *     import FlexLayout from '@smartface/native/ui/flexlayout';
     *     import Color from '@smartface/native/ui/color';
     *
     *     const flex = new FlexLayout();
     *     flex.flexGrow = 1;
     *     flex.flexDirection = FlexLayout.FlexDirection.ROW;
     *     var flexImage = new FlexLayout();
     *     flexImage.flexGrow = 0.5;
     *     flexImage.margin = 20;
     *     flexImage.marginRight = 10;
     *     flexImage.borderRadius = 10;
     *     flexImage.backgroundColor = Color.LIGHTGRAY;
     *
     *     flex.addChild(flexImage);
     *
     *     const flexLabels = new FlexLayout();
     *     flexLabels.flexGrow = 1;
     *
     *     const labelTop = new FlexLayout();
     *     labelTop.height = 20;
     *     labelTop.margin = 20;
     *     labelTop.marginBottom = 10;
     *     labelTop.borderRadius = 10;
     *     labelTop.backgroundColor = Color.LIGHTGRAY;
     *     flexLabels.addChild(labelTop);
     *
     *     const labelCenter = new FlexLayout();
     *     labelCenter.height = 20;
     *     labelCenter.margin = 20;
     *     labelCenter.marginTop = 0;
     *     labelCenter.borderRadius = 10;
     *     labelCenter.marginRight = 100;
     *     labelCenter.backgroundColor = Color.LIGHTGRAY;
     *     flexLabels.addChild(labelCenter);
     *
     *     const labelBottom = new FlexLayout();
     *     labelBottom.positionType = FlexLayout.PositionType.ABSOLUTE;
     *     labelBottom.bottom = 20;
     *     labelBottom.left = 20;
     *     labelBottom.height = 20;
     *     labelBottom.right = 40;
     *     labelBottom.borderRadius = 10;
     *     labelBottom.backgroundColor = Color.LIGHTGRAY;
     *
     *     flexLabels.addChild(labelBottom);
     *
     *     flex.addChild(flexLabels);
     *
     *     const shimmer = new ShimmerFlexLayout();
     *     shimmer.height = 200;
     *
     *     shimmer.ios.animationAlpha = 0.2;
     *     shimmer.baseAlpha = 0.5;
     *     shimmer.pauseDuration = 500;
     *     shimmer.android.highlightAlpha = 1;
     *
     *     shimmer.android.build(ShimmerFlexLayout.Android.Shimmer.AlphaHighlight);
     *     shimmer.contentLayout = flex
     *     myPage.layout.addChild(shimmer);
     *     shimmer.startShimmering();
     *
     */
    export class AbstractShimmerFlexLayout<TEvent extends string = ViewEvents> extends AbstractView<TEvent | ViewEvents> implements IShimmerFlexLayout {
        constructor(params?: Partial<IShimmerFlexLayout>);
        shimmeringDirection: ShimmeringDirection;
        startShimmering(): void;
        stopShimmering(): void;
        contentLayout: FlexLayout;
        get isShimmering(): boolean;
        baseAlpha: number;
        pauseDuration: number;
        static Android: {
            Shimmer: typeof ShimmerHighlight;
        };
        static ShimmeringDirection: typeof ShimmeringDirection;
    }
    const ShimmerFlexLayout: typeof AbstractShimmerFlexLayout;
    type ShimmerFlexLayout = IShimmerFlexLayout;
    export default ShimmerFlexLayout;
}
declare module "ui/shimmerflexlayout/shimmerflexlayout.android" {
    import { AbstractShimmerFlexLayout, IShimmerFlexLayout, ShimmerFlexLayoutAndroidParams } from "ui/shimmerflexlayout/index";
    import { ViewEvents } from "ui/view/view-event";
    import { ViewAndroid } from "ui/view/view.android";
    export default class ShimmerFlexLayoutAndroid<TEvent extends string = ViewEvents, TNative = ShimmerFlexLayoutAndroidParams> extends ViewAndroid<TEvent, TNative> implements IShimmerFlexLayout {
        private _layout;
        private _baseAlpha;
        private _direction;
        private _repeatDelay;
        private _contentLayout;
        private _duration?;
        private _intensity?;
        private _repeatCount?;
        private _tilt?;
        private _highlightColor?;
        private _baseColor?;
        private _shimmerBuilder;
        private _highlightAlpha;
        constructor(params?: Partial<IShimmerFlexLayout>);
        get contentLayout(): IShimmerFlexLayout['contentLayout'];
        set contentLayout(value: IShimmerFlexLayout['contentLayout']);
        startShimmering(): void;
        stopShimmering(): void;
        get isShimmering(): IShimmerFlexLayout['isShimmering'];
        get baseAlpha(): IShimmerFlexLayout['baseAlpha'];
        set baseAlpha(value: IShimmerFlexLayout['baseAlpha']);
        get pauseDuration(): IShimmerFlexLayout['pauseDuration'];
        set pauseDuration(value: IShimmerFlexLayout['pauseDuration']);
        get shimmeringDirection(): IShimmerFlexLayout['shimmeringDirection'];
        set shimmeringDirection(value: IShimmerFlexLayout['shimmeringDirection']);
        private shimmerBuilder;
        private androidSpecificProperties;
        static Android: typeof AbstractShimmerFlexLayout.Android;
        static ShimmeringDirection: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
    }
}
declare module "ui/shimmerflexlayout/shimmerflexlayout.ios" {
    import { AbstractShimmerFlexLayout, IShimmerFlexLayout, ShimmerFlexLayoutIOSParams } from "ui/shimmerflexlayout/index";
    import { ViewEvents } from "ui/view/view-event";
    import ViewIOS from "ui/view/view.ios";
    export default class ShimmerFlexLayoutIOS<TEvent extends string = ViewEvents, TNative = ShimmerFlexLayoutIOSParams> extends ViewIOS<TEvent, TNative, IShimmerFlexLayout> implements IShimmerFlexLayout {
        private _contentLayout;
        protected _nativeObject: __SF_FBShimmeringView;
        constructor(params?: Partial<IShimmerFlexLayout>);
        get nativeObject(): __SF_FBShimmeringView;
        startShimmering(): void;
        stopShimmering(): void;
        get isShimmering(): boolean;
        get shimmeringDirection(): IShimmerFlexLayout['shimmeringDirection'];
        set shimmeringDirection(value: IShimmerFlexLayout['shimmeringDirection']);
        get contentLayout(): IShimmerFlexLayout['contentLayout'];
        set contentLayout(value: IShimmerFlexLayout['contentLayout']);
        get pauseDuration(): IShimmerFlexLayout['pauseDuration'];
        set pauseDuration(value: IShimmerFlexLayout['pauseDuration']);
        get baseAlpha(): IShimmerFlexLayout['baseAlpha'];
        set baseAlpha(value: IShimmerFlexLayout['baseAlpha']);
        private nativeSpecificProperties;
        static Android: typeof AbstractShimmerFlexLayout.Android;
        static ShimmeringDirection: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
    }
}
declare module "ui/slider/slider-events" {
    export const SliderEvents: {
        readonly ValueChange: "valueChange";
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type SliderEvents = ExtractValues<typeof SliderEvents>;
}
declare module "ui/slider/index" {
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import { AbstractView, IView } from "ui/view/index";
    import { SliderEvents } from "ui/slider/slider-events";
    export interface ISlider<TEvent extends string = SliderEvents> extends IView {
        skipDefaults: boolean;
        /**
         * Gets/sets color of the thumb.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var Color = require('@smartface/native/ui/color');
         *     var mySlider = new Slider();
         *     mySlider.thumbColor = Color.GRAY;
         *
         * @property {UI.Color} [thumbColor = UI.Color.GRAY]
         * @android
         * @ios
         * @since 0.1
         */
        thumbColor: Color;
        /**
         * Gets/sets image of the thumb.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var mySlider = new Slider();
         *     mySlider.thumbImage = Image.createFromFile("images://smartface.png");
         *
         * @property {UI.Image} thumbImage
         * @android
         * @ios
         * @since 0.1
         */
        thumbImage: Image;
        /**
         * Gets/sets color of the thumb's minimum track color.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var Color = require('@smartface/native/ui/color');
         *     var mySlider = new Slider();
         *     mySlider.minTrackColor = Color.BLUE;
         *
         * @property {UI.Color} [minTrackColor = UI.Color.DARKGRAY]
         * @android
         * @ios
         * @since 0.1
         */
        minTrackColor: Color;
        /**
         * Gets/sets color of the thumb's maximum track color.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var Color = require('@smartface/native/ui/color');
         *     var mySlider = new Slider();
         *     mySlider.maxTrackColor = Color.GREEN;
         *
         * @property {UI.Color} [maxTrackColor = UI.Color.GREEN]
         * @android
         * @ios
         * @since 0.1
         */
        maxTrackColor: Color;
        /**
         * Gets/sets value of the slider. This value should be less or equals to maxValue,
         * greater or equals to minValue.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var mySlider = new Slider();
         *     mySlider.value = 30;
         *
         * @property {Number} [value = 0]
         * @android
         * @ios
         * @since 0.1
         */
        value: number;
        /**
         * Gets/sets minimum value of the slider.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var mySlider = new Slider();
         *     mySlider.minValue = 0;
         *
         * @property {Number} [minValue = 0]
         * @android
         * @ios
         * @since 0.1
         */
        minValue: number;
        /**
         * Gets/sets maximum value of the slider.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var mySlider = new Slider();
         *     mySlider.maxValue = 100;
         *
         * @property {Number} [maxValue = 100]
         * @android
         * @ios
         * @since 0.1
         */
        maxValue: number;
        /**
         * Enables/disables the slider.
         *
         * @since 1.1.8
         * @property {Boolean} [enabled = true]
         * @android
         * @ios
         */
        enabled: boolean;
        /**
         * This event is called when slider value changes.
         *
         *     @example
         *     const Slider = require('@smartface/native/ui/slider');
         *     var mySlider = new Slider();
         *     mySlider.onValueChange = valueChanged;
         *     mySlider.value = 40;
         *
         *     function valueChanged() {
         *         console.log("New value is: " + mySlider.value);
         *     }
         *
         * @event onValueChange
         * @android
         * @ios
         * @since 0.1
         * @deprecated
         * @example
         * ````
         * import Slider from '@smartface/native/ui/slider';
         *
         * const slider = new Slider();
         * slider.on(Slider.Events.ValueChange, () => {
         *  console.info('valueChange');
         * });
         * ````
         */
        onValueChange: (value: number) => void;
    }
    export class AbstractSlider<TEvent extends string = SliderEvents> extends AbstractView<TEvent | SliderEvents, any, ISlider> implements ISlider<TEvent> {
        constructor(params: Partial<ISlider>);
        skipDefaults: boolean;
        thumbColor: Color;
        thumbImage: Image;
        minTrackColor: Color;
        maxTrackColor: Color;
        value: number;
        minValue: number;
        maxValue: number;
        enabled: boolean;
        onValueChange: () => void;
    }
    /**
     * @class UI.Slider
     * @since 0.1
     * @extends UI.View
     *
     * Slider can be used to select a value from a range of values by moving the slider thumb along the track.
     *
     *     @example
     *     import Color from '@smartface/native/ui/color';
     *     import Slider from '@smartface/native/ui/slider';
     *     const mySlider = new Slider({
     *         width: 200,
     *         maxValue: 100,
     *         minValue: 0,
     *         value: 40,
     *         minTrackColor: Color.RED,
     *         thumbColor: Color.BLUE,
     *         onValueChange: () => {
     *             console.log("Slider's value: " + mySlider.value);
     *         }
     *     });
     *
     */
    const Slider: typeof AbstractSlider;
    type Slider = AbstractSlider;
    export default Slider;
}
declare module "ui/slider/slider.android" {
    import Color from "ui/color/index";
    import { SliderEvents } from "ui/slider/slider-events";
    import { ViewAndroid } from "ui/view/view.android";
    import { ISlider } from "ui/slider/index";
    import Image from "ui/image/index";
    export default class SliderAndroid<TEvent extends string = SliderEvents> extends ViewAndroid<TEvent | SliderEvents, any, ISlider> implements ISlider {
        private _layerDrawable;
        private _defaultThumb;
        private _minValue;
        private _maxValue;
        private _minTrackColor;
        private _maxTrackColor;
        private _thumbImage;
        private _thumbColor;
        private _onValueChange;
        constructor(params?: Partial<ISlider>);
        skipDefaults: boolean;
        get thumbColor(): Color;
        set thumbColor(value: Color);
        get thumbImage(): Image;
        set thumbImage(value: Image);
        get minTrackColor(): Color;
        set minTrackColor(value: Color);
        get maxTrackColor(): Color;
        set maxTrackColor(value: Color);
        get value(): number;
        set value(value: number);
        get minValue(): number;
        set minValue(value: number);
        get maxValue(): number;
        set maxValue(value: number);
        get onValueChange(): (value: number) => void;
        set onValueChange(value: (value: number) => void);
        toString(): string;
    }
}
declare module "ui/slider/slider.ios" {
    import { ISlider } from "ui/slider/index";
    import Color from "ui/color/index";
    import ViewIOS from "ui/view/view.ios";
    import { SliderEvents } from "ui/slider/slider-events";
    import Image from "ui/image/index";
    export default class SliderIOS<TEvent extends string = SliderEvents> extends ViewIOS<TEvent | SliderEvents, any, ISlider> implements ISlider {
        private _thumbImage;
        private _value;
        private _onValueChange;
        constructor(params?: Partial<ISlider>);
        skipDefaults: boolean;
        get thumbColor(): Color;
        set thumbColor(value: Color);
        get thumbImage(): Image;
        set thumbImage(value: Image);
        get minTrackColor(): Color;
        set minTrackColor(value: Color);
        get maxTrackColor(): Color;
        set maxTrackColor(value: Color);
        get value(): number;
        set value(value: number);
        get minValue(): number;
        set minValue(value: number);
        get maxValue(): number;
        set maxValue(value: number);
        get enabled(): boolean;
        set enabled(value: boolean);
        get onValueChange(): () => void;
        set onValueChange(value: () => void);
        handleValueChange(): void;
    }
}
declare module "ui/sliderdrawer/sliderdrawer.ios" {
    import { ISliderDrawer, SliderDrawerPosition, SliderDrawerState } from "ui/sliderdrawer/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import FlexLayoutIOS from "ui/flexlayout/flexlayout.ios";
    import { SliderDrawerEvents } from "ui/sliderdrawer/sliderdrawer-events";
    export default class SliderDrawerIOS<TEvent extends string = SliderDrawerEvents> extends NativeEventEmitterComponent<TEvent | SliderDrawerEvents, __SF_SliderDrawer> implements ISliderDrawer {
        private _position;
        private _enabled;
        private _drawerWidth;
        constructor(params?: Partial<ISliderDrawer>);
        pageView: FlexLayoutIOS;
        height: number;
        layout: FlexLayoutIOS;
        get state(): SliderDrawerState;
        get backgroundColor(): ISliderDrawer['backgroundColor'];
        set backgroundColor(value: ISliderDrawer['backgroundColor']);
        get drawerPosition(): ISliderDrawer['drawerPosition'];
        set drawerPosition(value: ISliderDrawer['drawerPosition']);
        get enabled(): ISliderDrawer['enabled'];
        set enabled(value: ISliderDrawer['enabled']);
        get width(): ISliderDrawer['width'];
        set width(value: ISliderDrawer['width']);
        get onDrag(): () => void;
        set onDrag(value: () => void);
        onShow: () => void;
        onHide: () => void;
        onLoad: () => void;
        show(): void;
        hide(): void;
        static Position: typeof SliderDrawerPosition;
        static State: typeof SliderDrawerState;
    }
}
declare module "ui/swipeitem/swipeitem" {
    import { ISwipeItem, ISwipeItemAndroidParams, ISwipeItemIOSParams } from "ui/swipeitem/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { WithMobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Font from "ui/font/index";
    import { SwipeItemEvents } from "ui/swipeitem/swipeitem-events";
    export default class SwipeItem extends NativeEventEmitterComponent<SwipeItemEvents, any, WithMobileOSProps<Partial<ISwipeItem>, Partial<ISwipeItemIOSParams>, Partial<ISwipeItemAndroidParams>>> implements ISwipeItem {
        private _text;
        private _backgroundColor;
        private _textColor;
        private _icon?;
        private _font;
        private _onPress;
        private _padding;
        private _iconTextSpacing;
        private _isAutoHide;
        private _threshold;
        private _borderBottomLeftRadius;
        private _borderBottomRightRadius;
        private _borderTopRightRadius;
        private _borderTopLeftRadius;
        private _paddingLeft;
        private _paddingRight;
        private _paddingBottom;
        private _paddingTop;
        constructor(params?: Partial<ISwipeItem>);
        get text(): string;
        set text(value: string);
        get font(): Font | null;
        set font(value: Font | null);
        get backgroundColor(): Color;
        set backgroundColor(value: Color);
        get textColor(): Color;
        set textColor(value: Color);
        get onPress(): ISwipeItem['onPress'];
        set onPress(value: ISwipeItem['onPress']);
        get icon(): ISwipeItem['icon'];
        set icon(value: ISwipeItem['icon']);
        private getIOSParams;
        private getAndroidParams;
    }
}
declare module "ui/swipeview/swipeview-events" {
    export const SwipeViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        /**
         * Gets/Sets the callback triggered when a page is selected after a swipe action.
         *
         * @event onPageSelected
         * @param index
         * @param page Selected page instance
         * @android
         * @ios
         * @since 1.1.10
         */
        readonly PageSelected: "pageSelected";
        /**
         * Gets/Sets the callback triggered when a page is scrolling. When call swipeToIndex function, onPageScrolled will behave differently on iOS and Android.
         * Click this link for SwipeToIndex and onPageScrolled use together: "https://developer.smartface.io/docs/swipeview-onpagescrolled-and-swipetoindex-together-usage"
         *
         * @event onPageScrolled
         * @param index  Index of the first page from the left that is currently visible.
         * @param offset Indicating the offset from index. Value from range [0, width of swipeview].
         * @android
         * @ios
         * @since 2.0.9
         */
        readonly PageScrolled: "pageScrolled";
        /**
         * Gets/Sets the callback triggered during swipe actions.
         *
         * @event onStateChanged
         * @param {UI.SwipeView.State} state
         * @android
         * @ios
         * @since 1.1.10
         */
        readonly StateChanged: "stateChanged";
    };
    export type SwipeViewEvents = ExtractValues<typeof SwipeViewEvents>;
}
declare module "ui/swipeview/index" {
    import Page from "ui/page/index";
    import { AbstractView, IView } from "ui/view/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import { SwipeViewEvents } from "ui/swipeview/swipeview-events";
    import { MobileOSProps } from "core/native-mobile-component";
    /**
     * @enum UI.SwipeView.State
     * @static
     * @readonly
     * @since 1.1.10
     *
     */
    export enum SwipeViewState {
        /**
         * @property {Number} [IDLE = 0]
         * @android
         * @ios
         * @static
         * @readonly
         * @since 1.1.10
         */
        IDLE = 0,
        /**
         * @property {Number} [DRAGGING = 1]
         * @android
         * @ios
         * @static
         * @readonly
         * @since 1.1.10
         */
        DRAGGING = 1
    }
    /**
     * @class UI.SwipeView
     * @since 1.1.10
     * @extends UI.View
     * SwipeView holds page classes provided inside an array. These pages can be traversed horizontally via gesture
     * actions.
     *
     *     @example
     *     const SwipeView = require('@smartface/native/ui/swipeview');
     *     var swipeView = new SwipeView({
     *       page: currentPage,
     *       width:300, height:300,
     *       pages: [require("../ui/ui_swipePage1"), require("../ui/ui_swipePage2"), require("../ui/ui_swipePage3")],
     *       onPageSelected: function(index,page) {
     *         console.log("Selected Page Index : " + index);
     *         console.log("Selected Page Instance : " + page);
     *       },
     *       onStateChanged: function(state) {
     *         if (SwipeView.State.DRAGGING === state) {
     *           console.log("Dragging");
     *         } else {
     *           console.log("Idle");
     *         }
     *       }
     *     });
     *
     * @constructor
     * @param {Object} object
     * @param {UI.Page} object.page
     * It is required to pass the current page to swipeview.
     *
     */
    export interface ISwipeView<TEvent extends string = SwipeViewEvents, TMobile extends MobileOSProps<IView['ios'], IView['android']> = MobileOSProps<IView['ios'], IView['android']>> extends IView<TEvent | SwipeViewEvents, any, TMobile> {
        /**
         * Gets/Sets the callback triggered when a page is selected after a swipe action.
         *
         * @event onPageSelected
         * @param index
         * @deprecated
         * @param page Selected page instance
         * @android
         * @ios
         * @since 1.1.10
         * @example
         * ````
         * import SwipeView from '@smartface/native/ui/swipeview';
         *
         * const swipeView = new SwipeView();
         * swipeView.on(SwipeView.Events.PageSelected, (params) => {
         * 	console.info('onPageSelected', params);
         * });
         * ````
         */
        page: Page;
        /**
         * Gets/Sets the array of the page classes will be displayed inside SwipeView. Pages parameter cannot be empty.
         *
         * @property {Array} pages
         * @android
         * @ios
         * @since 1.1.10
         */
        pages: Page[];
        onPageSelected: (index: number, page: Page) => void;
        /**
         * Gets/Sets the callback triggered when a page is scrolling. When call swipeToIndex function, onPageScrolled will behave differently on iOS and Android.
         * Click this link for SwipeToIndex and onPageScrolled use together: "https://developer.smartface.io/docs/swipeview-onpagescrolled-and-swipetoindex-together-usage"
         *
         * @event onPageScrolled
         * @param index  Index of the first page from the left that is currently visible.
         * @param offset Indicating the offset from index. Value from range [0, width of swipeview].
         * @deprecated
         * @android
         * @ios
         * @since 2.0.9
         * @example
         * ````
         * import SwipeView from '@smartface/native/ui/swipeview';
         *
         * const swipeView = new SwipeView();
         * swipeView.on(SwipeView.Events.PageScrolled, (params) => {
         * 	console.info('onPageScrolled', params);
         * });
         * ````
         */
        onPageScrolled: (index: number, offset: number) => void;
        /**
         * Gets/Sets the callback triggered during swipe actions.
         *
         * @event onStateChanged
         * @param {UI.SwipeView.State} state
         * @deprecated
         * @android
         * @ios
         * @since 1.1.10
         * @example
         * ````
         * import SwipeView from '@smartface/native/ui/swipeview';
         *
         * const swipeView = new SwipeView();
         * swipeView.on(SwipeView.Events.StateChanged, (params) => {
         * 	console.info('onStateChanged', params);
         * });
         * ````
         */
        onStateChanged: (state: SwipeViewState) => void;
        /**
         * Gets the currently displayed page's index inside the page array.
         *
         * @property {Number} currentIndex
         * @android
         * @ios
         * @readonly
         * @since 1.1.10
         */
        currentIndex: number;
        /**
         * Enables/Disables paging behavior.
         *
         * @property {Boolean} [pagingEnabled = true]
         * @android
         * @ios
         * @since 4.3.2
         */
        pagingEnabled: boolean;
        /**
         * Swipes to the page inside the index of the array.
         *
         * @method swipeToIndex
         * @param {Number} index
         * @param {Boolean} [animated=false]
         * @android
         * @ios
         * @since 1.1.10
         */
        swipeToIndex(index: number, animated: boolean): void;
        overScrollMode: OverScrollMode;
        onPageCreate: (position: number) => Page | null;
        pageCount: number;
        pagerAdapter: {
            notifyDataSetChanged: () => void;
        };
    }
    export class AbstractSwipeView<TEvent extends string = SwipeViewEvents, TIOS extends Record<string, any> = {}, TAND extends Record<string, any> = {}> extends AbstractView<TEvent | SwipeViewEvents, any, ISwipeView> implements ISwipeView {
        constructor(params?: Partial<ISwipeView>);
        onPageCreate: (position: number) => Page;
        pageCount: number;
        pagerAdapter: {
            notifyDataSetChanged: () => void;
        };
        page: Page;
        pages: Page[];
        onPageSelected: (index: number, page: Page) => void;
        onPageScrolled: (index: number, offset: number) => void;
        onStateChanged: (state: SwipeViewState) => void;
        currentIndex: number;
        pagingEnabled: boolean;
        swipeToIndex(index: number, animated: boolean): void;
        overScrollMode: OverScrollMode;
        static State: SwipeViewState;
    }
    const SwipeView: typeof AbstractSwipeView;
    type SwipeView = ISwipeView;
    export default SwipeView;
}
declare module "ui/swipeview/swipeview.android" {
    import { ISwipeView, SwipeViewState } from "ui/swipeview/index";
    import Page from "ui/page/index";
    import PageAndroid from "ui/page/page.android";
    import { ViewAndroid } from "ui/view/view.android";
    import { SwipeViewEvents } from "ui/swipeview/swipeview-events";
    export default class SwipeViewAndroid<TEvent extends string = SwipeViewEvents, TNative = any, TProps extends ISwipeView = ISwipeView> extends ViewAndroid<TEvent | SwipeViewEvents, TNative, TProps> implements ISwipeView {
        onPageSelected: (index: number, page: PageAndroid) => void;
        onPageScrolled: (index: number, offset: number) => void;
        onStateChanged: (state: SwipeViewState) => void;
        onPageCreate: (position: number) => PageAndroid;
        swipeToIndex(index: number, animated: boolean): void;
        private _page;
        private _pages;
        private _lastIndex;
        private _pageCount;
        private _pageInstances;
        private _callbackOnPageSelected;
        private _callbackOnPageStateChanged;
        private _callbackOnPageScrolled;
        private _onPageCreateCallback;
        constructor(params?: TProps);
        private getPageInstance;
        private getAndroidProps;
        private bypassPageSpecificProperties;
        pagerAdapter: any;
        get page(): PageAndroid<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", __SF_UIViewController, import("ui/page").IPage<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", import("core/native-mobile-component").MobileOSProps<import("ui/page").PageIOSParams, import("ui/page").PageAndroidParams>, any>>;
        set page(value: PageAndroid<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", __SF_UIViewController, import("ui/page").IPage<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", import("core/native-mobile-component").MobileOSProps<import("ui/page").PageIOSParams, import("ui/page").PageAndroidParams>, any>>);
        get pages(): Page[];
        set pages(value: Page[]);
        get pageCount(): number;
        set pageCount(value: number);
        get currentIndex(): any;
        get pagingEnabled(): any;
        set pagingEnabled(value: any);
        static State: SwipeViewState & typeof ViewAndroid.State;
    }
}
declare module "ui/swipeview/swipeview.ios" {
    import { ISwipeView, SwipeViewState } from "ui/swipeview/index";
    import Page from "ui/page/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import ViewIOS from "ui/view/view.ios";
    import { SwipeViewEvents } from "ui/swipeview/swipeview-events";
    import PageIOS from "ui/page/page.ios";
    export default class SwipeViewIOS<TEvent extends string = SwipeViewEvents, TNative = any, TProps extends ISwipeView = ISwipeView> extends ViewIOS<TEvent | SwipeViewEvents, TNative, TProps> implements ISwipeView {
        private _currentIndex;
        private _page;
        private currentState;
        private pageController;
        private transactionIndex;
        private pendingViewControllerIndex;
        private previousViewControllerIndex;
        private pageControllerDatasource;
        private _pageArray;
        private _instanceArray;
        private _pageNativeObjectArray;
        private _pagingEnabled;
        private _isPageTransaction;
        private pageControllerDelegate;
        overScrollMode: OverScrollMode;
        constructor(params?: TProps);
        onPageSelected: (index: number, page: Page) => void;
        onPageScrolled: (index: number, offset: number) => void;
        onStateChanged: (state: SwipeViewState) => void;
        onPageCreate: (position: number) => Page;
        pageCount: number;
        pagerAdapter: {
            notifyDataSetChanged: () => void;
        };
        private setPageControllerDataSource;
        swipeToIndex(value: number, animated: boolean): void;
        private setViewControllerDelegate;
        private setPageController;
        private onPageSelectedHandler;
        private onStateChangedHandler;
        get pages(): any[];
        set pages(value: any[]);
        get page(): PageIOS<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", __SF_UIViewController, import("ui/page").IPage<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", import("core/native-mobile-component").MobileOSProps<import("ui/page").PageIOSParams, import("ui/page").PageAndroidParams>, any>>;
        set page(value: PageIOS<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", __SF_UIViewController, import("ui/page").IPage<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", import("core/native-mobile-component").MobileOSProps<import("ui/page").PageIOSParams, import("ui/page").PageAndroidParams>, any>>);
        get currentIndex(): number;
        get width(): ISwipeView['width'];
        set width(value: ISwipeView['width']);
        get height(): ISwipeView['height'];
        set height(value: ISwipeView['height']);
        get pagingEnabled(): boolean;
        set pagingEnabled(value: boolean);
        static State: typeof SwipeViewState;
    }
}
declare module "ui/switch/switch-events" {
    export const SwitchEvents: {
        readonly ToggleChanged: "toggleChanged";
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
    };
    export type SwitchEvents = ExtractValues<typeof SwitchEvents>;
}
declare module "ui/switch/index" {
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import Image from "ui/image/index";
    import { AbstractView, IView } from "ui/view/index";
    import { SwitchEvents } from "ui/switch/switch-events";
    export type SwitchAndroidProps = IView['android'] & {
        /**
         * Gets/sets color of the thumb when Switch is OFF.
         * It is set to gray by default.
         * thumbOffColor deprecated 1.1.8 use android.thumbOffColor instead.
         *
         * @property {UI.Color} thumbOffColor
         * @android
         * @since 1.1.8
         */
        thumbOffColor?: Color;
        /**
         * Gets/sets the toggle image of the switch. This property should be used before assigning colors.
         *
         * @property {UI.Color | String} toggleImage
         * @android
         * @since 3.2.1
         */
        toggleImage: Image | string;
        /**
         * Gets/sets the thumb image of the switch. This property should be used before assigning colors.
         *
         * @property {UI.Color | String} thumbImage
         * @android
         * @since 3.2.1
         */
        thumbImage: Image | string;
        /**
         * Gets/sets the background of the switch when it is OFF.  It is set to gray
         * by default. This property works only for Android.
         *
         *     @example
         *     const Switch = require('@smartface/native/ui/switch');
         *     const Color = require('@smartface/native/ui/color');
         *     var mySwitch = new Switch();
         *     mySwitch.android.toggleOffColor = Color.DARKGRAY;
         *
         * @property {UI.Color} toggleOffColor
         * @android
         * @since 0.1
         */
        toggleOffColor: Color;
    };
    type SwitchIOSProps = IView['ios'];
    export interface ISwitch<TEvent extends string = SwitchEvents, TProps extends MobileOSProps<SwitchIOSProps, SwitchAndroidProps> = MobileOSProps<SwitchIOSProps, SwitchAndroidProps>> extends IView<TEvent | SwitchEvents, any, TProps> {
        /**
         * Enables/disables the Switch.
         *
         *     @example
         *     const Switch = require('@smartface/native/ui/switch');
         *     var mySwitch = new Switch();
         *     mySwitch.enabled = false;
         *
         * @since 1.1.8
         * @property {Boolean} [enabled = true]
         * @android
         * @ios
         */
        enabled: boolean;
        /**
         * Gets/sets color of the thumb when Switch is ON. If this is set on iOS, the switch grip will lose its drop shadow.
         * The default of this property is green on Android and null on iOS. For iOS, If you want to use default of this property, you should set null.
         *
         * @property {UI.Color} thumbOnColor
         * @android
         * @ios
         * @since 0.1
         */
        thumbOnColor: Color;
        /**
         * Gets/sets color of the thumb when Switch is OFF.
         * It is set to gray by default.
         *
         * @property {UI.Color} thumbOffColor
         * @android
         * @since 0.1
         */
        thumbOffColor: Color;
        /**
         * Gets/sets toggle value of Switch. When Switch is ON,
         * the value of this property will be true. It is set to false by default.
         *
         * @property {Boolean} toggle
         * @android
         * @ios
         * @since 0.1
         */
        toggle: boolean;
        /**
         * Gets/sets the background of the switch when it is ON.
         * The default of this property is gray on Android and green on iOS.
         *
         * @property {UI.Color} toggleOnColor
         * @android
         * @ios
         * @since 0.1
         */
        toggleOnColor: Color;
        /**
         * This event is called when the state of switch changes from ON to OFF or vice versa.
         *
         * @event onToggleChanged
         * @param {Boolean} state
         * @deprecated
         * @android
         * @ios
         * @since 0.1
         * @example
         * ````
         * import Switch from '@smartface/native/ui/switch';
         *
         * const switch = new Switch();
         * switch.on(Switch.Events.ToggleChanged, (params) => {
         *  console.info('onToggleChanged', params);
         * });
         * ````
         */
        onToggleChanged: (toggle: boolean) => void;
    }
    export class AbstractSwitch<TEvent extends string = SwitchEvents> extends AbstractView<TEvent, any, ISwitch> implements ISwitch<TEvent> {
        get enabled(): boolean;
        set enabled(value: boolean);
        get thumbOnColor(): Color;
        set thumbOnColor(value: Color);
        get thumbOffColor(): Color;
        set thumbOffColor(value: Color);
        get toggle(): boolean;
        set toggle(value: boolean);
        get toggleOnColor(): Color;
        set toggleOnColor(value: Color);
        get onToggleChanged(): (toggle: boolean) => void;
        set onToggleChanged(value: (toggle: boolean) => void);
    }
    const Switch: typeof AbstractSwitch;
    type Switch = AbstractSwitch;
    export default Switch;
}
declare module "ui/switch/switch.android" {
    import { ISwitch } from "ui/switch/index";
    import Color from "ui/color/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { SwitchEvents } from "ui/switch/switch-events";
    export default class SwitchAndroid<TEvent extends string = SwitchEvents> extends ViewAndroid<TEvent | SwitchEvents, any, ISwitch> {
        private _thumbOnColor;
        private _thumbOffColor;
        private _toggleOnColor;
        private _toggleOffColor;
        private _toggleImage;
        private _thumbImage;
        private _onToggleChangedCallback;
        constructor(params?: Partial<ISwitch>);
        get thumbOnColor(): Color;
        set thumbOnColor(value: Color);
        get thumbOffColor(): Color;
        set thumbOffColor(value: Color);
        get toggle(): boolean;
        set toggle(value: boolean);
        get toggleOnColor(): Color;
        set toggleOnColor(value: Color);
        get onToggleChanged(): (toggle: boolean) => void;
        set onToggleChanged(value: (toggle: boolean) => void);
        setThumbColor(): void;
        setTrackColor(): void;
    }
}
declare module "ui/switch/switch.ios" {
    import { ISwitch } from "ui/switch/index";
    import Color from "ui/color/index";
    import ViewIOS from "ui/view/view.ios";
    import { SwitchEvents } from "ui/switch/switch-events";
    export default class SwitchIOS<TEvent extends string = SwitchEvents> extends ViewIOS<TEvent | SwitchEvents, __SF_UISwitch, ISwitch> {
        private _toggleOnColor;
        private _onToggleChanged;
        constructor(params?: Partial<ISwitch>);
        get enabled(): boolean;
        set enabled(value: boolean);
        get thumbOnColor(): Color | null;
        set thumbOnColor(value: Color | undefined | null);
        thumbOffColor: Color;
        get toggle(): boolean;
        set toggle(value: boolean);
        get toggleOnColor(): Color;
        set toggleOnColor(value: Color);
        get onToggleChanged(): (toggle: boolean) => void;
        set onToggleChanged(value: (toggle: boolean) => void);
    }
}
declare module "ui/tabbarcontroller/tabbarcontroller.android" {
    import { ITabBarController } from "ui/tabbarcontroller/index";
    import Color from "ui/color/index";
    import type Page from "ui/page/index";
    import PageAndroid from "ui/page/page.android";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import { ITabbarItem } from "ui/tabbaritem/index";
    import { TabBarControllerEvents } from "ui/tabbarcontroller/tabbarcontroller-events";
    export default class TabBarControllerAndroid<TEvent extends string = TabBarControllerEvents> extends PageAndroid<TEvent | TabBarControllerEvents, any, ITabBarController> implements ITabBarController {
        private _onSelectedCallback;
        private _onPageCreateCallback;
        private _items;
        private _barColor;
        private _indicatorColor;
        private _textColor;
        private _iconColor;
        private _overScrollMode;
        private _scrollEnabled;
        private _dividerWidth;
        private _dividerPadding;
        private _dividerColor;
        private _indicatorHeight;
        private _autoCapitalize;
        private tabLayout;
        private divider;
        private swipeView;
        private dividerDrawable;
        constructor(params?: Partial<ITabBarController>);
        dividerColor: Color;
        dividerPadding: number;
        dividerWidth: number;
        get barHeight(): number;
        set barHeight(value: number);
        get items(): ITabbarItem[];
        set items(value: ITabbarItem[]);
        get indicatorColor(): Color;
        set indicatorColor(value: Color);
        get autoCapitalize(): boolean;
        set autoCapitalize(value: boolean);
        get indicatorHeight(): number;
        set indicatorHeight(value: number);
        overScrollMode: OverScrollMode;
        get barColor(): Color;
        set barColor(value: Color);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get selectedIndex(): number;
        setSelectedIndex(index: number, animated: boolean): void;
        get iconColor(): Color | {
            normal: Color;
            selected: Color;
        };
        set iconColor(value: Color | {
            normal: Color;
            selected: Color;
        });
        get textColor(): Color | {
            normal: Color;
            selected: Color;
        };
        set textColor(value: Color | {
            normal: Color;
            selected: Color;
        });
        get pagingEnabled(): boolean;
        set pagingEnabled(value: boolean);
        get onPageCreate(): (index: number) => Page;
        set onPageCreate(value: (index: number) => Page);
        get onSelected(): (index: number) => void;
        set onSelected(value: (index: number) => void);
        setAllCaps(itemArray: any[], nativeTabLayout: any, autoCapitalize: boolean): void;
        createDividerDrawableIfNeeded(): void;
    }
}
declare module "ui/tabbarcontroller/tabbarcontroller.ios" {
    import { BarTextTransform, ITabBarController, LargeTitleDisplayMode, PresentationStyle } from "ui/tabbarcontroller/index";
    import OverScrollMode from "ui/shared/android/overscrollmode";
    import Color from "ui/color/index";
    import Page from "ui/page/index";
    import PageIOS from "ui/page/page.ios";
    import { ITabbarItem } from "ui/tabbaritem/index";
    import { TabBarControllerEvents } from "ui/tabbarcontroller/tabbarcontroller-events";
    export default class TabBarControllerIOS<TEvent extends string = TabBarControllerEvents> extends PageIOS<TEvent | TabBarControllerEvents, any, ITabBarController> implements ITabBarController {
        static iOS: {
            BarTextTransform: typeof BarTextTransform;
            LargeTitleDisplayMode: typeof LargeTitleDisplayMode;
            PresentationStyle: typeof PresentationStyle;
        };
        private _items;
        private _autoCapitalize;
        private _iconColor;
        private _textColor;
        private _onPageCreate;
        private _onSelected;
        private iOSProps;
        constructor(params?: Partial<ITabBarController>);
        get barHeight(): number;
        get items(): ITabbarItem[];
        set items(value: ITabbarItem[]);
        dividerColor: Color;
        dividerPadding: number;
        dividerWidth: number;
        get indicatorColor(): Color;
        set indicatorColor(value: Color);
        get autoCapitalize(): boolean;
        set autoCapitalize(value: boolean);
        get indicatorHeight(): number;
        set indicatorHeight(value: number);
        overScrollMode: OverScrollMode;
        get barColor(): Color;
        set barColor(value: Color);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get selectedIndex(): number;
        setSelectedIndex(index: number, animated: boolean): void;
        get iconColor(): {
            normal: Color;
            selected: Color;
        } | Color;
        set iconColor(value: {
            normal: Color;
            selected: Color;
        } | Color);
        get textColor(): {
            normal: Color;
            selected: Color;
        } | Color;
        set textColor(value: {
            normal: Color;
            selected: Color;
        } | Color);
        get pagingEnabled(): boolean;
        set pagingEnabled(value: boolean);
        get onPageCreate(): (index: number) => Page;
        set onPageCreate(value: (index: number) => Page);
        get onSelected(): (index: number) => void;
        set onSelected(value: (index: number) => void);
    }
}
declare module "ui/tabbaritem/tabbaritem.android" {
    import { ITabbarItem } from "ui/tabbaritem/index";
    import { NativeMobileComponent } from "core/native-mobile-component";
    import Image from "ui/image/index";
    import { IPage } from "ui/page/index";
    export default class TabbarItemAndroid extends NativeMobileComponent<any, ITabbarItem> implements ITabbarItem {
        private _title;
        private _icon;
        private _badgeObj;
        private _systemIcon;
        private _tabBarItemParent;
        private index;
        private badgeAdded;
        private _attributedTitle?;
        private _route;
        constructor(params?: Partial<ITabbarItem>);
        invalidate(): void;
        get tabBarItemParent(): IPage<"show" | "load" | "hide" | "orientationChange" | "safeAreaPaddingChange", import("core/native-mobile-component").MobileOSProps<import("ui/page").PageIOSParams, import("ui/page").PageAndroidParams>, any> | null;
        get title(): string;
        set title(value: string);
        get route(): string;
        set route(value: string);
        get icon(): {
            normal: Image | string;
            selected: Image | string;
        } | Image | string;
        set icon(value: {
            normal: Image | string;
            selected: Image | string;
        } | Image | string);
        get badge(): import("ui/badge").IBadge;
        titleSetter(title: string): void;
        makeSelector(normalImage: Image, selectedImage: Image): {
            nativeObject: any;
        };
        setBadgeToTabarItem(badgeObj: any): void;
        toString(): string;
        setProperties(params: {
            itemTitle: string;
            itemIcon: Image;
            systemIcon: string | number;
        }): void;
    }
}
declare module "ui/tabbaritem/tabbaritem.ios" {
    import { ITabbarItem } from "ui/tabbaritem/index";
    import { NativeMobileComponent } from "core/native-mobile-component";
    import { IBadge } from "ui/badge/index";
    import Image from "ui/image/index";
    import { IPage } from "ui/page/index";
    export default class TabbarItemIOS extends NativeMobileComponent<any, ITabbarItem> implements ITabbarItem {
        private _nativeView;
        private _title;
        private _icon;
        private _badge;
        private _route;
        constructor(params?: Partial<TabbarItemIOS>);
        setProperties(params: {
            itemTitle: string;
            itemIcon: string | {
                normal: string | Image;
                selected: string | Image;
            } | Image;
            systemIcon?: string | number | undefined;
        }): void;
        tabBarItemParent: IPage | null;
        get android(): Partial<{
            attributedTitle: import("global/attributedstring/attributedstring").IAttributedString;
            systemIcon: string | number;
        }>;
        get route(): string;
        set route(value: string);
        get layout(): any;
        get title(): string;
        set title(title: string);
        get icon(): {
            normal: Image | string;
            selected: Image | string;
        } | Image | string;
        set icon(icon: {
            normal: Image | string;
            selected: Image | string;
        } | Image | string);
        get badge(): IBadge;
        getScreenLocation(): any;
        invalidate(): void;
    }
}
declare module "ui/textarea/textarea-events" {
    export const TextAreaEvents: any;
    export type TextAreaEvents = ExtractValues<typeof TextAreaEvents>;
}
declare module "ui/textarea/index" {
    import { ITextBox, TextBoxAndroidProps, TextBoxiOSProps } from "ui/textbox/index";
    import { TextAreaEvents } from "ui/textarea/textarea-events";
    import { ConstructorOf } from "core/constructorof";
    import { MobileOSProps } from "core/native-mobile-component";
    export type TextareaiOSProps = TextBoxiOSProps & {
        /**
         * Get/set showScrollBar property
         *
         * @property {Boolean} [showScrollBar = false]
         * @ios
         * @since 1.1.10
         */
        showScrollBar: boolean;
        clearButtonEnabled: boolean;
    };
    export type TextareaAndroidProps = TextBoxAndroidProps & {
        /**
         * Gets/sets hint text that will be displayed when TextBox is empty.
         *
         * @property {String} [hint = ""]
         * @android
         * @since 1.1.10
         */
        hint: string;
    };
    export interface ITextArea<TEvent extends string = TextAreaEvents, TProps extends MobileOSProps<TextareaiOSProps, TextareaAndroidProps> = MobileOSProps<TextareaiOSProps, TextareaAndroidProps>> extends ITextBox<TEvent | TextAreaEvents, TProps> {
        /**
         * Sets/Gets the bounce effect when scrolling.
         *
         * @property {Boolean} bounces
         * @ios
         * @since 3.2.1
         */
        bounces: boolean;
    }
    /**
     * @class UI.TextArea
     * @since 1.1.10
     * @extends UI.TextBox
     * TextArea is a UI which users can edit the multiline text.
     *
     *     @example
     *     import TextArea from '@smartface/native/ui/textarea';
     *     const myTextArea= new TextArea({
     *         left:10, top:10, width:200, height:200,
     *         borderWidth: 1
     *     });
     *     myPage.layout.addChild(myTextArea);
     *
     */
    const TextArea: ConstructorOf<ITextArea, Partial<ITextArea>>;
    type TextArea = ITextArea;
    export default TextArea;
}
declare module "ui/textarea/textarea.android" {
    import { ITextArea } from "ui/textarea/index";
    import ActionKeyType from "ui/shared/android/actionkeytype";
    import KeyboardType from "ui/shared/keyboardtype";
    import TextBoxAndroid from "ui/textbox/textbox.android";
    import { TextAreaEvents } from "ui/textarea/textarea-events";
    export default class TextAreaAndroid<TEvent extends string = TextAreaEvents, TNative = any, TProps extends ITextArea = ITextArea> extends TextBoxAndroid<TEvent | TextAreaEvents, TNative, TProps> implements ITextArea<TEvent> {
        private _bounces;
        private __hint;
        private __actionKeyType;
        private __keyboardType;
        private __isPassword;
        private __onActionButtonPress;
        constructor(params: Partial<TProps>);
        get isPassword(): boolean;
        set isPassword(value: boolean);
        get actionKeyType(): ActionKeyType;
        set actionKeyType(value: ActionKeyType);
        get keyboardType(): KeyboardType;
        set keyboardType(value: KeyboardType);
        get hint(): string;
        set hint(value: string);
        get bounces(): boolean;
        set bounces(value: boolean);
        get onActionButtonPress(): ITextArea['onActionButtonPress'];
        set onActionButtonPress(value: ITextArea['onActionButtonPress']);
    }
}
declare module "ui/textarea/textarea.ios" {
    import { ITextArea, TextareaiOSProps } from "ui/textarea/index";
    import ActionKeyType from "ui/shared/android/actionkeytype";
    import KeyboardType from "ui/shared/keyboardtype";
    import TextAlignment from "ui/shared/textalignment";
    import TextBoxIOS from "ui/textbox/textbox.ios";
    import { TextAreaEvents } from "ui/textarea/textarea-events";
    export default class TextAreaIOS<TEvent extends string = TextAreaEvents, TNative = __SF_UITextView, TProps extends ITextArea = ITextArea> extends TextBoxIOS<TEvent | TextAreaEvents, TNative, TProps> implements ITextArea<TEvent> {
        private _bounces;
        private __hint;
        private _actionKeyType;
        private _keyboardType;
        private _isPassword;
        private _adjustFontSizeToFit;
        private _minimumFontSize;
        private __clearButtonEnabled;
        constructor(params?: Partial<TProps>);
        enabled?: boolean;
        get iosProps(): TextareaiOSProps;
        get bounces(): boolean;
        set bounces(value: boolean);
        get textAlignment(): TextAlignment;
        set textAlignment(value: TextAlignment);
        get hint(): string;
        set hint(value: string);
        get actionKeyType(): ActionKeyType;
        set actionKeyType(value: ActionKeyType);
        get keyboardType(): KeyboardType;
        set keyboardType(value: KeyboardType);
        get isPassword(): boolean;
        set isPassword(value: boolean);
    }
}
declare module "ui/textview/textview.android" {
    import { ITextView } from "ui/textview/index";
    import { Size } from "primitive/size";
    import LabelAndroid from "ui/label/label.android";
    import { TextViewEvents } from "ui/textview/textview-events";
    export default class TextViewAndroid<TEvent extends TextViewEvents, TProps extends ITextView = ITextView> extends LabelAndroid<TEvent | TextViewEvents, any, TProps> implements ITextView {
        private _attributedStringBuilder;
        private _attributedStringArray;
        private _onLinkClick;
        private _letterSpacing;
        private _lineSpacing;
        private _scrollEnabled;
        private _htmlText;
        private linkMovementMethodCreated;
        private scrollableMovementMethodCreated;
        constructor(params?: Partial<TProps>);
        get htmlText(): ITextView['htmlText'];
        set htmlText(value: ITextView['htmlText']);
        get maxLines(): ITextView['maxLines'];
        set maxLines(value: ITextView['maxLines']);
        get selectable(): boolean;
        set selectable(value: boolean);
        get attributedText(): ITextView['attributedText'];
        set attributedText(value: ITextView['attributedText']);
        getAttributeTextSize(maxWidth: number): Size | null;
        get onLinkClick(): ITextView['onLinkClick'];
        set onLinkClick(value: ITextView['onLinkClick']);
        get letterSpacing(): ITextView['letterSpacing'];
        set letterSpacing(value: ITextView['letterSpacing']);
        get lineSpacing(): ITextView['lineSpacing'];
        set lineSpacing(value: ITextView['lineSpacing']);
        get textAlignment(): ITextView['textAlignment'];
        set textAlignment(value: ITextView['textAlignment']);
        get scrollEnabled(): ITextView['scrollEnabled'];
        set scrollEnabled(value: ITextView['scrollEnabled']);
        private enableScrollable;
    }
}
declare module "ui/textview/textview.ios" {
    import LabelIOS from "ui/label/label.ios";
    import { ITextView } from "ui/textview/index";
    import { Size } from "primitive/size";
    import { TextViewEvents } from "ui/textview/textview-events";
    export default class TextViewIOS<TEvent extends TextViewEvents, TProps extends ITextView = ITextView> extends LabelIOS<TEvent | TextViewEvents, any, TProps> implements ITextView<TEvent | TextViewEvents> {
        private _lastModifiedAttributedString;
        private __attributedText;
        private _letterSpacing;
        private _lineSpacing;
        private _onLinkClick;
        private _selectable;
        constructor(params?: Partial<ITextView>);
        getAttributeTextSize(maxWidth: number): Size | null;
        private assignIOSSpecificParameters;
        set onLinkClick(value: ITextView['onLinkClick']);
        get onLinkClick(): ITextView['onLinkClick'];
        get letterSpacing(): ITextView['letterSpacing'];
        set letterSpacing(value: ITextView['letterSpacing']);
        get lineSpacing(): ITextView['letterSpacing'];
        set lineSpacing(value: ITextView['letterSpacing']);
        get attributedText(): ITextView['attributedText'];
        set attributedText(value: ITextView['attributedText']);
        get selectable(): ITextView['selectable'];
        set selectable(value: ITextView['selectable']);
        get htmlText(): ITextView['htmlText'];
        set htmlText(value: ITextView['htmlText']);
        get scrollEnabled(): boolean;
        set scrollEnabled(value: boolean);
        get font(): ITextView['font'];
        set font(value: ITextView['font']);
        get text(): ITextView['text'];
        set text(value: ITextView['text']);
        get textAlignment(): ITextView['textAlignment'];
        set textAlignment(value: ITextView['textAlignment']);
        get textColor(): ITextView['textColor'];
        set textColor(value: ITextView['textColor']);
        get ellipsizeMode(): ITextView['ellipsizeMode'];
        set ellipsizeMode(value: ITextView['ellipsizeMode']);
        get maxLines(): ITextView['maxLines'];
        set maxLines(value: ITextView['maxLines']);
        private setText;
    }
}
declare module "ui/timepicker/timepicker-events" {
    export const TimePickerEvents: {
        readonly Selected: "selected";
    };
    export type TimePickerEvents = ExtractValues<typeof TimePickerEvents>;
}
declare module "ui/timepicker/index" {
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { TimePickerEvents } from "ui/timepicker/timepicker-events";
    import { ConstructorOf } from "core/constructorof";
    /**
     * @class UI.TimePicker
     * @since 0.1
     *
     * TimePicker is a dialog where users are able to select the time.
     *
     *     @example
     *     import TimePicker from '@smartface/native/ui/timepicker';
     *     const myTimePicker = new TimePicker();
     *     myTimePicker.onTimeSelected = (time) => {
     *         console.log('Hour: ' + time.hour + ' Minute: ' + time.minute);
     *     };
     *     myTimePicker.android.is24HourFormat = false;
     *     myTimePicker.show();
     *
     */
    export interface ITimePicker<TEvent extends string = TimePickerEvents> extends NativeEventEmitterComponent<TEvent> {
        /**
         * Sets the time avaliable on the picker.
         *
         * @method setTime
         * @android
         * @ios
         * @param {Object} time
         * @param {Number} time.hour
         * @param {Number} time.minute
         * @since 0.1
         */
        setTime(params: {
            hour: number;
            minute: number;
        }): void;
        /**
         * Sets whether time is 24-hour or AM/PM mode.
         *
         * @property {Boolean} is24HourFormat
         * @android
         * @since 0.1
         */
        is24HourFormat: boolean;
        /**
         * Makes the picker appear on the screen.
         *
         * @method show
         * @android
         * @ios
         * @since 0.1
         */
        show(): void;
        /**
         * Triggered when a time is selected on the picker.
         *
         * @since 0.1
         * @param {Object} time
         * @param {Number} time.hour
         * @param {Number} time.minute
         * @deprecated
         * @event onTimeSelected
         * @android
         * @ios
         * @example
         * ````
         * import TimePicker from '@smartface/native/ui/timepicker';
         *
         * const timePicker = new TimePicker();
         * timePicker.on(TimePicker.Events.Selected, (params) => {
         *  console.info('onTimeSelected', params);
         * });
         * ````
         */
        onTimeSelected: (e: {
            hour: number;
            minute: number;
        }) => void;
    }
    const TimePicker: ConstructorOf<ITimePicker, Partial<ITimePicker>>;
    type TimePicker = ITimePicker;
    export default TimePicker;
}
declare module "ui/timepicker/timepicker.android" {
    import { ITimePicker } from "ui/timepicker/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { TimePickerEvents } from "ui/timepicker/timepicker-events";
    export default class TimePickerAndroid<TEvent extends string = TimePickerEvents> extends NativeEventEmitterComponent<TEvent | TimePickerEvents> implements ITimePicker<TEvent | TimePickerEvents> {
        private _is24HourFormat;
        private _onTimeSelected;
        private _hour;
        private _minutes;
        constructor(params?: Partial<ITimePicker>);
        setTime(params: {
            hour: number;
            minute: number;
        }): void;
        show(): void;
        get onTimeSelected(): ITimePicker['onTimeSelected'];
        set onTimeSelected(value: ITimePicker['onTimeSelected']);
        get is24HourFormat(): boolean;
        set is24HourFormat(value: boolean);
        get hour(): number | null;
        set hour(value: number | null);
        get minutes(): number | null;
        set minutes(value: number | null);
        private createTimerDialog;
    }
}
declare module "ui/timepicker/timepicker.ios" {
    import { ITimePicker } from "ui/timepicker/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { TimePickerEvents } from "ui/timepicker/timepicker-events";
    export default class TimePickerIOS<TEvent extends string = TimePickerEvents> extends NativeEventEmitterComponent<TEvent | TimePickerEvents> implements ITimePicker<TEvent | TimePickerEvents> {
        private _hours;
        private _minutes;
        constructor(params?: Partial<ITimePicker>);
        setTime(params: {
            hour: number;
            minute: number;
        }): void;
        is24HourFormat: boolean;
        show(): void;
        onTimeSelected: (e: {
            hour: number;
            minute: number;
        }) => void;
    }
}
declare module "ui/toast/toast-events" {
    export const ToastEvents: {
        readonly Dismissed: "dismissed";
    };
    export type ToastEvents = ExtractValues<typeof ToastEvents>;
}
declare module "ui/toast/index" {
    import { ConstructorOf } from "core/constructorof";
    import { IEventEmitter } from "core/eventemitter/index";
    import { INativeComponent } from "core/inative-component";
    import Color from "ui/color/index";
    import { ToastEvents } from "ui/toast/toast-events";
    /**
     * @since 4.4.1
     * Toast provide brief messages about app processes at the bottom of the screen.
     *
     *     @example
     *     import Toast from '@smartface/native/ui/toast';
     *     const myToastMessage = new Toast({
     *         message: "This is a toast message",
     *         actionTextColor: Color.YELLOW,
     *         bottomOffset: 200,
     *         duration: 5
     *     });
     *     myToastMessage.createAction("Action Title", () => {console.log("Action Pressed!")})
     *     myToastMessage.show();
     *
     */
    export interface IToast<TEvent extends string = ToastEvents> extends INativeComponent, IEventEmitter<TEvent | ToastEvents> {
        /**
         * Gets/sets the message of toast.
         * @android
         * @ios
         * @since 4.4.1
         */
        set message(value: string);
        get message(): string;
        /**
         * Gets/sets the background of toast message view.
         * @android
         * @ios
         * @since 4.4.1
         */
        set backgroundColor(value: Color);
        get backgroundColor(): Color;
        /**
         * Gets/sets the actionTextColor of toast action text.
         * @android
         * @ios
         * @since 4.4.1
         */
        set actionTextColor(value: Color);
        get actionTextColor(): Color;
        /**
         * Gets/sets the messageTextColor of toast message text.
         * @android
         * @ios
         * @since 4.4.1
         */
        set messageTextColor(value: Color);
        get messageTextColor(): Color;
        /**
         * Gets/sets the bottom offset of toast message view from bottom.
         * @android
         * @ios
         * @since 4.4.1
         */
        set bottomOffset(value: number);
        get bottomOffset(): number;
        /**
         * Gets/sets how long it will stay on the screen. Value can bet set between 1 - 10 as integer
         * @android
         * @ios
         * @since 4.4.1
         */
        set duration(value: number);
        get duration(): number;
        /**
         * Gets status of the toast. Returns true if the toast is currently displayed on the screen.
         * @android
         * @ios
         * @since 4.4.1
         */
        get isShowing(): boolean;
        /**
         * Add an action to toast.
         * @param {String} title of action.
         * @android
         * @ios
         * @since 4.4.1
         */
        createAction(title: string, callback: () => void): void;
        /**
         * This function called when displayed toast dismissed.
         * @param {void} callback function called when toast dismissed.
         * @android
         * @ios
         * @since 4.4.1
         */
        onDismissed: (callback: void) => void;
        /**
         *  This method shows the toast on the screen.
         * @android
         * @ios
         * @since 4.4.1
         */
        show(): void;
        /**
         * Dismisses the Toast, isShowing property set to false after this operation.
         * @android
         * @ios
         * @since 4.4.1
         */
        dismiss(): void;
    }
    const Toast: ConstructorOf<IToast, Partial<IToast>>;
    type Toast = IToast;
    export default Toast;
}
declare module "ui/toast/toast.android" {
    import { IToast } from "ui/toast/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import { ToastEvents } from "ui/toast/toast-events";
    export default class ToastAndroid<TEvent extends string = ToastEvents, TProps extends MobileOSProps<{}, {}> = MobileOSProps<{}, {}>> extends NativeEventEmitterComponent<TEvent | ToastEvents, any, TProps> implements IToast {
        private _message;
        private _messageTextColor;
        private _actionTextColor;
        private _backgroundColor;
        private _bottomOffset;
        constructor(params?: TProps);
        set message(value: string);
        get message(): string;
        set backgroundColor(value: Color);
        get backgroundColor(): Color;
        set actionTextColor(value: Color);
        get actionTextColor(): Color;
        set messageTextColor(value: Color);
        get messageTextColor(): Color;
        set bottomOffset(value: number);
        get bottomOffset(): number;
        set duration(value: number);
        get duration(): number;
        get isShowing(): boolean;
        createAction(title: string, callback: () => void): void;
        onDismissed: (callback: void) => void;
        show(): void;
        dismiss(): void;
        private convertToMiliSeconds;
        private convertToSeconds;
        private createNativeSnackBar;
    }
}
declare module "ui/toast/toast.ios" {
    import { IToast } from "ui/toast/index";
    import NativeEventEmitterComponent from "core/native-event-emitter-component";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    import { ToastEvents } from "ui/toast/toast-events";
    export default class ToastIOS<TEvent extends string = ToastEvents, TProps extends MobileOSProps<{}, {}> = MobileOSProps<{}, {}>> extends NativeEventEmitterComponent<TEvent | ToastEvents, __SF_Snackbar, TProps> implements IToast {
        private _bottomOffset;
        constructor(params?: TProps);
        set message(value: string);
        get message(): string;
        set backgroundColor(value: Color);
        get backgroundColor(): Color;
        set actionTextColor(value: Color);
        get actionTextColor(): Color;
        set messageTextColor(value: Color);
        get messageTextColor(): Color;
        set bottomOffset(value: number);
        get bottomOffset(): number;
        set duration(value: number);
        get duration(): number;
        get isShowing(): boolean;
        createAction(title: string, callback: () => void): void;
        onDismissed: (callback: void) => void;
        show(): void;
        dismiss(): void;
    }
}
declare module "ui/videoview/videoview-events" {
    export const VideoViewEvents: {
        readonly Touch: "touch";
        readonly TouchCancelled: "touchCancelled";
        readonly TouchEnded: "touchEnded";
        readonly TouchMoved: "touchMoved";
        /**
         * This event is called when the video clip completed playing.
         *
         * @event onFinish
         * @android
         * @ios
         * @param {Function} callback
         * @since 0.1
         */
        readonly Finish: "finish";
        /**
         * This event is called when the video clip is ready to be played.
         *
         * @event onReady
         * @android
         * @ios
         * @param {Function} callback
         * @since 0.1
         */
        readonly Ready: "ready";
        /**
         * This event is called when the video player failed.
         *
         * @event onFailure
         * @android
         * @ios
         * @param {Function} callback
         * @since 4.3.6
         */
        readonly Failure: "failure";
        /**
         * Tells the delegate when Picture in Picture is about to stop, to give your app an opportunity to restore its video playback user interface.
         *
         * @event restoreUserInterfaceForPictureInPictureStopWithCompletionHandler
         * @ios
         * @param {Function} callback
         * @param {Boolean} callback.parameter To allow the system to finish restoring your user interface, you must call the completion handler with a value of true.
         * @since 4.3.1
         */
        readonly RestoreUserInterfaceForPictureInPictureStopWithCompletionHandler: "restoreUserInterfaceForPictureInPictureStopWithCompletionHandler";
        /**
         * Picture in Picture is about to start.
         *
         * @event willStartPictureInPicture
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         */
        readonly WillStartPictureInPicture: "willStartPictureInPicture";
        /**
         * Picture in Picture is about to stop.
         *
         * @event willStopPictureInPicture
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         */
        readonly WillStopPictureInPicture: "willStopPictureInPicture";
        /**
         * Picture in Picture has started.
         *
         * @event didStartPictureInPicture
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         */
        readonly DidStartPictureInPicture: "didStartPictureInPicture";
        /**
         * Picture in Picture has stopped.
         *
         * @event didStopPictureInPicture
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         */
        readonly DidStopPictureInPicture: "didStopPictureInPicture";
        /**
         * Setting this event makes the fullscreen button appear. The event to be notified when the fullscreen button is clicked, or null to remove the current listener and hide the fullscreen button.
         *
         * @event onFullScreenModeChanged
         * @param {Function} callback
         * @param {Boolean} callback.isFullScreen true if the video rendering surface should be fullscreen false otherwise.
         * @android
         * @since 4.3.1
         */
        readonly FullScreenModeChanged: "fullScreenModeChanged";
        /**
         * The event to be notified about controller visibility changes.
         *
         * @method onControllerVisibilityChange
         * @param {Function} callback
         * @param {Boolean} callback.visible true if the controller visible, otherwise false
         * @android
         * @since 4.3.1
         */
        readonly ControllerVisibilityChange: "controllerVisibilityChange";
    };
    export type VideoViewEvents = ExtractValues<typeof VideoViewEvents>;
}
declare module "ui/videoview/index" {
    import { IView, ViewAndroidProps, ViewIOSProps } from "ui/view/index";
    import File from "io/file/index";
    import Page from "ui/page/index";
    import { ConstructorOf } from "core/constructorof";
    import { VideoViewEvents } from "ui/videoview/videoview-events";
    import { MobileOSProps } from "core/native-mobile-component";
    import Color from "ui/color/index";
    export interface IVideoViewIOSProps extends ViewIOSProps {
        /**
         * A Boolean value that determines whether the player automatically displays in full screen when the play button is tapped.
         *
         * @property {Boolean} entersFullScreenWhenPlaybackBegins
         * @ios
         * @since 4.1.4
         */
        entersFullScreenWhenPlaybackBegins: boolean;
        /**
         * A Boolean value that indicates whether the player exits full screen when playback ends.
         *
         * @property {Boolean} exitsFullScreenWhenPlaybackEnds
         * @ios
         * @since 4.1.4
         */
        exitsFullScreenWhenPlaybackEnds: boolean;
        /**
         * Picture in Picture has stopped.
         *
         * @event didStopPictureInPicture
         * @deprecated
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.DidStopPictureInPicture, () => {
         * 	console.info('didStopPictureInPicture');
         * });
         * ````
         */
        didStopPictureInPicture: () => void;
        /**
         * Picture in Picture has started.
         *
         * @event didStartPictureInPicture
         * @deprecated
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.DidStartPictureInPicture, () => {
         * 	console.info('didStartPictureInPicture');
         * });
         * ````
         */
        didStartPictureInPicture: () => void;
        /**
         * Picture in Picture is about to stop.
         *
         * @event willStopPictureInPicture
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.WillStopPictureInPicture, (params) => {
         * 	console.info('willStopPictureInPicture', params);
         * });
         * ````
         */
        willStopPictureInPicture: () => void;
        /**
         * Picture in Picture is about to start.
         *
         * @event willStartPictureInPicture
         * @deprecated
         * @ios
         * @param {Function} callback
         * @since 4.3.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.WillStartPictureInPicture, (params) => {
         * 	console.info('willStartPictureInPicture', params);
         * });
         * ````
         */
        willStartPictureInPicture: () => void;
        /**
         * Tells the delegate when Picture in Picture is about to stop, to give your app an opportunity to restore its video playback user interface.
         *
         * @event restoreUserInterfaceForPictureInPictureStopWithCompletionHandler
         * @deprecated
         * @ios
         * @param {Function} callback
         * @param {Boolean} callback.parameter To allow the system to finish restoring your user interface, you must call the completion handler with a value of true.
         * @since 4.3.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.RestoreUserInterfaceForPictureInPictureStopWithCompletionHandler, (params) => {
         * 	console.info('restoreUserInterfaceForPictureInPictureStopWithCompletionHandler', params);
         * });
         * ````
         */
        restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (callback: (parameter?: boolean) => void) => void;
        /**
         * Asks the delegate whether the player view controller should automatically dismiss when Picture in Picture starts.
         *
         * @property {Boolean} shouldAutomaticallyDismissAtPictureInPictureStart
         * @ios
         * @since 4.3.1
         */
        shouldAutomaticallyDismissAtPictureInPictureStart: boolean;
    }
    export interface IVideoViewAndroidProps extends ViewAndroidProps {
        /**
         * Enables state saving of the videoview. Saves the configuration with video's current position.
         *
         * @property  {Boolean} [stateSavingEnabled = true]
         * @android
         * @since 4.3.1
         */
        stateSavingEnabled: boolean;
        /**
         * Sets a custom error message to be displayed by the view. The error message will be displayed
         * permanently, unless it is cleared by passing null to this method.
         *
         * @property  {String} customErrorMessage
         * @android
         * @since 4.3.1
         */
        customErrorMessage: string;
        /**
         * Gets/sets background color of a view. It allows setting background
         * color with UI.Color instance.
         *
         * @property {UI.Color} backgroundColor
         * @android
         * @since 4.3.1
         */
        backgroundColor: Color;
        /**
         * Sets whether a loading indicator is displayed when the player is in the buffering state.
         * The loading indicatorr is not displayed by default.
         *
         * @property {Boolean} [loadingIndicatorEnabled = false]
         * @android
         * @since 4.3.1
         */
        loadingIndicatorEnabled: boolean;
        /**
         * Setting this event makes the fullscreen button appear. The event to be notified when the fullscreen button is clicked, or null to remove the current listener and hide the fullscreen button.
         *
         * @event onFullScreenModeChanged
         * @param {Function} callback
         * @param {Boolean} callback.isFullScreen true if the video rendering surface should be fullscreen false otherwise.
         * @android
         * @since 4.3.1
         */
        onFullScreenModeChanged: (isFullScreen: boolean) => void;
        /**
         * Sets whether the next button is shown.
         *
         * @property {Boolean} [nextButtonEnabled = true]
         * @android
         * @since 4.3.1
         */
        nextButtonEnabled: boolean;
        /**
         * Sets whether the fast forward button is shown.
         *
         * @property {Boolean} [fastForwardButtonEnabled = true]
         * @android
         * @since 4.3.1
         */
        fastForwardButtonEnabled: boolean;
        /**
         * Sets whether the rewind button is shown.
         *
         * @property {Boolean} [rewindButtonEnabled = true]
         * @android
         * @since 4.3.1
         */
        rewindButtonEnabled: boolean;
        /**
         * Sets whether the previous button is shown.
         *
         * @property {Boolean} [previousButtonEnabled = true]
         * @android
         * @since 4.3.1
         */
        previousButtonEnabled: boolean;
        /**
         * Sets the controller timeout. The controller is automatically hidden after this
         * duration of time has elapsed without user input and with playback or loading in progress.
         *
         * @property {Number} controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause the  ontroller to remain visible indefinitely.
         * @android
         * @since 4.3.1
         */
        controllerShowTimeoutMs: number;
        /**
         * The event to be notified about controller visibility changes.
         *
         * @method onControllerVisibilityChange
         * @param {Function} callback
         * @param {Boolean} callback.visible true if the controller visible, otherwise false
         * @android
         * @since 4.3.1
         */
        onControllerVisibilityChange: (visible: boolean) => void;
        /**
         * Sets controller visibility.
         *
         * @property {Boolean} showController
         * @android
         * @since 4.3.1
         */
        showController: boolean;
        /**
         * Sets the full screen button image to minimize/maximize manually. If the {@link UI.VideoView#onFullScreenModeChanged onFullScreenModeChanged} callback wasn't assign, there won't be any changes.
         *
         * @method setFullScreenButtonImage
         * @param {Boolean} isInFullScreen  if true, full screen button image will be minimize.
         * @android
         * @since 4.3.1
         */
        setFullScreenButtonImage: (isInFullScreen: boolean) => void;
    }
    /**
     * @class UI.VideoView
     * @since 0.1
     * @extends UI.View
     * VideoView is a video holder where a video clip is played inside.
     * Supported formats for both platforms are 3GPP (.3gp) and MPEG-4 (.mp4).
     *
     *     @example
     *     const Flex      = require('@smartface/native/ui/flexlayout');
     *     const VideoView = require('@smartface/native/ui/videoview');
     *
     *     var myVideoView = new VideoView({
     *         left:10, top:10, height:250, width:250,
     *         positionType: Flex.PositionType.ABSOLUTE,
     *         onReady: function() {
     *             myVideoView.play();
     *         }
     *     });
     *     myVideoView.loadURL('url-to-videoclip');
     *
     *     myPage.layout.addChild(myVideoView);
     *
     */
    export interface IVideoView<TEvent extends string = VideoViewEvents, TMobile extends MobileOSProps<IVideoViewIOSProps, IVideoViewAndroidProps> = MobileOSProps<IVideoViewIOSProps, IVideoViewAndroidProps>> extends IView<TEvent | VideoViewEvents, any, TMobile> {
        /**
         * This function plays the loaded video clip.
         *
         * @method play
         * @android
         * @ios
         * @since 0.1
         */
        play(): void;
        /**
         * This function pauses the video clip.
         *
         * @method play
         * @android
         * @ios
         * @since 0.1
         */
        pause(): void;
        /**
         * This function stops the video clip by seeking to the initial position of the video.
         *
         * @method stop
         * @android
         * @ios
         * @since 0.1
         */
        stop(): void;
        /**
         * This function returns status of the video, if the video clip is played or not.
         *
         * @method isPlaying
         * @return {Boolean}
         * @android
         * @ios
         * @since 0.1
         */
        isPlaying(): boolean;
        /**
         * This function puts the video clip in loop.
         *
         * @method setLoopEnabled
         * @android
         * @ios
         * @param {Boolean} enabled
         * @since 0.1
         */
        setLoopEnabled(enabled: boolean): void;
        /**
         * This function loads the video clip from the given URL.
         *
         * @method loadURL
         * @android
         * @ios
         * @param {String} url
         * @since 0.1
         */
        loadURL(url: string): void;
        /**
         * This function loads the video clip from the local file.
         *
         * @method loadFile
         * @android
         * @ios
         * @param {IO.File} file
         * @since 0.1
         */
        loadFile(file: File): void;
        /**
         * This event is called when the video clip is ready to be played.
         *
         * @event onReady
         * @deprecated
         * @android
         * @ios
         * @param {Function} callback
         * @since 0.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.Ready, () => {
         * 	console.info('onReady');
         * });
         * ````
         */
        onReady: () => void;
        /**
         * This event is called when the video clip completed playing.
         *
         * @event onFinish
         * @deprecated
         * @android
         * @ios
         * @param {Function} callback
         * @since 0.1
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.Finish, () => {
         * 	console.info('onFinish');
         * });
         * ````
         */
        onFinish: () => void;
        /**
         * This event is called when the video player is failed.
         *
         * @event onFailure
         * @deprecated
         * @android
         * @ios
         * @param {Function} callback
         * @since 4.3.6
         * @example
         * ````
         * import VideoView from '@smartface/native/ui/videoview';
         *
         * const videoView = new VideoView();
         * videoView.on(VideoView.Events.Failure, () => {
         * 	console.info('onFailure');
         * });
         * ````
         */
        onFailure: () => void;
        /**
         * This function seeks to desired position of the video.
         *
         * @method seekTo
         * @android
         * @ios
         * @param {Number} milliseconds
         * @since 0.1
         */
        seekTo(time: number): void;
        /**
         * This function returns the total duration of the video.
         *
         * @property {Number} totalDuration
         * @android
         * @ios
         * @since 0.1
         */
        readonly totalDuration: number;
        /**
         * This function returns the current duration of the video.
         *
         * @property {Number} currentDuration
         * @android
         * @ios
         * @since 0.1
         */
        readonly currentDuration: number;
        /**
         * Configure your app to continue playing video when it goes into the background.
         * For iOS, you must add the following key to info.plist.
         * `<key>UIBackgroundModes</key><array><string>audio</string></array>`
         *
         * @property {Boolean} backgroundModeEnabled
         * @android
         * @ios
         * @since 4.3.1
         */
        backgroundModeEnabled: boolean;
        /**
         * This function sets the volume of the video clip. The range is between {0.0, 1.0}
         *
         * @method setVolume
         * @android
         * @ios
         * @param {Number} volume
         * @since 0.1
         */
        setVolume(vol: number): void;
        /**
         * This function sets the visibility of video controller
         *
         * @method setControllerEnabled
         * @android
         * @ios
         * @param {Boolean} enabled
         * @since 0.1
         */
        setControllerEnabled(enabled: boolean): void;
        /**
         * Gets/Sets the page where the videoview is put. In Android, Page is mandatory to release video resources based on your configurations.
         *
         * @property {UI.Page} page
         * @ios
         * @android
         * @since 4.3.1
         */
        page: Page | null;
    }
    const VideoView: ConstructorOf<IVideoView, Partial<IVideoView>>;
    type VideoView = IVideoView;
    export default VideoView;
}
declare module "ui/videoview/videoview.android" {
    import { IVideoView } from "ui/videoview/index";
    import File from "io/file/index";
    import Color from "ui/color/index";
    import type Page from "ui/page/index";
    import { ViewAndroid } from "ui/view/view.android";
    import { VideoViewEvents } from "ui/videoview/videoview-events";
    export default class VideoViewAndroid<TEvent extends string = VideoViewEvents> extends ViewAndroid<TEvent | VideoViewEvents, any, IVideoView> implements IVideoView {
        onReady: () => void;
        onFinish: () => void;
        onFailure: () => void;
        nativeInner: any;
        private _backgroundModeEnabled;
        private _page;
        private _enableStateSaving;
        private _onFullScreenModeChanged;
        private _showLoadingIndicator;
        private _nextButtonEnabled;
        private _fastForwardButtonEnabled;
        private _rewindButtonEnabled;
        private _previousButtonEnabled;
        private _controllerShowTimeoutMs;
        private _customErrorMessage;
        private _showController;
        constructor(params?: Partial<IVideoView>);
        private getAndroidProps;
        private getIOSProps;
        private setNativeEvents;
        play(): void;
        pause(): void;
        stop(): void;
        isPlaying(): boolean;
        setLoopEnabled(enabled: boolean): void;
        loadURL(url: string): void;
        loadFile(file: File): void;
        seekTo(time: number): void;
        setVolume(vol: number): void;
        setControllerEnabled(enabled: boolean): void;
        toString(): string;
        get totalDuration(): IVideoView['totalDuration'];
        get currentDuration(): IVideoView['currentDuration'];
        get page(): Page;
        set page(value: Page);
        get backgroundModeEnabled(): boolean;
        set backgroundModeEnabled(value: boolean);
        get backgroundImage(): void;
        set backgroundImage(value: void);
        get borderColor(): Color;
        set borderColor(value: Color);
        get borderRadius(): number;
        set borderRadius(value: number);
        get borderWidth(): number;
        set borderWidth(value: number);
    }
}
declare module "ui/videoview/videoview.ios" {
    import { IVideoView } from "ui/videoview/index";
    import File from "io/file/index";
    import Page from "ui/page/index";
    import ViewIOS from "ui/view/view.ios";
    import { VideoViewEvents } from "ui/videoview/videoview-events";
    export default class VideoViewIOS<TEvent extends string = VideoViewEvents> extends ViewIOS<TEvent | VideoViewEvents, any, IVideoView> implements IVideoView {
        protected avPlayerViewController: __SF_AVPlayerViewController;
        protected avPlayer: __SF_AVPlayer;
        private _loopEnabled;
        private _page;
        constructor(params?: Partial<IVideoView>);
        private getAndroidParams;
        private getIOSParams;
        private setAVControllerEvents;
        onReady: () => void;
        onFinish: () => void;
        onFailure: () => void;
        play(): void;
        pause(): void;
        stop(): void;
        setLoopEnabled(enabled: boolean): void;
        loadURL(url: string): void;
        loadFile(file: File): void;
        seekTo(time: number): void;
        setVolume(vol: number): void;
        setControllerEnabled(enabled: boolean): void;
        isPlaying(): boolean;
        get page(): Page | null;
        set page(value: Page | null);
        get totalDuration(): number;
        get currentDuration(): number;
        backgroundModeEnabled: boolean;
    }
}
declare module "ui/view/ripple/with-ripple-effect.android" {
    import View from "ui/view/index";
    export function withRippleEffect(view: View): void;
}
declare module "ui/webbrowser/index" {
    import Page from "ui/page/index";
    import Color from "ui/color/index";
    export class AbstractWebBrowserOptions {
        constructor(params?: Partial<AbstractWebBrowserOptions>);
        get url(): string;
        set url(value: string);
        get barColor(): Color;
        set barColor(value: Color);
        /**
         * Gets the itemColor.
         *
         * @returns {Color}
         * @ios
         * @since 2.0.11
         */
        get itemColor(): Color;
        /**
         * Sets the itemColor.
         *
         * @property {Color} [value = Color.BLACK]
         * @ios
         * @since 2.0.11
         */
        set itemColor(value: Color);
        /**
         * Gets the statusBar visibility.
         *
         * @returns {boolean}
         * @ios
         * @since 2.0.11
         */
        get statusBarVisible(): boolean;
        /**
         * Sets the statusBar visibility.
         *
         * @property {boolean} [value = true]
         * @ios
         * @since 2.0.11
         */
        set statusBarVisible(value: boolean);
    }
    /**
     * @class UI.WebBrowser
     * @since 2.0.11
     *
     * An object that provides a standard interface for browsing the web.
     *
     *       @example
     *       const WebBrowser = require('@smartface/native/ui/webbrowser');
     *       var webOptions = new WebBrowser.Options();
     *       webOptions.url = "https://smartface.io"
     *       webOptions.barColor = Color.RED;
     *       webOptions.ios.itemColor = Color.BLUE;
     *       WebBrowser.show(page,webOptions);
     */
    export class AbstractWebBrowser {
        /**
         * @class UI.WebBrowser.Options
         * @since 2.0.11
         *
         * An object that provides a standard interface for browsing the web.
         *
         *      @example
         *      var webOptions = new WebBrowser.Options();
         *      webOptions.url = "https://smartface.io"
         *      webOptions.barColor = Color.RED;
         *      webOptions.ios.itemColor = Color.BLUE;
         *      WebBrowser.show(page,options);
         */
        static readonly Options: new (params?: Partial<AbstractWebBrowserOptions>) => AbstractWebBrowserOptions;
        /**
         *
         * This function shows WebBrowser on the given UI.Page.
         *
         * @event show
         * @param {UI.Page} page
         * @param {UI.WebBrowser.Options} options
         * @static
         * @android
         * @ios
         * @since 2.0.11
         */
        static show(page: Page, options: AbstractWebBrowserOptions): void;
        constructor(params?: AbstractWebBrowserOptions);
        /**
         * Only HTTP and HTTPS URLs are supported.
         *
         * @property {String} [url = ""]
         * @android
         * @ios
         * @since 2.0.11
         */
        url: string;
        /**
         * The color to tint the background of the header bar and bottom bar.
         *
         * @property {UI.Color} [barColor = UI.Color.WHITE]
         * @android
         * @ios
         * @since 2.0.11
         */
        barColor: Color;
        /**
         * The color to tint the the control buttons on the header bar and bottom bar.
         *
         * @property {UI.Color} [itemColor = UI.Color.create("#00A1F1")]
         * @ios
         * @since 0.1
         */
        itemColor: Color;
        /**
         * Gets/sets visibility of the status bar.
         *
         * @property {Boolean} [statusBarVisible = true]
         * @removed 4.0.0 Use {@link Application.statusBar} instead
         * @ios
         * @since 0.1
         */
        statusBarVisible: boolean;
    }
    const WebBrowser: typeof AbstractWebBrowser;
    type WebBrowser = AbstractWebBrowser;
    export default WebBrowser;
}
declare module "ui/webbrowser/webbrowseroptions" {
    import { AbstractWebBrowserOptions } from "ui/webbrowser/index";
    import Color from "ui/color/index";
    export class WebBrowserOptions implements AbstractWebBrowserOptions {
        private _url;
        private _barColor;
        private _itemColor;
        private _statusBarVisible;
        constructor(params?: Partial<WebBrowserOptions>);
        get url(): string;
        set url(value: string);
        get barColor(): Color;
        set barColor(value: Color);
        get itemColor(): Color;
        set itemColor(value: Color);
        get statusBarVisible(): boolean;
        set statusBarVisible(value: boolean);
    }
}
declare module "ui/webbrowser/webbrowser.android" {
    import { AbstractWebBrowser } from "ui/webbrowser/index";
    import Color from "ui/color/index";
    import Page from "ui/page/index";
    import { WebBrowserOptions } from "ui/webbrowser/webbrowseroptions";
    export class WebBrowserAndroid implements AbstractWebBrowser {
        static readonly Options: typeof WebBrowserOptions;
        url: string;
        barColor: Color;
        itemColor: Color;
        statusBarVisible: boolean;
        constructor(params?: Partial<WebBrowserAndroid>);
        show(page: Page, options: Partial<WebBrowserAndroid>): void;
    }
}
declare module "ui/webbrowser/webbrowser.ios" {
    import { AbstractWebBrowser } from "ui/webbrowser/index";
    import Page from "ui/page/index";
    import Color from "ui/color/index";
    import { WebBrowserOptions } from "ui/webbrowser/webbrowseroptions";
    export class WebBrowserIOS implements AbstractWebBrowser {
        static readonly Options: typeof WebBrowserOptions;
        url: string;
        barColor: Color;
        itemColor: Color;
        statusBarVisible: boolean;
        constructor(params?: Partial<WebBrowserIOS>);
        show(page: Page, options: Partial<WebBrowserIOS>): void;
    }
}
declare module "ui/webview/webview.ios" {
    import ViewIOS from "ui/view/view.ios";
    import IWebView from "ui/webview/index";
    import { WebViewEvents } from "ui/webview/webview-events";
    class WebViewIOS<TEvent extends string = WebViewEvents> extends ViewIOS<TEvent | WebViewEvents, any, IWebView> implements IWebView {
        private _scrollBarEnabled;
        private _onError;
        private _onShow;
        private _onLoad;
        private _onChangedURL;
        private _safeAreaInsets;
        private _sslPinning;
        static removeAllData: () => void;
        constructor(params?: Partial<IWebView>);
        private setEvents;
        get onChangedURL(): any;
        set onChangedURL(callback: any);
        get onLoad(): any;
        set onLoad(callback: any);
        get onError(): any;
        set onError(callback: any);
        get onShow(): any;
        set onShow(callback: any);
        get userAgent(): any;
        set userAgent(value: any);
        get openLinkInside(): any;
        set openLinkInside(value: any);
        get zoomEnabled(): any;
        set zoomEnabled(value: any);
        get scrollEnabled(): any;
        set scrollEnabled(value: any);
        get bounceEnabled(): any;
        set bounceEnabled(value: any);
        get scrollBarEnabled(): boolean;
        set scrollBarEnabled(value: boolean);
        Android: {
            ConsoleMessageLevel: {};
        };
        clearCache(deleteDiskFiles: any): void;
        clearCookie(): void;
        clearAllData(): void;
        loadURL(value: string): void;
        loadFile(value: any): void;
        refresh(): void;
        loadHTML(value: any): void;
        goBack(): void;
        goForward(): void;
        evaluateJS(javascript: any, callback: any): void;
        private getAndroidProps;
        private getIOSProps;
    }
    export default WebViewIOS;
}
declare module "util/iOS/uigesturerecognizerstate" {
    enum UIGestureRecognizerState {
        possible = 0,
        began = 1,
        changed = 2,
        ended = 3,
        cancelled = 4,
        failed = 5
    }
    export default UIGestureRecognizerState;
}
